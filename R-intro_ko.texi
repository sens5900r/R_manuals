\input texinfo
@c %**start of header
@documentencoding utf-8
@setfilename R-intro.info
@settitle R 입문
@setchapternewpage on
@c %**end of header

@c Authors: If you edit/add @example(s) ,  please keep
@c  ./R-intro.R   up-to-date !
@c  ~~~~~~~~~~~
@syncodeindex fn vr


@dircategory 프로그래밍
@direntry
* R 입문: (R-intro).    An introduction to R.
@end direntry

@finalout

@include R-defs.texi
@include version.texi

@copying
본 매뉴얼은 R 버전 @value{VERSION}을 위한 것입니다.

Copyright @copyright{} 1990 W.@: N.@: Venables@*
Copyright @copyright{} 1992 W.@: N.@: Venables & D.@: M.@: Smith@*
Copyright @copyright{} 1997 R.@: Gentleman & R.@: Ihaka@*
Copyright @copyright{} 1997, 1998 M.@: Maechler@*
@Rcopyright{1999}

@quotation
@permission{}
@end quotation
@end copying


@c <FIXME>
@c Apparently AUCTeX 11.06 has a problem with '@appendixsection' entries
@c when updating nodes---the equivalent '@appendixsec' seems to work.
@c Hence changed (temporarily?) ...
@c </FIXME>

@c <NOTE>
@c Conversion to PDF fails if sectioning titles contain (user-defined)
@c macros such as @R{}.  Hence in section titles we changed @R{} to R.
@c Revert when this is fixed.
@c </NOTE>

@titlepage
@title R 입문
@subtitle Notes on @R{}: A Programming Environment for Data Analysis and 그래픽스
@subtitle Version @value{VERSION}
@author W. N. Venables, D. M. Smith
@author and the R Core Team
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifplaintext
@insertcopying
@end ifplaintext

@contents

@ifnottex
@node 상위, 서문, (dir), (dir)
@top R 입문

본 문서는 통계 계산과 그래프 작성을 위한 프로그래밍 환경인 R(``GNU S'')에 대한 입문서입니다. R은 Bell 연구소에서 John Chambers 등에 의해 개발된 S 시스템과 유사합니다. S 시스템은 1998년 ACM 소프트웨어 시스템상을 수상한 시스템으로, 상세한 정보는 @uref{https://awards.acm.org/award_winners/chambers_6640862.cfm}에서 확인할 수 있습니다. R은 선형 및 비선형 모델링, 통계 검정, 시계열 분석, 분류, 클러스터링 등 다양한 통계 및 그래픽 기술을 제공합니다.

본 매뉴얼은 데이터 타입, 프로그래밍 요소, 통계 모델링 및 그래프 작성에 대한 정보를 제공합니다.

@insertcopying

@end ifnottex

@menu
* 서문::                     
* 소개 및 기초 지식::  
* 숫자와 벡터의 간단한 조작::  
* 객체::                     
* 요인::                     
* 배열과 행렬::         
* 리스트와 데이터 프레임::       
* 파일에서 데이터 읽기::     
* 확률 분포::   
* 루프와 조건 실행::  
* 직접 함수 작성하기::  
* R에서의 통계 모델::     
* 그래픽스::                    
* 패키지::                    
* 운영체제 기능::               
* 예제 세션::            
* R 실행하기::                  
* 명령행 편집기::     
* 함수 및 변수 색인::  
* 개념 색인::               
* 참조::                  
@end menu

@node 서문, 소개 및 기초 지식, 상위, 상위
@unnumbered 서문

본 @R{} 입문서는 1990-2년 당시 Adelaide 대학에서 작성된 @Sl{}과 @SPLUS{} 환경을 설명하는 원래의 노트에서 파생되었습니다. @R{}과 @Sl{} 프로그램 간의 차이를 반영하기 위해 일부 수정을 가했으며 일부 내용은 확장하였습니다.

본 매뉴얼을 이런 방식으로 수정하여 배포할 수 있는 권한을 부여해준 빌 베너블스 (그리고 데이비드 스미스)에게 감사의 말씀을 전합니다. 그들은 예전부터 @R{}을 지지하는 역할을 해왔습니다.

의견 및 정정 사항은 언제나 환영합니다. 이메일을 통해 @email{R-help@@R-project.org}로 보내주시기 바랍니다.

@subheading 독자들에게 제안하는 사항

대부분의 @R{} 초보자는 부록 A의 입문 세션에서 시작합니다. 이를 통해 @R{} 세션의 스타일에 익숙해지고, 더 중요한 것은 실제로 무엇이 일어나는지에 대한 즉각적인 피드백을 받을 수 있습니다.

많은 사용자들은 @R{}의 그래픽 기능을 주로 사용합니다. @xref{그래픽스}에서는 대부분의 섹션을 소화하기 전에도 읽을 수 있으며 기다릴 필요가 없습니다.

@menu
* 소개 및 기초 지식::
@end menu

@node 소개 및 기초 지식, 숫자와 벡터의 간단한 조작, 서문, 상위
@chapter 소개 및 기초 지식

@menu
* R 환경::           
* 관련 소프트웨어 및 문서::  
* R과 통계::            
* R과 윈도우 시스템::     
* R 대화형 사용하기::       
* 도움말 얻기::                
* R 명령어; 대소문자 구분 등::  
* 이전 명령어 재실행 및 수정::
* 파일로부터 명령 실행 또는 출력 방향 변경::  
* 데이터 영속성 및 객체 제거::  
@end menu

@node R 환경, 관련 소프트웨어 및 문서, 소개 및 기초 지식, 소개 및 기초 지식
@section R 환경

@R{}는 데이터 조작, 계산 및 그래픽 표시를 위한 통합 소프트웨어 패키지입니다. 그 중 일부는 다음과 같습니다.

@R{}은 데이터 조작, 계산 및 그래픽 표시를 위한 통합 소프트웨어 시스템입니다. 그 중에서도,

@itemize @bullet
@item
효과적인 데이터 처리 및 저장 기능,
@item
배열 및 행렬에 대한 연산을 위한 연산자 모음,
@item
데이터 분석을 위한 크고 일관된 통합 도구 모음,
@item
컴퓨터에서 직접 또는 하드카피로 데이터 분석 및 표시를 위한 그래픽 기능,
@item
조건문, 루프, 사용자 정의 재귀 함수 및 입출력 기능을 포함하는 잘 개발된 간단하고 효과적인 프로그래밍 언어인 'S'가 있습니다. (실제로 시스템에서 제공하는 대부분의 함수는 @Sl{} 언어로 작성됩니다.)
@end itemize

"환경"이라는 용어는 다른 데이터 분석 소프트웨어와 달리 매우 구체적이고 융통성이 없는 도구들의 점증적인 축적이 아니라 전체적으로 계획된 일관된 시스템으로 특징화하고자 합니다.

@R{}는 대화형 데이터 분석 방법의 신규 개발을 위한 도구입니다. 빠르게 발전하여 많은 @emph{패키지}들이 확장되어왔습니다. 그러나 @R{}로 작성된 대부분의 프로그램은 사실상 단일 데이터 분석을 위해 작성된 일회성 코드입니다.

@node 관련 소프트웨어 및 문서, R과 통계, R 환경, 소개 및 기초 지식
@section 관련 소프트웨어 및 문서

@R{}은 Bell 연구소의 Rick Becker, John Chambers, Allan Wilks에 의해 개발된 @Sl{} 언어의 구현체로 볼 수 있으며 @SPLUS{} 시스템의 기초도 됩니다.

@Sl{} 언어의 발전은 John Chambers와 공동 저자들이 쓴 네 권의 책으로 특징 지어집니다. @R{}에서는 Richard A.@: Becker, John M.@: Chambers 및 Allan R.@: Wilks가 저술했으며 @emph{The New @Sl{} Language: A Programming Environment for Data Analysis and 그래픽스}라는 제목입니다. @Sl{}의 1991 릴리스(@Sl{} 버전 3)의 새로운 기능은 John M.@: Chambers와 Trevor J.@: Hastie가 편집한 @emph{Statistical Models in @Sl{}}에서 다루고 있습니다. @pkg{methods} 패키지의 형식 및 클래스는 John M.@: Chambers가 저술했으며 @emph{Programming with Data}에서 설명한 것을 기반으로 합니다. 자세한 참조는 @xref{참조}를 참고하세요.

지금은 @R{}을 사용한 데이터 분석 및 통계에 대한 설명서가 많이 있으며, @Sl{}/@SPLUS{} 문서는 일반적으로 @R{}에서도 사용할 수 있습니다. 차이점을 고려하여 사용하면 됩니다. @xref{What documentation exists for R?, , , R-FAQ, The R statistical system FAQ}.

@node R과 통계, R과 윈도우 시스템, 관련 소프트웨어 및 문서, 소개 및 기초 지식
@section R과 통계
@cindex 패키지

@R{} 환경 소개에서는 @emph{통계}를 언급하지 않았습니다. 그러나 많은 사람들이 @R{}을 통계 시스템으로 사용합니다. 우리는 많은 고전적이고 현대적인 통계 기법들이 구현된 환경으로 생각합니다. 이 중 일부는 기본 @R{} 환경에 내장되어 있지만, 많은 기능들은 @emph{패키지}로 제공됩니다. 약 25개의 패키지가 @R{}와 함께 제공되며(표준 및 권장 패키지라고 함), 인터넷 사이트(@uref{https://CRAN.R-project.org}) 및 기타곳에서 @acronym{CRAN} 패밀리를 통해 많은 패키지들을 사용할 수 있습니다. 패키지에 대한 자세한 내용은 (@pxref{패키지})에서 설명합니다.

대부분의 고전적인 통계 기법과 최신 방법론들이 @R{}과 함께 사용할 수 있지만, 사용자들은 조금의 노력을 기울여야 할 수도 있습니다.

@Sl{} (따라서 @R{})와 다른 주요 통계 시스템 간에는 철학적인 중요한 차이가 있습니다. @Sl{}에서는 통계 분석을 일련의 단계로 수행하며, 중간 결과는 객체에 저장됩니다. 따라서 SAS와 SPSS는 회귀 분석이나 판별 분석에서 많은 출력을 제공하지만, @R{}은 최소한의 출력을 제공하고 결과를 fit 객체에 저장하여 후속 @R{} 함수에서 쿼리할 수 있도록 합니다.

@node R과 윈도우 시스템, R 대화형 사용하기, R과 통계, 소개 및 기초 지식
@section R과 윈도우 시스템

@R{}를 사용하는 가장 편리한 방법은 윈도우 시스템을 실행하는 그래픽 워크스테이션에서 사용하는 것입니다. 이 가이드는 이러한 시설을 가진 사용자를 대상으로합니다. 특히, 때로는 X 윈도우 시스템에서 @R{}을 사용하는 것을 언급 할 것이지만, 말하는 대부분의 내용은 @R{} 환경의 어떤 구현에도 일반적으로 적용됩니다.

대부분의 사용자는 컴퓨터의 운영 체제와 직접 상호 작용해야 할 필요성을 느낄 것입니다. 이 가이드에서는 주로 UNIX 기계에서 운영 체제와 상호 작용하는 것을 다룹니다. Windows 또는 macOS에서 @R{}을 실행하는 경우 일부 작은 조정이 필요합니다.

@R{}의 사용자 정의 기능을 최대한 활용하기 위해 워크스테이션을 설정하는 것은 간단하지만 다소 지루한 절차이며, 여기에서는 자세히 다루지 않습니다. 어려움을 겪는 사용자는 지역 전문가의 도움을 받아야합니다.

@node R 대화형 사용하기, 도움말 얻기, R과 윈도우 시스템, 소개 및 기초 지식
@section R 대화형 사용하기

@R{} 프로그램을 사용할 때 입력 명령을 예상할 때는 프롬프트(prompt)가 발생합니다. 기본 프롬프트는 @samp{@code{>}}이며, UNIX에서는 셸 프롬프트와 동일할 수 있으므로 아무 일도 일어나지 않는 것처럼 보일 수 있습니다. 그러나 우리가 나중에 볼 것처럼, 원한다면 다른 @R{} 프롬프트로 쉽게 변경할 수 있습니다. 우리는 UNIX 셸 프롬프트가 @samp{@code{$}}라고 가정합니다.

UNIX에서 @R{}을 사용하는 경우 첫 번째 경우를 위한 제안된 절차는 다음과 같습니다:

@enumerate
@item
@R{}을 사용할 때 데이터 파일을 보관할 별도의 하위 디렉터리를 만드십시오. 예를 들어, @file{work}이라는 이름의 하위 디렉터리를 만듭니다. 이 디렉터리는 이 문제를 위해 @R{}을 사용할 때 작업 디렉터리가 될 것입니다.

@example
$ mkdir work
$ cd work
@end example

@item
R 명령어로 @R{} 프로그램을 시작하세요.

@example
$ R
@end example

@item
이 지점에서 나중에 설명할 @R{} 명령어를 실행할 수 있습니다.

@item
@R{} 프로그램을 종료하려면 다음 명령어를 입력합니다.

@example
> q()
@end example

이 시점에서 @R{} 세션의 데이터를 저장할 것인지 물어보게 됩니다. 일부 시스템에서는 대화 상자가 나타나고, 다른 시스템에서는 @kbd{yes}, @kbd{no}, @kbd{cancel} 중 하나로 응답할 수 있는 텍스트 프롬프트가 표시됩니다. 저장하고 종료할지, 저장하지 않고 종료할지, 또는 @R{} 세션으로 돌아갈지 선택할 수 있습니다. 저장된 데이터는 이후 @R{} 세션에서 사용할 수 있습니다.

@end enumerate

이후의 @R{} 세션은 간단합니다.

@enumerate

@item
작업 디렉토리로 @file{work}를 지정하고 이전과 같은 방법으로 프로그램을 시작하세요:

@example
$ cd work
$ R
@end example

@item
@R{} 프로그램을 사용하고, 세션의 끝에서 @code{q()} 명령을 사용하여 프로그램을 종료합니다.

@end enumerate

Windows에서 @R{}을 사용하려면 기본적으로 동일한 절차를 따릅니다. 작업 디렉토리로 폴더를 만들고 @R{} 바로 가기에서 "시작 위치" 필드로 설정하십시오. 그런 다음 아이콘을 두 번 클릭하여 @R{}을 시작하십시오.

@section 입문 세션

진행하기 전에 컴퓨터에서 @R{}을 체험해 보고 싶어하는 독자들은 강력하게 권장되는 @ref{예제 세션}의 입문 세션을 실습해 보기 바랍니다.

@node 도움말 얻기, R 명령어; 대소문자 구분 등, R 대화형 사용하기, 소개 및 기초 지식
@section 함수와 기능에 대한 도움말 얻기
@findex help

@R{}에는 UNIX의 @code{man} 기능과 유사한 내장 도움말 기능이 있습니다. 예를 들어 @code{solve}와 같은 특정한 명명된 함수에 대한 더 많은 정보를 얻으려면 다음 명령을 사용합니다.

@example
> help(solve)
@end example
@findex help

다른 방법은 다음과 같습니다.

@example
> ?solve
@end example
@findex ?

특수 문자로 지정된 기능의 경우, 인수는 큰따옴표 또는 작은따옴표로 묶어서 "문자열"로 만들어야 합니다. 이는 구문상 의미가 있는 몇 개의 단어(예: @code{if}, @code{for}, @code{function} 등)에 대해서도 필요합니다.

@example
> help("[[")
@end example

따옴표 중 어느 쪽을 사용해도 다른 따옴표를 이스케이프하는 데 사용할 수 있습니다. 예를 들어 @code{"It's important"}와 같은 문자열입니다. 우리는 일반적으로 이중 인용부호를 우선 사용하는 것을 권장합니다.

대부분의 @R{} 설치에서는 다음 명령을 실행하여 @HTML{} 형식의 도움말을 사용할 수 있습니다.

@example
> help.start()
@end example
@findex help.start

@noindent
이 명령은 웹 브라우저를 시작하여 하이퍼링크로 도움말 페이지를 탐색할 수 있게 합니다. UNIX에서는 이후의 도움말 요청이 @HTML{} 기반 도움말 시스템으로 전송됩니다. @code{help.start()}로 로드된 페이지에서 `Search Engine and Keywords' 링크는 사용 가능한 함수를 검색하는 고수준 개념 목록을 포함하여 특히 유용합니다. 이것은 빠르게 지표를 잡고 @R{}의 다양한 기능을 이해하는 데 큰 도움이 될 수 있습니다.

@findex help.search
@code{help.search} 명령어 (대체로 @code{??}) 는 다양한 방식으로 도움말을 검색할 수 있게 합니다. 예를 들어,

@example
> ??solve
@end example
@findex ??

자세한 내용과 더 많은 예제를 보려면 @code{?help.search}를 사용해보세요.

도움말 주제에 대한 예제는 보통 다음과 같이 실행할 수 있습니다.

@example
> example(@var{topic})
@end example
@findex example

Windows 버전의 @R{}에는 다른 선택적 도움말 시스템이 있습니다. 다음 명령어를 사용하여 

@example
> ?help
@end example

@noindent
이에 대한 자세한 내용을 확인하십시오.

@node R 명령어; 대소문자 구분 등, 이전 명령어 재실행 및 수정, 도움말 얻기, 소개 및 기초 지식
@section R 명령어; 대소문자 구분 등


기술적으로 @R{}은 매우 간단한 구문을 가진 @emph{표현 언어}(expression language)입니다. 대소문자를 구분하기 때문에 대부분의 UNIX 기반 패키지와 같이 @emph{대소문자 구분}이 적용됩니다. 따라서 @code{A}와 @code{a}는 서로 다른 심볼로 간주되며 서로 다른 변수를 참조합니다. @R{} 이름에서 사용할 수 있는 기호 집합은 운영 체제 및 실행되는 국가(실제로는 사용 중인 @emph{로캘}(locale)에 따라)에 따라 다릅니다. 보통은 모든 알파벳과 숫자 기호가 허용됩니다@footnote{휴대용 @R{} 코드(포함하여 @R{} 패키지에서 사용할 코드)의 경우 A--Za--z0--9만 사용해야 합니다.}(일부 국가에서는 강세 기호가 있는 문자도 포함됩니다) 그리고 @samp{@code{.}}와 @samp{@code{_}}가 허용됩니다. 이름은 @samp{@code{.}} 또는 문자로 시작해야 하며 @samp{@code{.}}로 시작하는 경우 두 번째 문자는 숫자가 될 수 없습니다. 이름의 길이는 효과적으로 무제한입니다.

기본 명령은 @emph{식}(expressions) 또는 @emph{할당}(assignments)으로 구성됩니다. 식이 명령으로 주어지면 계산되고 출력되며(특별히 숨기지 않은 경우), 값은 손실됩니다. 할당은 식을 계산하고 값을 변수에 전달하지만 결과는 자동으로 인쇄되지 않습니다.

명령은 세미콜론(@samp{@code{}}) 또는 개행으로 구분됩니다. 기본 명령은 중괄호(@samp{@code{@{}}와 @samp{@code{@}}})로 하나의 복합식으로 묶일 수 있습니다. @emph{주석}은 줄 끝에서 시작하는 샵 기호(@samp{@code{#}})로 작성할 수 있습니다. 문자열 내부나 함수 정의 인수 목록 안에서는 주석을 사용할 수 없습니다.

명령이 줄 끝에서 완료되지 않은 경우 @R{}은 다른 프롬프트를 제공합니다. 기본적으로

@example
+ 
@end example

이전 명령어를 다시 실행하려면 단순히 엔터 키를 누르면 됩니다. 이전 명령어를 수정하려면 커서를 해당 명령어에 이동시켜 수정할 수 있습니다.

콘솔에서 입력한 명령행은 약 4095바이트로 제한됩니다. (@footnote{일부 콘솔은 더 많이 입력하면 허용되지 않으며, 그중 일부는 초과한 부분을 무시하고 일부는 다음 줄의 시작으로 사용합니다.}) 

@node 이전 명령어 재실행 및 수정, 파일로부터 명령 실행 또는 출력 방향 변경, R 명령어; 대소문자 구분 등, 소개 및 기초 지식
@section 이전 명령어 재실행 및 수정

UNIX의 대부분 버전과 Windows에서 @R{}은 이전 명령어를 회상하고 재실행할 수 있는 메커니즘을 제공합니다. 키보드의 수직 화살표 키를 사용하여 @emph{명령어 기록}을 앞뒤로 스크롤할 수 있습니다. 명령이 이렇게 발견되면 수평 화살표 키를 사용하여 명령 내에서 커서를 이동하고 다른 키를 사용하여 문자를 추가하거나 @key{DEL} 키를 사용하여 문자를 제거할 수 있습니다. 자세한 내용은 나중에 설명합니다. @pxref{명령행 편집기}.

UNIX에서 회상 및 편집 기능은 매우 맞춤 가능합니다. 이를 위해 @strong{readline} 라이브러리에 대한 매뉴얼 항목을 읽어보세요.

또한 Emacs 텍스트 편집기는 @R{}과 상호 작용하면서 보다 일반적인 지원 메커니즘을 제공하며, (@acronym{ESS}, @emph{Emacs Speaks Statistics}을 통해) 알아볼 수 있습니다. @xref{R and Emacs, , , R-FAQ, The R statistical system FAQ}.

@node 파일로부터 명령 실행 또는 출력 방향 변경, 데이터 영속성 및 객체 제거, 이전 명령어 재실행 및 수정, 소개 및 기초 지식
@section 파일로부터 명령 실행 또는 출력 방향 변경
@cindex 입력과 출력 방향 변경

명령어들이 무제한으로 저장된 외부 파일이 작업 디렉토리 @file{work}에 있다면, 예를 들어 @file{commands.R} 이라고 한다면, 다음 명령어를 사용하여 언제든지 @R{} 세션에서 실행할 수 있습니다.

@example
source("commands.R")
@end example
@findex source

Windows에서는 @strong{Source}도 사용 가능합니다. 이것은 @strong{File} 메뉴에 있습니다. 함수 @code{sink}는

@example
sink("record.lis")
@end example
@findex sink

@noindent
모든 이후 콘솔 출력을 외부 파일 @file{record.lis}로 이동시킵니다. 명령어

@example
sink()
@end example

@noindent
이것을 다시 콘솔로 복원합니다.

@node 데이터 영속성 및 객체 제거, , 파일로부터 명령 실행 또는 출력 방향 변경, 소개 및 기초 지식
@section 데이터 영속성 및 객체 제거

@R{}에서 생성하고 조작하는 엔티티를 @emph{객체}라고 합니다. 이들은 변수, 숫자 배열, 문자열, 함수 또는 이러한 구성 요소에서 구축된 더 일반적인 구조물일 수 있습니다.

@R{} 세션 중에는 객체가 이름에 의해 생성되고 저장됩니다(이 프로세스에 대해서는 다음 섹션에서 논의합니다). @R{} 명령어

@example
> objects()
@end example

@noindent
(또는 @code{ls()})를 사용하여 @R{}에 현재 저장된 대부분의 객체의 이름을 표시할 수 있습니다. 현재 저장된 객체의 컬렉션을 @emph{작업공간}라고합니다.
@cindex 작업공간

객체를 제거하기 위해서는 @code{rm} 함수를 사용할 수 있습니다.

@example
> rm(x, y, z, ink, junk, temp, foo, bar)
@end example
@findex rm
@cindex 객체 제거하기

@R{} 세션 중에 생성된 모든 객체는 미래 @R{} 세션에서 사용하기 위해 영구적으로 파일에 저장할 수 있습니다. 각 @R{} 세션이 끝나면 현재 사용 가능한 모든 객체를 저장할 수 있는 기회가 주어집니다. 이를 지정하면 객체가 현재 디렉토리의 @file{.RData}라는 파일에 쓰여지고, 세션에서 사용된 명령 라인은 @file{.Rhistory}라는 파일에 저장됩니다.

@R{}이 같은 디렉토리에서 나중에 시작될 때 이 파일에서 작업 공간을 다시 불러옵니다. 동시에 관련된 명령어 기록도 다시 불러옵니다.

@R{}로 수행한 분석에 대해 별도의 작업 디렉토리를 사용하는 것이 좋습니다. 분석 중에 이름이 @code{x}와 @code{y}인 객체가 생성되는 경우가 많습니다. 이러한 이름은 단일 분석의 맥락에서 종종 의미가 있지만, 동일한 디렉토리에서 여러 분석을 수행한 경우 그것들이 무엇인지 결정하기가 상당히 어려울 수 있습니다.

@node 숫자와 벡터의 간단한 조작, 객체, 소개 및 기초 지식, 상위
@chapter 간단한 조작; 숫자와 벡터
@cindex 벡터

@menu
* 벡터와 할당::      
* 벡터 연산::           
* 규칙적인 수열 생성::  
* 논리 벡터::             
* 결측값::              
* 문자 벡터::           
* 색인 벡터::               
* 기타 객체 유형::      
@end menu

@node 벡터와 할당, 벡터 연산, 숫자와 벡터의 간단한 조작, 숫자와 벡터의 간단한 조작
@section 벡터와 할당

@R{}은 명명된 @emph{데이터 구조}를 조작합니다. 가장 간단한 구조는 숫자 @emph{벡터}로, 숫자의 순차적인 모음으로 구성된 단일 객체입니다. 예를 들어, 10.4, 5.6, 3.1, 6.4, 21.7로 구성된 5개의 숫자를 가진 벡터 @code{x}를 설정하려면 @R{} 명령을 사용하십시오.

@example
> x <- c(10.4, 5.6, 3.1, 6.4, 21.7)
@end example
@findex c
@findex vector

이것은 @emph{함수}인 @code{c()}를 사용한 @emph{할당} 구문입니다. 이 문맥에서는 임의의 개수의 벡터 @emph{인수}를 사용할 수 있고, 그 값은 인수를 끝에서 끝까지 연결하여 얻은 벡터입니다.@footnote{벡터 유형이 아닌 인수(예: @code{list} 모드 인수)의 경우, @code{c()}의 작동 방식이 다소 다릅니다. @ref{리스트 결합하기}을 참조하십시오.}

표현식에서 스스로 나타나는 숫자는 길이가 하나인 벡터로 간주됩니다.

할당 연산자(@samp{@code{<-}})에 주목하십시오. 이 연산자는 @samp{@code{<}} (작다'')와 @samp{@code{-}} (빼기'') 두 문자가 엄격하게 나란히 배치되어 있으며, 표현식의 값을 받는 객체를 `가리키고' 있습니다. 대부분의 상황에서 @samp{@code{=}} 연산자를 대안으로 사용할 수 있습니다.
@c 이 텍스트에서 할당 연산자는 @samp{<-}로 표시되지 않고, ``@code{<-}''로 표시됩니다.
@cindex 할당

할당은 함수 @code{assign()}를 사용하여 할당할 수도 있습니다. 위와 동일한 할당을 다음과 같이 만드는 것과 동일합니다.

@example
> assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))
@end example

@noindent
평소에 사용하는 연산자인 @code{<-}는 이에 대한 구문적 단축키로 생각할 수 있습니다.

할당은 다른 방향으로도 할당 연산자의 명확한 변경을 사용하여 수행할 수 있습니다. 따라서 같은 할당을 다음과 같이 할 수 있습니다.

@example
> c(10.4, 5.6, 3.1, 6.4, 21.7) -> x
@end example

표현식이 완전한 명령어로 사용되면 값이 인쇄되고 @emph{사라집니다}@footnote{사실, 다른 문장을 실행하기 전에 @code{.Last.value}로 여전히 사용할 수 있습니다.}. 따라서 이제 다음 명령을 사용하면

@example
> 1/x
@end example

@noindent
다섯 값의 역수가 터미널에 출력됩니다(물론 @code{x}의 값은 변경되지 않음).

다음과 같은 추가 할당

@example
> y <- c(x, 0, x)
@end example

@noindent
는 중간에 0이 있는 두 개의 @code{x} 복사본으로 구성된 11개 항목의 벡터 @code{y}를 생성합니다.

@node 벡터 연산, 규칙적인 수열 생성, 벡터와 할당, 숫자와 벡터의 간단한 조작
@section 벡터 연산

벡터는 산술 표현식에서 사용할 수 있으며, 이 경우 연산은 요소별로 수행됩니다. 동일한 표현식에서 나타나는 벡터는 모두 같은 길이일 필요가 없습니다. 길이가 다른 경우, 표현식의 값은 표현식에서 나타나는 가장 긴 벡터와 길이가 같은 벡터입니다. 표현식의 더 짧은 벡터는 가장 긴 벡터의 길이와 일치할 때까지 필요한 만큼(아마도 부분적으로) @emph{재사용됩니다}. 특히 상수는 단순히 반복됩니다. 그래서 위의 할당을 사용하여 명령을 실행하면
@cindex 재활용 규칙

@example
> v <- 2*x + y + 1
@end example

@noindent
이는 요소별로 @code{2*x}를 2.2번 반복하고, @code{y}를 한 번 반복하고, @code{1}을 11번 반복하여 합한 결과로 구성된 길이가 11인 새 벡터 @code{v}를 생성합니다.

@cindex 산술 함수와 연산자
기본 산술 연산자는 일반적인 @code{+}, @code{-}, @code{*}, @code{/} 및 거듭제곱을 위한 @code{^}입니다.

@findex +
@findex -
@findex *
@findex /
@findex ^
또한 모든 일반 산술 함수를 사용할 수 있습니다.
@code{log}, @code{exp}, @code{sin}, @code{cos}, @code{tan}, @code{sqrt} 등은 모두 일반적인 의미를 가지고 있습니다.
@findex log
@findex exp
@findex sin
@findex cos
@findex tan
@findex sqrt
@code{max}와 @code{min}은 각각 벡터의 가장 큰 요소와 가장 작은 요소를 선택합니다.
@findex max
@findex min
@code{range}는 값이 길이가 두 개인 벡터인 함수로, @code{c(min(x), max(x))}입니다.
@findex range
@code{length(x)}는 @code{x}의 요소 개수입니다.
@findex length
@code{sum(x)}는 @code{x}의 요소 합계를 제공합니다.
@findex sum
그리고 @code{prod(x)}는 그들의 곱입니다.
@findex prod

두 가지 통계 함수인 @code{mean(x)}는 표본 평균을 계산하며, 이는 @code{sum(x)/length(x)}와 동일합니다.
@findex mean
그리고 @code{var(x)}는

@example
sum((x-mean(x))^2)/(length(x)-1)
@end example
@findex var

@noindent
또는 표본 분산입니다. @code{var()}에 대한 인수가 @math{n}-by-@math{p} 행렬이면 값은 독립적인
@math{p}-변량 표본 벡터로 행을 간주하여 얻은 @math{p}-by-@math{p} 표본 공분산 행렬입니다.

@code{sort(x)}는 요소가 증가하는 순서로 배열된 @code{x}와 같은 크기의 벡터를 반환하지만, 더 유연한 정렬 기능도 사용할 수 있습니다(@code{order()} 또는 정렬을 수행하는 순열을 생성하는 @code{sort.list()} 참조).
@findex sort
@findex order

@code{max}와 @code{min}은 인수 중 가장 큰 값과 가장 작은 값을 선택한다는 점에 유의하세요. 심지어 여러 개의 벡터가 주어져도 마찬가지입니다. @emph{병렬} 최대값 및 최소값 함수 @code{pmax}와 @code{pmin}은 가장 긴 인수와 길이가 같은 벡터를 반환하며, 각 요소에는 입력 벡터 중 해당 위치의 가장 큰(가장 작은) 요소가 포함됩니다.
@findex pmax
@findex pmin

대부분의 경우 사용자는 숫자 벡터의 "숫자"가 정수, 실수 또는 복소수인지 여부에 관심이 없을 것입니다. 내부적으로 계산은 배정밀도 실수 또는 입력 데이터가 복소수인 경우 배정밀도 복소수로 수행됩니다.

복소수로 작업하려면 명시적인 복소 부분을 제공하세요. 따라서

@example
sqrt(-17)
@end example

@noindent
는 @code{NaN}과 경고를 출력하지만,

@example
sqrt(-17+0i)
@end example

@noindent
는 복소수로 계산을 수행합니다.

@menu
* 규칙적인 수열 생성::
@end menu

@node 규칙적인 수열 생성, 논리 벡터, 벡터 연산, 숫자와 벡터의 간단한 조작
@section 규칙적인 수열 생성
@cindex 규칙적인 수열

@R{}은 일반적으로 사용되는 일련의 숫자를 생성하는 여러 가지 기능을 가지고 있습니다. 예를 들어 @code{1:30}은 벡터 @code{c(1, 2, @dots{}, 29, 30)}입니다.
@c <NOTE>
@c Info는 콜론 (:)을 인덱스 항목으로 처리할 수 없습니다.
@ifnotinfo
@findex :
@end ifnotinfo
@c </NOTE>
콜론 연산자는 표현식 내에서 높은 우선 순위를 가지므로, 예를 들어 @code{2*1:15}는 벡터 @code{c(2, 4, @dots{}, 28, 30)}입니다. @code{n <- 10}을 입력하고 시퀀스 @code{1:n-1}과 @code{1:(n-1)}을 비교하세요.

@code{30:1} 구조를 사용하여 역순으로 시퀀스를 생성할 수 있습니다.

@findex seq
함수 @code{seq()}는 일련의 숫자를 생성하는 더 일반적인 기능입니다. 이 함수는 다섯 개의 인수를 가지며, 한 번의 호출에서 일부만 지정할 수 있습니다. 첫 번째와 두 번째 인수(있는 경우)는 시퀀스의 시작과 끝을 지정하며, 이 두 인수만 주어진 경우 결과는 콜론 연산자와 동일합니다. 즉, @code{seq(2,10)}은 @code{2:10}과 동일한 벡터입니다.

@code{seq()}의 인수와 다른 많은 @R{} 함수의 인수는 명명된 형식으로도 제공될 수 있으며, 이 경우 인수가 나타나는 순서는 중요하지 않습니다. 처음 두 인수는 @code{from=@var{value}}와 @code{to=@var{value}}로 명명될 수 있습니다. 따라서 @code{seq(1,30)}, @code{seq(from=1, to=30)} 및 @code{seq(to=30, from=1)}은 모두 @code{1:30}과 동일합니다. @code{seq()}의 다음 두 인수는 각각 @code{by=@var{value}}와 @code{length=@var{value}}로 명명될 수 있으며, 이는 각각 시퀀스의 단계 크기와 길이를 지정합니다. 이 둘 중 어느 것도 주어지지 않으면 기본값 @code{by=1}이 가정됩니다.

예를 들면

@example
> seq(-5, 5, by=.2) -> s3
@end example

@noindent
는 @code{s3}에서 벡터 @code{c(-5.0, -4.8, -4.6, @dots{}, 4.6, 4.8, 5.0)}를 생성합니다. 마찬가지로

@example
> s4 <- seq(length=51, from=-5, by=.2)
@end example

@noindent
는 @code{s4}에서 동일한 벡터를 생성합니다.

다섯 번째 인수는 @code{along=@var{vector}}로 명명될 수 있으며, 일반적으로 시퀀스 @code{1, 2, @dots{}, length(@var{vector})}를 생성하는 데 사용되거나 벡터가 비어 있는 경우 (그렇게 될 수 있음) 빈 시퀀스가 됩니다.

관련 함수로 @code{rep()}가 있습니다.
@findex rep
이는 다양한 복잡한 방법으로 객체를 복제하는 데 사용할 수 있습니다.
가장 간단한 형태는 다음과 같습니다.

@example
> s5 <- rep(x, times=5)
@end example

@noindent
는 @code{s5}에 @code{x}의 다섯 개 복사본을 차례로 놓습니다. 또 다른 유용한 버전은 다음과 같습니다.

@example
> s6 <- rep(x, each=5)
@end example

@noindent
는 다음 요소로 넘어가기 전에 @code{x}의 각 요소를 다섯 번 반복합니다.

@node 논리 벡터, 결측값, 규칙적인 수열 생성, 숫자와 벡터의 간단한 조작
@section 논리 벡터

숫자 벡터뿐만 아니라 @R{}은 논리 양의 조작을 허용합니다. 논리 벡터의 요소는 @code{TRUE}, @code{FALSE}, @code{NA} (``사용할 수 없음'' 참조) 값을 가질 수 있습니다. 처음 두 개는 종종 각각 @code{T} 및 @code{F}로 축약됩니다. 그러나 @code{T}와 @code{F}는 기본적으로 @code{TRUE}와 @code{FALSE}로 설정된 변수이지만 예약어가 아니므로 사용자가 덮어쓸 수 있습니다. 따라서 항상 @code{TRUE}와 @code{FALSE}를 사용해야 합니다.
@findex FALSE
@findex TRUE
@findex F
@findex T

논리 벡터는 @emph{조건}에 의해 생성됩니다. 예를 들면

@example

temp <- x > 13
@end example

@noindent
는 조건이 충족되지 않은 @code{x}의 요소에 해당하는 값이 @code{FALSE}이고 충족되는 경우 값이 @code{TRUE}인, @code{x}와 동일한 길이의 벡터 @code{temp}를 설정합니다.

논리 연산자는 @code{<}, @code{<=}, @code{>}, @code{>=}, 정확한 동등을 위한 @code{==} 및 불일치를 위한 @code{!=} 입니다.
@findex <
@findex <=
@findex >
@findex >=
@findex ==
@findex !=
또한 @code{c1}과 @code{c2}가 논리 표현식인 경우, @w{@code{c1 & c2}}는 그들의 교집합 (@emph{``and''}), @w{@code{c1 | c2}}는 그들의 합집합 (@emph{``or''}), 그리고 @code{!c1}은 @code{c1}의 부정입니다.
@findex !
@findex |
@findex &

논리 벡터는 일반 산술에 사용될 수 있으며, 이 경우 @code{FALSE}는 @code{0}이 되고 @code{TRUE}는 @code{1}이 되는 숫자 벡터로 강제 변환됩니다. 그러나 논리 벡터와 강제 변환된 숫자 벡터가 동일하지 않은 경우가 있습니다. 예를 들어 다음 하위 섹션을 참조하십시오.

@node 결측값, 문자 벡터, 논리 벡터, 숫자와 벡터의 간단한 조작
@section 결측값
@cindex 결측값

어떤 경우에는 벡터의 구성 요소가 완전히 알려지지 않을 수 있습니다. 요소 또는 값이 통계적 의미에서 "사용할 수 없거나" "결측값"인 경우, 벡터 내에 해당 값에 대한 공간을 특수 값 @code{NA}를 할당함으로써 예약할 수 있습니다.
@findex NA
일반적으로 @code{NA}에서 수행되는 모든 작업은 @code{NA}가 됩니다. 이 규칙의 동기는 단순히 작업의 명세가 불완전한 경우 결과를 알 수 없으므로 사용할 수 없기 때문입니다.

@findex is.na
함수 @code{is.na(x)}는 @code{x}와 크기가 같은 논리 벡터를 제공하며, 해당 요소가 @code{NA}인 경우에만 값이 @code{TRUE}입니다.

@example
> z <- c(1:3,NA);  ind <- is.na(z)
@end example

논리 표현식 @code{x == NA}는 @code{is.na(x)}와는 매우 다르다는 것에 유의하십시오. 왜냐하면 @code{NA}는 실제 값이 아니라 사용할 수 없는 수량을 표시하는 마커이기 때문입니다. 따라서 @code{x == NA}는 논리 표현식 자체가 완전하지 않고 따라서 결정할 수 없으므로 @code{x}와 길이가 같은 벡터이며 그 값은 모두 @code{NA}입니다.

또한 수치 계산으로 생성되는 두 번째 종류의 "결측값"이 있으며, 이를 @emph{Not a Number} 즉, @code{NaN}이라고 합니다.
@findex NaN
예시는 다음과 같습니다.

@example
> 0/0
@end example

@noindent
또는

@example
> Inf - Inf
@end example

@noindent
둘 다 결과가 합리적으로 정의될 수 없기 때문에 @code{NaN}를 반환합니다.

요약하면, @code{is.na(xx)}는 @code{NA}와 @code{NaN} 값 모두에 대해 @code{TRUE}입니다. 이를 구별하기 위해, @code{is.nan(xx)}는 @code{NaN}에 대해서만 @code{TRUE}입니다.
@findex is.nan

결측값은 때때로 따옴표 없이 문자 벡터를 인쇄할 때 @code{<NA>}로 인쇄됩니다.

@node 문자 벡터, 색인 벡터, 결측값, 숫자와 벡터의 간단한 조작
@section 문자 벡터
@cindex 문자 벡터

문자 수량과 문자 벡터는 @R{}에서 자주 사용되며, 예를 들어 플롯 라벨로 사용됩니다. 필요한 경우 두 개의 따옴표로 구분된 문자열로 표시됩니다. 예를 들어, @code{"x-values"}, @code{"New iteration results"}와 같습니다.

문자열은 일치하는 두 개의 (@code{"}) 또는 하나의 (@code{'}) 따옴표를 사용하여 입력되지만, 두 개의 따옴표를 사용하여 인쇄되거나(또는 때때로 따옴표 없이 인쇄됩니다). C 스타일 이스케이프 시퀀스를 사용하며 @code{}를 이스케이프 문자로 사용합니다. 따라서 @code{}는 @code{\}로 입력되고 인쇄되며, 두 개의 따옴표 안에서 @code{"}는 @code{"}로 입력됩니다. 다른 유용한 이스케이프 시퀀스는 @code{\n}(줄 바꿈), @code{\t}(탭) 및 @code{\b}(백스페이스)입니다. 전체 목록은 @command{?Quotes}를 참조하십시오.

문자 벡터는 @code{c()} 함수를 사용하여 벡터로 연결할 수 있으며, 그 사용 예시는 자주 나타납니다.
@findex c

@findex paste
@code{paste()} 함수는 임의의 개수의 인수를 가져와 문자열로 하나씩 연결합니다. 인수 중에서 주어진 숫자는 분명한 방법으로 문자열로 변환되며, 즉 인쇄되는 경우와 동일한 방법으로 변환됩니다. 기본적으로 인수는 결과에서 하나의 공백 문자로 구분되지만, 명명된 인수인 @code{sep=@var{string}}을 사용하여 @code{@var{string}}(빈 문자열일 수 있음)으로 변경할 수 있습니다.

예를 들어,

@example

labs <- paste(c("X","Y"), 1:10, sep="")
@end example

@noindent
은 @code{labs}를 다음과 같은 문자 벡터로 만듭니다.

@example
c("X1", "Y2", "X3", "Y4", "X5", "Y6", "X7", "Y8", "X9", "Y10")
@end example

특히 여기서 짧은 목록의 재활용이 발생함에 유의하십시오. 따라서 @code{c("X", "Y")}는 시퀀스 @code{1:10}과 일치하도록 5번 반복됩니다.
@footnote{@code{paste(..., collapse=@var{ss})}는 인수를 @var{ss} 사이에 두고 하나의 문자열로 연결합니다. 예를 들어, @code{ss <- "|"}. 문자 조작을 위한 더 많은 도구가 있으며, @code{sub} 및 @code{substring}의 도움말을 참조하십시오.}

@node 색인 벡터, 기타 객체 유형, 문자 벡터, 숫자와 벡터의 간단한 조작
@section 색인 벡터; 데이터 세트의 하위 집합 선택 및 수정
@cindex 인덱싱 벡터

벡터의 요소 하위 집합은 대괄호 안에 있는 @emph{색인 벡터}를 벡터 이름에 추가하여 선택할 수 있습니다. 보다 일반적으로 벡터로 평가되는 모든 표현식은 표현식 바로 뒤에 대괄호 안에 있는 색인 벡터를 추가하여 이와 유사한 요소의 하위 집합을 선택할 수 있습니다.

@c FIXME: 여기에 subset()에 대한 앞 참조 추가
@c FIXME 및 subset()에 대한 단락 추가 {데이터 프레임 뒤에 와야 함...
@c FIXME ...

이러한 색인 벡터는 4가지 고유한 유형 중 하나가 될 수 있습니다.

@enumerate

@item
@strong{논리 벡터}. 이 경우, 색인 벡터는 선택할 요소가 있는 벡터와 동일한 길이로 재사용됩니다.
색인 벡터에서 @code{TRUE}에 해당하는 값이 선택되고 @code{FALSE}에 해당하는 값은 생략됩니다. 예를 들어

@example
> y <- x[!is.na(x)]
@end example

@noindent
는 객체 @code{y}를 생성(또는 다시 생성)하고, @code{x}의 누락되지 않은 값들을 동일한 순서대로 포함합니다. @code{x}에 결측값이 있으면 @code{y}는 @code{x}보다 짧을 것입니다.
또한

@example
> (x+1)[(!is.na(x)) & x>0] -> z
@end example

@noindent
는 객체 @code{z}를 생성하고 @code{x}의 해당 값이 누락되지 않고 양수인 경우 벡터 @code{x+1}의 값을 그 안에 넣습니다.

@item
@strong{양의 정수량 벡터}. 이 경우 색인 벡터의 값은 @{1, 2, @dots{}, @code{length(x)}@} 집합에 있어야 합니다. 벡터의 해당 요소가 선택되고 결과에 @emph{그 순서대로} 연결됩니다. 색인 벡터는 어떤 길이든 될 수 있으며 결과는 색인 벡터와 같은 길이입니다. 예를 들어, @code{x[6]}은 @code{x}의 여섯 번째 구성 요소이며,

@example
> x[1:10]
@end example

@noindent
는 @code{x}의 처음 10개 요소를 선택합니다 (@code{length(x)}가 10 미만이 아닌 경우). 또한,

@example
> c("x","y")[rep(c(1,2,2,1), times=4)]
@end example

@noindent
(약간 이례적인 작업이긴 하지만) 4번 반복된 @code{"x", "y", "y", "x"}로 구성된 길이가 16인 문자 벡터를 생성합니다.

@item
@strong{음의 정수량 벡터}. 이러한 색인 벡터는 포함되지 않은 값이 아닌 @emph{제외된} 값을 지정합니다. 따라서

@example
> y <- x[-(1:5)]
@end example

@noindent
는 @code{x}의 처음 다섯 개 요소를 제외한 모든 요소를 @code{y}에 저장합니다.

@item
@strong{문자열 벡터}. 이 가능성은 객체에 컴포넌트를 식별하기 위한 @code{names} 속성이 있는 경우에만 적용됩니다. 이 경우 이름 벡터의 하위 벡터를 위의 항목 2에서와 같이 양의 정수 레이블과 동일한 방식으로 사용할 수 있습니다.

@example
> fruit <- c(5, 10, 1, 20)
> names(fruit) <- c("orange", "banana", "apple", "peach")
> lunch <- fruit[c("apple","orange")]
@end example

이 방법의 장점은 영숫자 @emph{이름}이 @emph{숫자 인덱스}보다 기억하기 쉽다는 것입니다. 이 옵션은 특히 데이터 프레임과 관련하여 나중에 살펴볼 것입니다.

@end enumerate


색인이 지정된 표현식은 할당의 수신측에도 나타날 수 있으며, 이 경우 할당 작업은 벡터의 @emph{해당 요소에만} 수행됩니다. 표현식은 @code{vector[@var{index_vector}]} 형식이어야 하며 벡터 이름 대신 임의의 표현식을 사용하는 것은 여기서 큰 의미가 없습니다.

예를 들어,

@example

x[is.na(x)] <- 0
@end example

@noindent
는 @code{x}의 누락된 값들을 0으로 대체하며,

@example

y[y < 0] <- -y[y < 0]
@end example

@noindent
는 다음과 같은 효과를 갖습니다.

@example

y <- abs(y)
@end example

@node 기타 객체 유형, , 색인 벡터, 숫자와 벡터의 간단한 조작
@section 기타 객체 유형

벡터는 @R{}에서 가장 중요한 객체 유형이지만, 나중에 더 자세히 살펴볼 몇 가지 다른 유형이 있습니다.

@itemize @bullet
@item
@emph{행렬} 또는 일반적으로 @emph{배열}은 벡터의 다차원 일반화입니다. 사실, 이것들은 두 개 이상의 인덱스로 인덱싱할 수 있는 벡터이며 특별한 방법으로 출력됩니다. @xref{배열과 행렬}.

@item
@emph{요인}은 범주형 데이터를 처리하는 간결한 방법을 제공합니다. @xref{요인}.

@item
@emph{리스트}는 다양한 요소가 동일한 유형일 필요가 없으며 종종 벡터 또는 리스트 자체인 벡터의 일반적인 형태입니다. 리스트는 통계 계산 결과를 반환하는 편리한 방법을 제공합니다. @xref{리스트}.

@item
@emph{데이터 프레임}은 열이 다른 유형일 수 있는 행렬과 같은 구조입니다. 데이터 프레임을 관측 단위별로 하나의 행이 있으며 숫자형과 범주형 변수가 모두 있는 '데이터 행렬'로 생각하십시오. 많은 실험은 데이터 프레임으로 가장 잘 설명됩니다: 처리는 범주형이지만 반응은 수치형입니다. @xref{데이터 프레임}.

@item
@emph{함수}는 @R{}에서 객체 자체이며 프로젝트의 작업 공간에 저장할 수 있습니다. 이를 통해 @R{}을 간단하고 편리하게 확장할 수 있습니다. @xref{직접 함수 작성하기}.

@end itemize

@node 객체, 요인, 숫자와 벡터의 간단한 조작, 상위
@chapter 객체, 그들의 모드와 속성
@cindex 객체
@cindex 속성

@menu
* 내재적 속성 모드와 길이::  
* 객체의 길이 변경::  
* 속성 가져오기 및 설정::  
* 객체의 클래스::      
@end menu

@node 내재적 속성 모드와 길이, 객체의 길이 변경, 객체, 객체
@section 내재적 속성 모드와 길이

@R{}이 작업하는 개체는 기술적으로 @emph{객체}라고 알려져 있습니다. 예로 들어, 숫자(실수) 또는 복소수 값의 벡터, 논리 값의 벡터 및 문자열 벡터가 있습니다. 이들은 컴포넌트가 모두 동일한 유형 또는 @emph{모드}인 "원자" 구조로 알려져 있습니다. 즉, @emph{숫자}@footnote{@emph{숫자} 모드는 사실상 두 가지 구분되는 모드, 즉 @emph{정수}와 @emph{배정밀도}의 혼합물입니다. 설명서에서 설명한 바와 같습니다.}, @emph{복소수}, @emph{논리}, @emph{문자} 및 @emph{원시}입니다.

벡터는 값이 @emph{동일한 모드여야} 합니다. 따라서 주어진 벡터는 @emph{논리}, @emph{숫자}, @emph{복소수}, @emph{문자} 또는 @emph{원시} 중 명확하게 하나여야 합니다. (이 규칙의 유일한 예외처럼 보이는 것은 사용할 수 없는 수량에 대해 나열된 @code{NA}라는 특수한 "값"이지만, 사실 @code{NA}의 여러 유형이 있습니다.) 벡터는 비어 있을 수도 있고 여전히 모드를 가질 수 있습니다. 예를 들어, 빈 문자열 벡터는 @code{character(0)}로 나열되고 빈 숫자 벡터는 @code{numeric(0)}로 나열됩니다.

@R{}은 또한 @emph{리스트}라고 불리는 객체를 처리하며, 이들은 @emph{list} 모드입니다. 이들은 개별적으로 어떤 모드든 될 수 있는 객체의 순차적인 시퀀스입니다. @emph{리스트}는 컴포넌트가 그 자체로 리스트일 수 있기 때문에 원자 구조가 아닌 "재귀적" 구조로 알려져 있습니다.

다른 재귀적 구조는 @emph{function}과 @emph{expression} 모드의 구조입니다. 함수는 @R{} 시스템의 일부분을 구성하는 객체이며 나중에 자세히 다루게 될 사용자 작성 함수와 유사합니다. 객체로서의 표현식은 이 가이드에서 논의되지 않을 @R{}의 고급 부분을 형성하지만, @R{}에서 모델링에 사용되는 @emph{식}을 논의할 때 간접적으로 다룰 것입니다.

객체의 @emph{모드}란 그 기본 구성 요소의 기본 유형을 의미합니다. 이것은 객체의 "속성"의 특수한 경우입니다. 모든 객체의 또 다른 속성은 @emph{길이}입니다. 함수 @code{mode(@var{object})}와 @code{length(@var{object})}는 정의된 구조의 모드와 길이를 알아낼 때 사용할 수 있습니다@footnote{그러나 @code{length(@var{object})}가 항상 본질적으로 유용한 정보를 포함하지는 않습니다. 예를 들어, @code{@var{object}}가 함수인 경우입니다.}.

객체의 추가 속성은 보통 @code{attributes(@var{object})}에 의해 제공됩니다. 이를 참조하십시오 @ref{속성 가져오기 및 설정}. 이 때문에, @emph{mode}와 @emph{length}는 객체의 "내재적 속성"이라고도 불립니다.
@findex mode
@findex length

예를 들어, @code{z}가 길이가 100인 복소수 벡터인 경우, 표현식에서 @code{mode(z)}는 문자열 @code{"complex"}이고 @code{length(z)}는 @code{100}입니다.

@R{}은 다음과 같은 예에서처럼 합리적으로 고려될 수 있는 거의 모든 경우에 모드 변경을 처리합니다(그리고 몇 가지는 아닐 수도 있습니다).

@example
> z <- 0:9
@end example

@noindent
우리는 다음과 같이 할 수 있습니다.

@example
> digits <- as.character(z)
@end example

@noindent
이후에 @code{digits}는 문자 벡터 @code{c("0", "1", "2", @dots{}, "9")}가 됩니다. 추가적인 @emph{강제 변환} 또는 모드 변경으로 수치 벡터를 다시 구성할 수 있습니다.

@example
> d <- as.integer(digits)
@end example

@noindent
이제 @code{d}와 @code{z}는 동일합니다.@footnote{일반적으로, 수치에서 문자로의 강제 변환과 다시 문자에서 수치로의 변환은 문자 표현의 반올림 오류로 인해 정확하게 되돌릴 수 없습니다.} 모드 간의 강제 변환 또는 객체에 아직 가지고 있지 않은 다른 속성을 부여하기 위한 @code{as.@var{something}()} 형식의 함수가 많이 있습니다. 독자는 이들 함수에 익숙해지기 위해 다양한 도움말 파일을 참조해야 합니다.

@c </FIXME>

@node 객체의 길이 변경, 속성 가져오기 및 설정, 내재적 속성 모드와 길이, 객체
@section 객체의 길이 변경

"빈" 객체는 여전히 모드를 가질 수 있습니다. 예를 들어,

@example
> e <- numeric()
@end example

@noindent
은 @code{e}를 숫자 모드의 빈 벡터 구조로 만듭니다. 비슷하게 @code{character()}는 빈 문자 벡터이며 등등입니다. 어떤 크기의 객체라도 생성되면 이전 범위를 벗어난 인덱스 값을 제공함으로써 그 객체에 새로운 구성 요소를 추가할 수 있습니다. 따라서

@example
> e[3] <- 17
@end example

@noindent
이제 @code{e}는 길이가 3인 벡터가 되며 (이 시점에서 처음 두 구성 요소는 모두 @code{NA}입니다). 이것은 추가 구성 요소의 모드가 처음에 객체의 모드와 일치하는 한 모든 구조에 적용됩니다.

이러한 객체 길이의 자동 조정은 @code{scan()} 입력 함수에서 자주 사용됩니다. (@pxref{scan() 함수}.)

반대로 객체의 크기를 줄이려면 할당만으로 충분합니다. 따라서 @code{alpha}가 길이가 10인 객체라면

@example
> alpha <- alpha[2 * 1:5]
@end example

@noindent
이제 짝수 인덱스를 가진 이전 구성 요소만으로 구성된 길이가 5인 객체가 됩니다. (물론 이전 인덱스는 유지되지 않습니다.) 그런 다음 첫 번째 세 개의 값을 유지하려면

@example
> length(alpha) <- 3
@end example

@noindent
을 사용하고 벡터는 동일한 방식으로 확장할 수 있습니다(누락된 값으로).

@node 속성 가져오기 및 설정, 객체의 클래스, 객체의 길이 변경, 객체
@section 속성 가져오기 및 설정
@findex attr
@findex attributes

함수 @code{attributes(@var{object})}는 해당 객체에 대해 현재 정의된 모든 비 내재적 속성 목록을 반환합니다. 함수 @code{attr(@var{object}, @var{name})}는 특정 속성을 선택하는 데 사용할 수 있습니다. 이러한 함수는 특정 목적으로 새로운 속성을 생성하는 경우나 @R{} 객체와 생성 날짜 또는 연산자를 연결하는 등 특수한 상황에서 사용됩니다. 그러나 이 개념은 매우 중요합니다.

주의를 기울여 속성을 할당하거나 삭제해야 합니다. 속성은 @R{}에서 사용되는 객체 시스템의 일부분이기 때문입니다.

할당의 왼쪽에 사용되면 @code{@var{object}}와 새로운 속성을 연결하거나 기존 속성을 변경하는 데 사용할 수 있습니다. 예를 들어

@example
> attr(z, "dim") <- c(10,10)
@end example

@noindent
은 @R{}이 @code{z}를 마치 10x10 행렬인 것처럼 취급하게 합니다.

@node 객체의 클래스, , 속성 가져오기 및 설정, 객체
@section 객체의 클래스
@cindex 클래스

@R{}의 모든 객체에는 함수 @code{class}로 보고되는 @emph{클래스}가 있습니다. 단순한 벡터의 경우 이것은 단지 모드일 뿐이며, 예를 들어 @code{"numeric"}, @code{"logical"}, @code{"character"} 또는 @code{"list"}이지만, @code{"matrix"}, @code{"array"}, @code{"factor"} 및 @code{"data.frame"}과 같은 다른 가능한 값이 있습니다.

객체의 @emph{클래스}로 알려진 특별한 속성은 @R{}에서 객체 지향 스타일@footnote{패키지 @code{methods}에서 제공되는 `formal' 또는 `S4' 클래스를 사용한 다른 스타일이 있습니다.} 프로그래밍을 가능하게 합니다. 예를 들어, 객체가 클래스가 @code{"data.frame"}이면, 특정한 방식으로 출력되고, @code{plot()} 함수는 그래픽적으로 특정한 방식으로 표시하며, @code{summary()}와 같은 기타 일반적인 함수는 그것의 클래스에 민감한 방식으로 인수로 반응합니다.

클래스의 영향을 일시적으로 제거하려면 @code{unclass()} 함수를 사용하십시오.
@findex unclass
예를 들어, @code{winter}가 클래스 @code{"data.frame"}인 경우

@example
> winter
@end example

@noindent
는 데이터 프레임 형식으로 출력되며, 행렬과 비슷합니다. 반면에

@example
> unclass(winter)
@end example

@noindent
는 일반적인 목록으로 출력됩니다. 이 기능을 사용해야 하는 상황은 특별하지만, 클래스와 일반 함수 개념을 배우는 과정에서 이 기능이 필요한 경우가 있습니다.

일반 함수와 클래스에 대해서는 @ref{객체 지향}에서 더 자세히 설명하겠지만, 간단하게만 다룰 것입니다.

@node 요인, 배열과 행렬, 객체, 상위
@chapter 순서가 있는 요인과 순서가 없는 요인
@cindex 요인
@cindex 순서가 있는 요인

@emph{요인}은 동일한 길이의 다른 벡터의 구성 요소에 대한 이산 분류(그룹화)를 지정하는 데 사용되는 벡터 객체입니다. @R{}은 @emph{순서가 있는} 요인과 @emph{순서가 없는} 요인을 모두 제공합니다. 요인의 실제적인 용도는 모델 공식(@pxref{대조})과 관련이 있지만, 여기서는 구체적인 예를 살펴볼 것입니다.

@section 구체적인 예시

예를 들어, 호주의 모든 주와 준주로부터 30명의 세무 회계사를 뽑았다고 가정합니다. @footnote{독자는 호주에는 호주 수도 준주, 뉴사우스웨일스, 북부 준주, 퀸즐랜드, 사우스 오스트레일리아, 태즈매니아, 빅토리아 및 웨스턴 오스트레일리아와 같이 8개의 주와 준주가 있다는 것을 알고 있어야 합니다.} 개별 주 출신 상태는 주 별 약어로 이루어진 문자 벡터로 지정됩니다.

@example
> state <- c("tas", "sa",  "qld", "nsw", "nsw", "nt",  "wa",  "wa",
             "qld", "vic", "nsw", "vic", "qld", "qld", "sa",  "tas",
             "sa",  "nt",  "wa",  "vic", "qld", "nsw", "nsw", "wa",
             "sa",  "act", "nsw", "vic", "vic", "act")
@end example

문자 벡터의 경우 "정렬된"이라는 것은 알파벳순으로 정렬된 것을 의미합니다.

@emph{요인} 역시 @code{factor()} 함수를 사용하여 생성할 수 있습니다:
@findex factor

@example
> statef <- factor(state)
@end example

@code{print()} 함수는 요인을 다른 객체와 약간 다르게 처리합니다:

@example
> statef
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa
[16] tas sa  nt  wa  vic qld nsw nsw wa  sa  act nsw vic vic act
Levels:  act nsw nt qld sa tas vic wa
@end example

요인의 레벨을 알아보려면 @code{levels()} 함수를 사용할 수 있습니다.
@findex levels

@example
> levels(statef)
[1] "act" "nsw" "nt"  "qld" "sa"  "tas" "vic" "wa"
@end example

@menu
* @code{tapply()} 함수와 불규칙 배열::  
* 순서가 있는 요인::             
@end menu

@node @code{tapply()} 함수와 불규칙 배열, 순서가 있는 요인, 요인, 요인
@section @code{tapply()} 함수와 불규칙 배열
@findex tapply

이전 예시를 계속하면, 동일한 세무 회계사들의 소득이 또 다른 벡터에 있다고 가정합니다 (적절하게 큰 금액 단위로).

@example
> incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
               61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
               59, 46, 58, 43)
@end example

각 주의 평균 소득을 계산하기 위해 이제 특수 함수 @code{tapply()}를 사용할 수 있습니다:

@example
> incmeans <- tapply(incomes, statef, mean)
@end example

@noindent
레벨로 구성 요소가 레이블이 지정된 평균 벡터를 생성합니다

@example
   act    nsw     nt    qld     sa    tas    vic     wa
44.500 57.333 55.500 53.600 55.000 60.500 56.000 52.250
@end example

@code{tapply()} 함수는 함수를 적용하는 데 사용됩니다. 여기서는
@code{mean()}, 첫 번째 인수의 각 구성 요소 그룹에, 여기서는
@code{incomes}, 두 번째 구성 요소의 레벨에 의해 정의됩니다. 여기서는
@code{statef}@footnote{@code{tapply()}는 두 번째 인수가 요인이 아닌 경우에도 이 경우 작동합니다. 예를 들어, @samp{@code{tapply(incomes, state)}}와 같이, 다른 함수에 대해서도 많은 경우가 있습니다. 필요할 때 인수가 요인으로 강제 변환되기 때문입니다(@code{as.factor()}를 사용하여).}, 마치 별도의 벡터 구조처럼. 결과는 요인의 레벨 속성과 동일한 길이의 구조를 포함합니다. 독자는 도움말 문서를 참조하여 자세한 내용을 확인해야 합니다.

이제 주별 소득 평균의 표준 오차를 계산해야 한다고 가정합니다. 이를 위해 주어진 벡터에 대해 표준 오차를 계산하는 @R{} 함수를 작성해야 합니다. 표본 분산을 계산하는 @code{var()} 내장 함수가 있으므로, 이러한 함수는 매우 간단한 한 줄 짜리 함수입니다. 할당을 통해 지정됩니다:

@example
> stdError <- function(x) sqrt(var(x)/length(x))
@end example

@noindent
(함수 작성은 나중에 @ref{직접 함수 작성하기}에서 다룰 예정입니다. @R{}의 내장 함수 @code{sd()}는 다른 것임에 주의하세요.)
@findex sd
@findex var
이러한 할당 후, 표준 오차는 다음과 같이 계산됩니다.

@example
> incster <- tapply(incomes, statef, stdError)
@end example

@noindent
그런 다음 계산된 값은 다음과 같습니다.

@example
> incster
act    nsw  nt    qld     sa tas   vic     wa
1.5 4.3102 4.5 4.1061 2.7386 0.5 5.244 2.6575
@end example

주 평균 소득에 대한 일반적인 95% 신뢰 구간을 찾는 연습을 해볼 수 있습니다. 이를 위해 @code{length()} 함수를 사용하여 표본 크기를 찾고, 적절한 @math{t} 분포의 백분위수를 찾기 위해 @code{qt()} 함수를 사용하여 @code{tapply()}를 한 번 더 사용할 수 있습니다. (@R{}의 @math{t} 검정 기능도 조사해 볼 수 있습니다.)

@code{tapply()} 함수는 벡터를 여러 카테고리로 복잡하게 인덱싱하는 데도 사용할 수 있습니다. 예를 들어, 세무사를 주와 성별로 나누고 싶을 수 있습니다. 그러나 이 간단한 예시에서는 (요인이 하나뿐인 경우) 벡터의 값이 요인의 고유 항목과 일치하는 그룹으로 모이게 됩니다. 그런 다음 함수가 이러한 각 그룹에 개별적으로 적용됩니다. 값은 함수 결과의 벡터이며, 요인의 @code{levels} 속성에 의해 레이블이 지정됩니다.

벡터와 레이블링 요인의 조합은 하위 클래스 크기가 불규칙할 수 있는 @emph{불규칙 배열}이라고도 하는 것의 한 예입니다. 하위 클래스 크기가 모두 같은 경우 인덱싱은 암시적으로 이루어지고 훨씬 효율적으로 이루어집니다. 다음 섹션에서 이에 대해 알아보겠습니다.

@node 순서가 있는 요인,  , @code{tapply()} 함수와 불규칙 배열, 요인
@section 순서가 있는 요인
@findex ordered

요인의 레벨은 알파벳순으로 저장되거나 명시적으로 지정된 경우 @code{factor}에 지정된 순서대로 저장됩니다.

때때로 레벨에는 기록하고 통계 분석에서 사용하려는 자연스러운 순서가 있을 수 있습니다. @code{ordered()} 함수는 이러한 순서가 있는 요인을 생성하지만, 그렇지 않으면 @code{factor}와 동일합니다. 대부분의 경우, 순서가 있는 요인과 순서가 없는 요인의 차이는 전자가 레벨의 순서를 보여주는 것으로 인쇄되는 것이지만, 선형 모델을 적합할 때 생성되는 대조는 다릅니다.


@node 배열과 행렬, 리스트와 데이터 프레임, 요인, 상위
@chapter 배열과 행렬

@menu
* 배열::                      
* 배열 인덱싱::              
* 색인 행렬::              
* array() 함수::        
* 두 배열의 외적::  
* 배열의 일반화된 전치::  
* 행렬 기능::           
* 분할 행렬 만들기::  
* 배열과 함께 사용하는 연결 함수 c()::  
* 요인으로부터의 빈도표::  
@end menu

@node 배열, 배열 인덱싱, 배열과 행렬, 배열과 행렬
@section 배열
@cindex 배열
@cindex 행열

배열은 데이터 항목의 곱하기로 적용된 인덱스 컬렉션으로 간주될 수 있으며 예를 들어 숫자가 될 수 있습니다. @R{}에서는 배열을 생성하고 처리하기 위한 간단한 기능을 제공하며, 특히 행렬의 특별한 경우를 제공합니다.

차원 벡터는 음이 아닌 정수의 벡터입니다. 그 길이가 @math{k}이면 배열이 @math{k}차원이 됩니다. 예를 들어 행렬은 @math{2}차원 배열입니다. 차원은 차원 벡터에서 주어진 값까지 1부터 인덱싱됩니다.

@R{}에서 벡터는 차원 벡터가 그것의 @emph{dim} 속성으로 있는 경우에만 배열로 사용될 수 있습니다. 예를 들어, @code{z}가 1500개의 요소를 가진 벡터라고 가정합니다. 할당

@example
> dim(z) <- c(3,5,100)
@end example
@findex dim

@noindent
은 @math{3} x @math{5} x @math{100} 배열로 취급할 수 있게 해주는 @emph{dim} 속성을 부여합니다.

@code{matrix()} 및 @code{array()}와 같은 다른 함수는 @ref{array() 함수}에서 볼 수 있듯이 더 간단하고 자연스러운 할당을 위해 사용할 수 있습니다.

데이터 벡터의 값은 배열의 값을 FORTRAN과 같은 순서로 제공합니다. 즉, "열 우선 순서"로 첫 번째 첨자가 가장 빠르게 움직이고 마지막 첨자가 가장 느립니다.

예를 들어 배열의 차원 벡터가 @code{c(3,4,2)}이면 @code{a}에 @eqn{3 \times 4 \times 2 = 24, 3 * 4 * 2 = 24} 항목이 있고 데이터 벡터는 순서대로 @code{a[1,1,1], a[2,1,1], @dots{}, a[2,4,2], a[3,4,2]} 값을 가집니다.

배열은 일차원일 수 있습니다: 이러한 배열은 일반적으로 벡터와 동일한 방식으로 처리되지만(인쇄 포함), 예외가 혼동을 일으킬 수 있습니다.

@node 배열 인덱싱, 색인 행렬, 배열, 배열과 행렬
@section 배열 인덱싱.  배열의 하위섹션
@cindex 배열의 인덱싱 및 배열에 의한 인덱싱

I배열의 개별 요소는 배열 이름 다음에 쉼표로 구분된 대괄호 안에 첨자를 제공함으로써 참조할 수 있습니다.

더 일반적으로, 배열의 하위 섹션은 첨자 대신 일련의 @emph{색인 벡터}를 제공하여 지정할 수 있습니다. 그러나 @emph{어떤 인덱스 위치에도 빈 인덱스 벡터가 주어지면 해당 첨자의 전체 범위가 사용됩니다}.

이전 예제를 계속해서, @code{a[2,,]}는 차원 벡터 @code{c(4,2)}와 값을 포함하는 데이터 벡터가 있는 @eqn{4 \times 2, 4 * 2} 배열입니다.

@example
c(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1],
a[2,1,2], a[2,2,2], a[2,3,2], a[2,4,2])
@end example

@noindent
이 순서대로입니다. @code{a[,,]}는 전체 배열을 나타내며, 이는 첨자를 완전히 생략하고 @code{a}만 사용하는 것과 같습니다.

어떤 배열이든, 예를 들어 @code{Z}라고 하면, 차원 벡터는 @code{dim(Z)}(할당의 양쪽에서)로 명시적으로 참조할 수 있습니다.

또한, 배열 이름이 @emph{단일 첨자 또는 색인 벡터}로만 주어지면 데이터 벡터의 해당 값만 사용됩니다. 이 경우 차원 벡터는 무시됩니다. 그러나 단일 인덱스가 벡터가 아니라 배열 자체인 경우는 다음에서 설명하는 것처럼 그렇지 않습니다.

@menu
* 색인 행렬::
* array() 함수::
@end menu

@node 색인 행렬, array() 함수, 배열 인덱싱, 배열과 행렬
@section 색인 행렬

어떤 첨자 위치에서 인덱스 벡터뿐만 아니라 행렬을 사용하여 배열의 불규칙한 요소 집합에 양의 벡터를 할당하거나 불규칙한 요소 집합을 벡터로 추출하기 위해 단일 @emph{색인 행렬}을 사용할 수 있습니다.

행렬 예제는 프로세스를 명확하게 합니다. 두 번 인덱싱된 배열의 경우 색인 행렬은 두 개의 열과 원하는 만큼의 행으로 구성될 수 있습니다. 색인 행렬의 항목은 두 번 인덱싱된 배열의 행과 열 인덱스입니다. 예를 들어, @math{4} x @math{5} 배열 @code{X}가 있고 다음 작업을 수행하려고 한다고 가정해 보겠습니다.

@itemize @bullet
@item
벡터 구조로 요소 @code{X[1,3]}, @code{X[2,2]} 및 @code{X[3,1]}를 추출하고
@item
배열 @code{X}의 해당 항목을 0으로 대체합니다.
@end itemize
이 경우 @math{3} x @math{2} 첨자 배열이 필요합니다. 다음 예제와 같습니다.

@example
> x <- array(1:20, dim=c(4,5))   # @r{4 x 5 배열 생성.}
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> i <- array(c(1:3,3:1), dim=c(3,2))
> i                             # @r{@code{i}는 3 x 2 색인 배열입니다.}
     [,1] [,2]
[1,]    1    3
[2,]    2    2
[3,]    3    1
> x[i]                          # @r{해당 요소 추출}
[1] 9 6 3
> x[i] <- 0                     # @r{해당 요소를 0으로 대체.}
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    0   13   17
[2,]    2    0   10   14   18
[3,]    0    7   11   15   19
[4,]    4    8   12   16   20
>
@end example
@noindent
색인 행렬에는 음수 인덱스가 허용되지 않습니다. @code{NA}와 0 값은 허용됩니다. 색인 행렬의 0을 포함하는 행은 무시되며, @code{NA}를 포함하는 행은 결과에 @code{NA}를 생성합니다.


덜 중요한 예를 들어, @code{blocks}(@code{b} 수준)와 @code{varieties}(@code{v} 수준) 인자에 의해 정의된 블록 설계에 대한 (축소되지 않은) 설계 행렬을 생성하려고 한다고 가정합니다. 또한 실험에 @code{n}개의 구획이 있다고 가정해 봅시다. 다음과 같이 진행할 수 있습니다:

@example

Xb <- matrix(0, n, b)
Xv <- matrix(0, n, v)
ib <- cbind(1:n, blocks)
iv <- cbind(1:n, varieties)
Xb[ib] <- 1
Xv[iv] <- 1
X <- cbind(Xb, Xv)
@end example

인시던스 행렬, @code{N}을 구성하려면 다음을 사용할 수 있습니다.

@example

N <- crossprod(Xb, Xv)
@end example
@findex crossprod

그러나 이 행렬을 생성하는 더 간단한 직접적인 방법은 @code{table()}을 사용하는 것입니다.
@findex table

@example

N <- table(blocks, varieties)
@end example

색인 행렬은 숫자형이어야 합니다. 행렬로 제공되는 다른 형태의 행렬(예: 논리 또는 문자 행렬)은 색인 벡터로 취급됩니다.

@node array() 함수, 두 배열의 외적, 색인 행렬, 배열과 행렬
@section @code{array()} 함수
@findex array

벡터 구조에 @code{dim} 속성을 부여하는 것 외에도 배열은 @code{array} 함수를 사용하여 벡터에서 구성할 수 있습니다. 이 함수는 다음과 같은 형태를 가집니다.

@example

Z <- array(@var{data_vector}, @var{dim_vector})
@end example

예를 들어, 벡터 @code{h}가 24개 또는 그 이하의 숫자를 포함하고 있다면 명령

@example

Z <- array(h, dim=c(3,4,2))
@end example

@noindent
는 @code{h}를 사용하여 @code{Z}에서 @math{3} x @math{4} x @math{2} 배열을 설정합니다. @code{h}의 크기가 정확히 24인 경우 결과는 다음과 같습니다.

@example

Z <- h ; dim(Z) <- c(3,4,2)
@end example

그러나 @code{h}가 24보다 작으면 크기가 24가 되도록 처음부터 다시 값을 재활용합니다(@pxref{재활용 규칙}).
그러나 @code{dim(h) <- c(3,4,2)}는 길이 불일치에 대한 오류를 발생시킵니다.
극단적이지만 일반적인 예로

@example
> Z <- array(0, c(3,4,2))
@end example

@noindent
는 @code{Z}를 모두 0인 배열로 만듭니다.

이 시점에서 @code{dim(Z)}는 차원 벡터 @code{c(3,4,2)}를 나타내고, @code{Z[1:24]}는 @code{h}에서의 데이터 벡터를 나타내며, 빈 첨자가 있는 @code{Z[]} 또는 첨자가 없는 @code{Z}는 배열 전체를 배열로 나타냅니다.

배열은 산술 표현식에서 사용될 수 있으며 결과는 데이터 벡터에 대한 요소별 연산에 의해 형성된 배열입니다. 피연산자의 @code{dim} 속성은 일반적으로 동일해야 하며 결과의 차원 벡터가 됩니다. 따라서 @code{A}, @code{B}, @code{C}가 모두 유사한 배열이라면

@example
> D <- 2*A*B + C + 1
@end example

@noindent
는 주어진 요소별 연산의 결과인 데이터 벡터를 가진 유사한 배열인 @code{D}를 만듭니다. 그러나 배열과 벡터 계산을 섞은 경우의 정확한 규칙은 좀 더 주의 깊게 고려해야 합니다.

@menu
* 재활용 규칙::          
@end menu

@node 재활용 규칙,  , array() 함수, array() 함수
@subsection 벡터와 배열 혼합 산술. 재활용 규칙
@cindex 재활용 규칙

벡터와 배열을 혼합하여 요소별 계산을 수행하는 정확한 규칙은 다소 기묘하며 참고 자료에서 찾기 어렵습니다. 경험적으로 다음이 신뢰할 수 있는 지침이라고 생각합니다.

@itemize @bullet
@item
표현식은 왼쪽에서 오른쪽으로 검사됩니다.
@item
짧은 벡터 피연산자는 다른 피연산자와 크기가 일치할 때까지 값을 재활용하여 확장됩니다.
@item
짧은 벡터와 배열 @emph{만} 만날 경우, 배열은 모두 동일한 @code{dim} 속성을 가져야 하며 그렇지 않으면 오류가 발생합니다.
@item
행렬이나 배열 피연산자보다 긴 벡터 피연산자는 오류를 발생시킵니다.
@item
배열 구조가 존재하고 오류가 발생하지 않거나 벡터로의 강제 변환이 발생하지 않은 경우, 결과는 배열 피연산자의 공통 @code{dim} 속성을 가진 배열 구조입니다.
@end itemize

@node 두 배열의 외적, 배열의 일반화된 전치, array() 함수, 배열과 행렬
@section 두 배열의 외적
@cindex 배열의 외적

배열에서 중요한 연산 중 하나는 @emph{외적}입니다. @code{a}와 @code{b}가 두 개의 숫자 배열이라면, 그들의 외적은 두 차원 벡터를 연결하여 얻은 차원 벡터와, @code{a}의 데이터 벡터와 @code{b}의 데이터 벡터의 요소들의 모든 가능한 곱으로 얻은 데이터 벡터를 가진 배열입니다. 외적은 특수 연산자 @code{%o%}를 사용하여 형성됩니다:
@findex %o%

@example
> ab <- a %o% b
@end example

다른 방법으로는

@example
> ab <- outer(a, b, "*")
@end example
@findex outer

곱셈 함수는 두 변수의 임의의 함수로 대체될 수 있습니다. 예를 들어, 함수
@eqn{f(x; y) = \cos(y)/(1 + x^2), f(x; y) = cos(y)/(1 + x^2)}
를 @R{} 벡터 @code{x}와 @code{y}에 의해 정의된 @math{x}-와 @math{y}-좌표를 가진 정규 그리드 값에 대해 평가하려면 다음과 같이 진행할 수 있습니다:

@example
> f <- function(x, y) cos(y)/(1 + x^2)
> z <- outer(x, y, f)
@end example

특히 두 개의 일반 벡터의 외적은 이중 첨자 배열(즉, 최대 순위 1의 행렬)입니다. 외적 연산자는 물론 비교적입니다. 자체 @R{} 함수를 정의하는 방법은 @ref{직접 함수 작성하기}에서 더 자세히 다룰 것입니다.

@subsubheading 예제: 2x2 단일 자릿수 행렬의 행렬식

인위적이지만 귀여운 예로, 각 항목이 범위 @math{0, 1, @dots{}, 9}인 양의 정수인 @math{2}x@math{2} 행렬 @math{[a, b; c, d]}의 행렬식을 생각해봅시다.

이 문제의 목표는 이런 형태의 모든 가능한 행렬의 행렬식, @math{ad - bc},를 찾고 각 값이 나타나는 빈도를 @emph{고밀도} 그림으로 나타내는 것입니다. 이는 각 자릿수가 독립적으로 균일하게 무작위로 선택되는 경우 행렬식의 확률 분포를 찾는 것과 같습니다.

이 작업을 수행하는 깔끔한 방법은 @code{outer()} 함수를 두 번 사용하는 것입니다:

@example
> d <- outer(0:9, 0:9)
> fr <- table(outer(d, d, "-"))
> plot(fr, xlab="Determinant", ylab="Frequency")
@end example

여기서 @code{plot()}은 @code{fr}이 클래스 @code{"table"}임을 "본다는" 것 때문에 히스토그램과 같은 플롯 방법을 사용합니다.
이 문제를 @code{for} 루프로 처리하는 "명백한" 방법은 @ref{루프와 조건 실행}에서 논의될 예정이지만, 너무 비효율적이라 실제로 사용하기 어렵습니다.

또한 이러한 행렬 중 약 1/20이 단수행렬인 것도 놀랍게도 알 수 있습니다.

@node 배열의 일반화된 전치, 행렬 기능, 두 배열의 외적, 배열과 행렬
@section 배열의 일반화된 전치
@cindex 배열의 일반화된 전치

The function @code{aperm(a, perm)}
@findex aperm
may be used to permute an array, @code{a}.  The argument @code{perm}
must be a permutation of the integers @math{@{1, @dots{}, k@}}, where
@math{k} is the number of subscripts in @code{a}.  The result of the
function is an array of the same size as @code{a} but with old dimension
given by @code{perm[j]} becoming the new @code{j}-th dimension.  The
easiest way to think of this operation is as a generalization of
transposition for matrices.  Indeed if @code{A} is a matrix, (that is, a
doubly subscripted array) then @code{B} given by

@example
> B <- aperm(A, c(2,1))
@end example

@noindent
is just the transpose of @code{A}.  For this special case a simpler
function @code{t()}
@findex t
is available, so we could have used @code{B <- t(A)}.

@node 행렬 기능, 분할 행렬 만들기, 배열의 일반화된 전치, 배열과 행렬
@section 행렬 기능

@iftex
@macro xTx{}
@tex
$@strong{x}^T @strong{x}$%
@end tex
@end macro
@macro xxT{}
@tex
$@strong{x}@strong{x}^T$%
@end tex
@end macro
@end iftex

@ifnottex
@macro xTx{}
x'x
@end macro
@macro xxT{}
x x'
@end macro
@end ifnottex

앞서 언급했듯이, 행렬은 두 개의 첨자가 있는 배열입니다. 그러나 중요한 특별한 경우이기 때문에 별도의 논의가 필요합니다. @R{}에는 행렬에만 사용할 수 있는 많은 연산자와 함수가 포함되어 있습니다. 예를 들어, 앞서 언급했던 것처럼 @code{t(X)}는 행렬 전치 함수입니다. 함수 @code{nrow(A)}와 @code{ncol(A)}는 각각 행렬 @code{A}의 행과 열의 개수를 반환합니다.
@findex nrow
@findex ncol

@menu
* 곱셈::              
* 선형 방정식과 역행렬::  
* 고유값과 고유벡터::  
* 특이값 분해와 행렬식::  
* 최소제곱법과 QR 분해::  
@end menu

@node 곱셈, 선형 방정식과 역행렬, 행렬 기능, 행렬 기능
@subsection 행렬 곱셈

@cindex 행렬 곱셈
행렬 곱셈에는 연산자 @code{%%}가 사용됩니다.
@findex %%
@math{n} x @math{1} 또는 @math{1} x @math{n} 행렬은 해당 컨텍스트에서 적절한 경우 @math{n}-벡터로 사용할 수 있습니다. 반대로, 행렬 곱셈 표현식에서 나타나는 벡터들은 곱셈이 일관되게 가능한 경우 행 벡터 또는 열 벡터로 자동으로 승격됩니다(비록 이것이 항상 명확하게 가능한 것은 아닙니다, 나중에 보게 됩니다).

예를 들어, @code{A}와 @code{B}가 동일한 크기의 정사각 행렬이라면,

@example

A * B
@end example

@noindent
는 요소별 곱셈의 행렬이고

@example

A %*% B
@end example

@noindent
는 행렬 곱셈입니다. @code{x}가 벡터라면,

@example

x %% A %% x
@end example

@noindent
는 이차 형태입니다.@footnote{주목할 점은 @code{x %% x}가 모호하다는 것입니다.
이것은 @xTx{} 또는 @xxT{} 둘 중 하나를 의미할 수 있습니다. 이러한 경우 작은 행렬이 묵시적으로 채택되는 해석이므로, 이 경우 결과는 스칼라 @xTx{}입니다. 행렬 @xxT{}는 @code{cbind(x) %% x} 또는 @code{x %*% rbind(x)}로 계산할 수 있습니다. 왜냐하면 @code{rbind()} 또는 @code{cbind()}의 결과는 항상 행렬이기 때문입니다.  그러나 @xTx{} 또는 @xxT{}를 계산하는 가장 좋은 방법은 각각 @code{crossprod(x)} 또는 @code{x %o% x}입니다.}

@findex crossprod
함수 @code{crossprod()}는 "크로스 프로덕트"를 형성하며, @code{crossprod(X, y)}는 @code{t(X) %*% y}와 동일하지만 연산이 더 효율적입니다. @code{crossprod()}의 두 번째 인수가 생략되면 첫 번째 인수와 동일하게 간주됩니다.

@findex diag
@code{diag()}의 의미는 인수에 따라 다릅니다. @code{v}가 벡터인 경우, @code{diag(v)}는 벡터의 요소를 대각선 항목으로 하는 대각 행렬을 생성합니다. 반면에 @code{M}이 행렬인 경우, @code{diag(M)}는 @code{M}의 주 대각선 항목 벡터를 반환합니다. 이 규칙은 @sc{Matlab}의 @code{diag()}에서 사용되는 것과 동일합니다. 또한 약간 혼란스럽게도, @code{k}가 단일 숫자 값인 경우 @code{diag(k)}는 @code{k} x @code{k} 항등 행렬입니다!

@node 선형 방정식과 역행렬, 고유값과 고유벡터, 곱셈, 행렬 기능
@subsection 선형 방정식과 역행렬

@cindex 선형 방정식
@findex solve
선형 방정식 풀기는 행렬 곱셈의 역입니다.
다음에

@example

b <- A %*% x
@end example

@noindent
에서 @code{A}와 @code{b}만 주어진 경우, 벡터 @code{x}는 해당 선형 방정식 시스템의 해입니다. @R{}에서,

@example

solve(A,b)
@end example

@noindent
는 시스템을 풀어서 @code{x}를 반환합니다(일부 정확도 손실에 따라).
선형 대수에서 공식적으로
@eqn{@strong{x} = @strong{A}^{-1} @strong{b}, @code{x = A^@{-1@} %*% b}}
여기서
@eqn{@strong{A}^{-1}, @code{A^@{-1@}}}는
@eqn{@strong{A},@code{A}}의 @emph{역행렬}을 나타내며, 이는 다음과 같이 계산할 수 있습니다.

@example
solve(A)
@end example

@noindent
하지만 이것은 거의 필요하지 않습니다. 수치적으로, @code{x <- solve(A) %*% b} 대신 @code{solve(A,b)}를 계산하는 것은 비효율적이고 잠재적으로 불안정합니다.

다변량 계산에 사용되는 이차 형식 @eqn{@strong{x^T A^{-1} x},@ @code{x %*% A^@{-1@} %*%
x} @ }는 @code{A}의 역행렬을 계산하는 것이 아니라 @code{x %*% solve(A,x)}와 같은 것으로 계산되어야 합니다.@footnote{더 나은 방법은 행렬 제곱근 @eqn{B, B}를 형성하여 @eqn{A = BB^T, A = BB'}를 만들고 @eqn{By = x, By = x}의 해의 제곱 길이를 찾는 것입니다. 아마도 @eqn{A, A}의 Cholesky 또는 고유 분해를 사용합니다. }

@node 고유값과 고유벡터, 특이값 분해와 행렬식, 선형 방정식과 역행렬, 행렬 기능
@subsection 고유값과 고유벡터
@cindex 고유값과 고유벡터

@findex eigen
함수 @code{eigen(Sm)}는 대칭 행렬 @code{Sm}의 고유값과 고유벡터를 계산합니다. 이 함수의 결과는 @code{values}와 @code{vectors}라는 두 개의 구성 요소가 있는 목록입니다. 할당

@example
> ev <- eigen(Sm)
@end example

@noindent
는 이 목록을 @code{ev}에 할당합니다. 그런 다음 @code{ev$val}은 @code{Sm}의 고유값 벡터이고 @code{ev$vec}은 해당 고유벡터의 행렬입니다. 고유값만 필요했다면 다음 할당을 사용할 수 있습니다.

@example
> evals <- eigen(Sm)$values
@end example

@noindent
@code{evals}에는 고유값 벡터가 저장되고 두 번째 구성 요소는 버려집니다. 표현식

@example
> eigen(Sm)
@end example

@noindent
자체가 명령어로 사용되면 두 구성 요소가 이름과 함께 인쇄됩니다. 큰 행렬의 경우 필요하지 않은 경우 고유벡터를 계산하지 않는 것이 좋습니다.

@example
> evals <- eigen(Sm, only.values = TRUE)$values
@end example


@node 특이값 분해와 행렬식, 최소제곱법과 QR 분해, 고유값과 고유벡터, 행렬 기능
@subsection 특이값 분해와 행렬식
@cindex 특이값 분해

@findex svd
함수 @code{svd(M)}는 임의의 행렬 인수인 @code{M}을 받아들이고, @code{M}의 특이값 분해를 계산합니다. 이는 @code{M}과 동일한 열 공간을 가진 직교 정규화된 열의 행렬인 @code{U}, @code{M}의 행 공간이 열 공간인 두 번째 직교 정규화된 열의 행렬인 @code{V} 및 양의 항목을 가진 대각 행렬인 @code{D}로 구성되어 있으며, @code{M = U %*% D %*% t(V)}를 만족합니다. @code{D}는 사실상 대각 요소의 벡터로 반환됩니다. @code{svd(M)}의 결과는 실제로 @code{d}, @code{u} 및 @code{v}라는 세 가지 구성 요소로 된 목록입니다.

@code{M}이 실제로 정사각형인 경우 다음과 같이 절대값 행렬식을 계산할 수 있습니다.

@example
> absdetM <- prod(svd(M)$d)
@end example

@noindent
다양한 행렬로 이 계산이 자주 필요한 경우, @R{} 함수로 정의할 수 있습니다.

@example
> absdet <- function(M) prod(svd(M)$d)
@end example

@cindex 행렬식
@noindent
이렇게 하면 @code{absdet()}를 다른 @R{} 함수처럼 사용할 수 있습니다.
더 간단하지만 유용한 예로, 정사각 행렬의 대각합(trace)을 계산하는 함수인 @code{tr()}을 작성하는 것을 고려해 볼 수 있습니다. [힌트: 명시적인 루프를 사용할 필요가 없습니다. 다시 @code{diag()} 함수를 살펴보세요.]

@findex det
@findex determinant
@R{}에는 부호를 포함하여 행렬식을 계산하는 내장 함수인 @code{det}와, 부호와 크기(선택적으로 로그 스케일)를 제공하는 @code{determinant} 함수가 있습니다.

@c 함수는 이 노트에서 나중에 공식적으로 다룰 예정입니다.

@node 최소제곱법과 QR 분해,  ,특이값 분해와 행렬식, 행렬 기능
@subsection 최소제곱법과 QR 분해
@cindex 최소 제곱 적합화
@cindex QR 분해

함수 @code{lsfit()}은 최소 제곱 적합 절차의 결과를 제공하는 목록을 반환합니다. 다음과 같은 할당이 있습니다.

@example
> ans <- lsfit(X, y)
@end example
@findex lsfit

@noindent
@code{y}는 관측치 벡터이고 @code{X}는 설계 행렬인 최소 제곱 적합의 결과를 제공합니다. 자세한 내용은 도움말 시설을 참조하고, 또한 회귀 진단을 위한 후속 함수인 @code{ls.diag()}도 확인하십시오. 대표 평균 항이 자동으로 포함되므로 @code{X}의 열로 명시적으로 포함할 필요가 없습니다. 게다가 회귀 모델링을 위해 거의 항상 @code{lm(.)} (@pxref{선형 모델})을 @code{lsfit()}보다 선호할 것입니다.

@findex qr
다른 관련된 함수는 @code{qr()} 및 그와 연관된 함수들입니다.
다음 할당을 고려해 보세요.

@example
> Xplus <- qr(X)
> b <- qr.coef(Xplus, y)
> fit <- qr.fitted(Xplus, y)
> res <- qr.resid(Xplus, y)
@end example

@noindent
이것들은 @code{y}의 직교 투영을 @code{fit}의 @code{X} 범위에, 직교 보완재에 대한 투영을 @code{res}에, 투영에 대한 계수 벡터를 @code{b}에 계산합니다. 즉, @code{b}는 기본적으로 @sc{Matlab}의 '백 슬래시' 연산자의 결과입니다.

@code{X}가 전체 열 순위를 가지고 있다고 가정하지 않습니다. 중복성이 발견되면 발견될 때마다 제거됩니다.

이 대안은 최소 제곱 계산을 수행하는 더 오래된 저수준 방법입니다. 일부 맥락에서는 여전히 유용하지만, 일반적으로 이제 @ref{R에서의 통계 모델}에서 논의될 통계 모델 기능으로 대체됩니다.


@node 분할 행렬 만들기, 배열과 함께 사용하는 연결 함수 c(), 행렬 기능, 배열과 행렬
@section 분할 행렬 만들기, @code{cbind()}와 @code{rbind()}
@findex cbind
@findex rbind

앞서 비공식적으로 살펴본 것처럼, 행렬은 @code{cbind()}와 @code{rbind()} 함수를 사용하여 다른 벡터와 행렬로부터 구성할 수 있습니다. 대략적으로 @code{cbind()}는 수평적으로, 또는 열별로 행렬을 결합하여 행렬을 형성하고, @code{rbind()}는 수직적으로 또는 행별로 결합합니다.

할당에서

@example
> X <- cbind(@var{arg_1}, @var{arg_2}, @var{arg_3}, @dots{})
@end example

@noindent
@code{cbind()}의 인수는 임의의 길이의 벡터 또는 같은 열 크기(즉 같은 행 수)의 행렬이어야 합니다. 결과는 @var{arg_1}, @var{arg_2}, @dots{}를 열로 형성한 이어 붙인 인수가 있는 행렬입니다.

@code{cbind()}에 대한 인수 중 일부가 벡터인 경우, 현재 있는 행렬의 열 크기보다 작을 수 있으며, 이 경우 행렬 열 크기(또는 행렬이 주어지지 않은 경우 가장 긴 벡터의 길이)와 일치하도록 순환적으로 확장됩니다.

함수 @code{rbind()}는 행에 대한 해당 작업을 수행합니다. 이 경우 벡터 인수는 가능한 순환적으로 확장되며, 당연히 행 벡터로 간주됩니다.

@code{X1}과 @code{X2}가 동일한 행 수를 가지고 있다고 가정해 보겠습니다. 이들을 @code{1}의 초기 열과 함께 열별로 행렬 @code{X}에 결합하려면 다음을 사용할 수 있습니다.

@example
> X <- cbind(1, X1, X2)
@end example

@code{rbind()} 또는 @code{cbind()}의 결과는 항상 행렬 상태를 가집니다. 따라서 @code{cbind(x)} 및 @code{rbind(x)}는 벡터 @code{x}를 각각 열 또는 행 행렬로 처리할 수 있는 가장 간단한 방법일 수 있습니다.

@node 배열과 함께 사용하는 연결 함수 c(), 요인으로부터의 빈도표, 분할 행렬 만들기, 배열과 행렬
@section 배열과 함께 사용되는 연결 함수, @code{c()}

다음과 같이 언급되어야 합니다. @code{cbind()}와 @code{rbind()}는
@code{dim} 속성을 고려하는 연결 함수이지만, 기본적인
@code{c()} 함수는 그렇지 않으며, 오히려 모든 숫자 객체의
@code{dim} 및 @code{dimnames} 속성을 제거합니다. 이것은 때때로 유용하게 사용됩니다.

배열을 간단한 벡터 객체로 다시 변환하는 공식적인 방법은
@code{as.vector()}를 사용하는 것입니다.

@example
> vec <- as.vector(X)
@end example
@findex as.vector

그러나 한 가지 인수를 사용하는 @code{c()}로 비슷한 결과를 얻을 수 있습니다.
이 부수효과를 위해서만 사용합니다.

@example
> vec <- c(X)
@end example
@findex c

두 가지 사이에는 약간의 차이가 있지만, 결국 둘 중 어느 것을 선택할 것인지는 대부분 스타일의 문제입니다 (전자가 선호됩니다).

@node 요인으로부터의 빈도표,  , 배열과 함께 사용하는 연결 함수 c(), 배열과 행렬
@section 요인으로부터의 빈도표
@cindex 표

요인은 그룹으로의 분할을 정의합니다. 마찬가지로 두 개의 요인은 양방향 교차 분류를 정의하고, 그리고 이어집니다.
@findex table
함수 @code{table()}은 동일한 길이의 요인들로부터 빈도 표를 계산할 수 있게 합니다. @math{k}개의 요인 인수가 있으면,
결과는 @math{k}-way 배열의 빈도입니다.

예를 들어, @code{statef}가 데이터 벡터의 각 항목에 대한 상태 코드를 제공하는 요인이라고 가정합니다. 할당

@example
> statefr <- table(statef)
@end example

@noindent
은 샘플에서 각 상태의 빈도를 @code{statefr}에 나타내는 테이블로 나타납니다. 빈도는 요인의 @code{levels} 속성에 의해 정렬되고 레이블이 지정됩니다. 이 간단한 경우는 다음과 동일하지만 더 편리합니다.

@example
> statefr <- tapply(statef, statef, length)
@end example

더 나아가, @code{incomef}는 데이터 벡터의 각 항목에 대해 적절하게 정의된 "소득 계층"을 제공하는 요인이라고 가정해봅시다. 예를 들어 @code{cut()} 함수를 사용하여:

@example
> factor(cut(incomes, breaks = 35+10*(0:7))) -> incomef
@end example
@findex cut

그런 다음 빈도의 이원 테이블을 계산하려면:

@example
> table(incomef,statef)
         statef
incomef   act nsw nt qld sa tas vic wa
  (35,45]   1   1  0   1  0   0   1  0
  (45,55]   1   1  1   1  2   0   1  3
  (55,65]   0   3  1   3  2   2   2  1
  (65,75]   0   1  0   0  0   0   1  0
@end example

더 높은 차원의 빈도 테이블로의 확장은 즉각적입니다.

@node 리스트와 데이터 프레임, 파일에서 데이터 읽기, 배열과 행렬, 상위
@chapter 리스트와 데이터 프레임

@menu
* 리스트::                       
* 리스트 생성과 수정::  
* 데이터 프레임::                 
@end menu

@node 리스트, 리스트 생성과 수정, 리스트와 데이터 프레임, 리스트와 데이터 프레임
@section 리스트
@cindex 리스트

@R{}의 @emph{리스트}는 그것의 @emph{구성 요소}로 알려진 객체의 순서가 지정된 컬렉션으로 구성된 객체입니다.

구성 요소가 동일한 모드 또는 유형일 필요는 없으며, 예를 들어, 리스트는 숫자 벡터, 논리 값, 행렬, 복소수 벡터, 문자 배열, 함수 등으로 구성될 수 있습니다. 다음은 리스트를 만드는 방법에 대한 간단한 예입니다:

@example
> Lst <- list(name="Fred", wife="Mary", no.children=3,
              child.ages=c(4,7,9))
@end example
@findex list

구성 요소는 항상 @emph{번호가 지정되어} 있으며, 이를 통해 참조할 수 있습니다. 따라서 @code{Lst}가 네 개의 구성 요소를 가진 리스트의 이름이면, 이들은 각각 @code{Lst[[1]]}, @code{Lst[[2]]}, @code{Lst[[3]]} 및 @code{Lst[[4]]}로 개별적으로 참조할 수 있습니다. 더 나아가, @code{Lst[[4]]}가 첨자가 지정된 배열이면, @code{Lst[[4]][1]}은 그 첫 번째 항목입니다.

@code{Lst}가 리스트인 경우, 함수 @code{length(Lst)}는 (상위 수준의) 구성 요소의 수를 제공합니다.

리스트의 구성 요소는 또한 @emph{이름이 지정될} 수 있으며, 이 경우 구성 요소는 이름이 지정된 경우 더블 대괄호 안의 숫자 대신 문자열로 구성 요소 이름을 제공하거나, 더 편리하게는 다음 형식의 표현식을 제공하여 참조할 수 있습니다.

@example
> @var{name}$@var{component_name}
@end example

@noindent
같은 것을 위한 것입니다.

이것은 매우 유용한 관례입니다. 왜냐하면 번호를 잊어버렸을 때 올바른 구성 요소를 얻기가 더 쉬워지기 때문입니다.

따라서 위에서 제공한 간단한 예에서:

@code{Lst$name}은 @code{Lst[[1]]}과 동일하며 문자열 @code{"Fred"}입니다.

@code{Lst$wife}은 @code{Lst[[2]]}와 동일하며 문자열 @code{"Mary"}입니다.

@code{Lst$child.ages[1]}은 @code{Lst[[4]][1]}과 동일하며 숫자 @code{4}입니다.

게다가, 리스트 구성 요소의 이름을 이중 대괄호 안에서도 사용할 수 있습니다. 즉, @code{Lst[["name"]]}은 @code{Lst$name}와 동일합니다. 이는 구성 요소의 이름이 다른 변수에 저장되어 추출되어야 할 경우에 특히 유용합니다.

@example
> x <- "name"; Lst[[x]]
@end example

@code{Lst[[1]]}과 @code{Lst[1]}을 구분하는 것이 매우 중요합니다. @samp{@code{[[@var{@dots{}}]]}}는 단일 요소를 선택하는 데 사용되는 연산자이며, @samp{@code{[@var{@dots{}}]}}는 일반적인 첨자 연산자입니다. 따라서 전자는 리스트 @code{Lst}의 @emph{첫 번째 객체}이며, 명명된 리스트인 경우 이름은 포함되지 @emph{않습니다}. 후자는 첫 번째 항목만 포함하는 리스트 @code{Lst}의 @emph{하위 리스트}입니다. 명명된 리스트인 경우, 이름이 하위 리스트로 전송됩니다.

구성 요소의 이름은 고유하게 식별할 수 있는 최소한의 문자 수로 축약될 수 있습니다. 따라서 @code{Lst$coefficients}는 최소한으로 @code{Lst$coe}로 지정될 수 있고 @code{Lst$covariance}는 @code{Lst$cov}로 지정됩니다.

이름 벡터는 실제로 다른 속성과 마찬가지로 리스트의 속성일 뿐이며, 그대로 처리될 수 있습니다. 물론 리스트 이외의 다른 구조에도 마찬가지로 @emph{names} 속성을 부여할 수 있습니다.

@node 리스트 생성과 수정, 데이터 프레임, 리스트, 리스트와 데이터 프레임
@section 리스트 생성과 수정

기존 객체에서 새 리스트를 만들려면 @code{list()} 함수를 사용합니다. 다음과 같은 할당을 사용합니다.

@example
> Lst <- list(@var{name_1}=@var{object_1}, @var{@dots{}}, @var{name_m}=@var{object_m})
@end example

@noindent
여기서는 @var{object_1}, @dots{}, @var{object_m}를 구성 요소로 사용하여 @math{m}개의 구성 요소가 있는 리스트 @code{Lst}를 설정하고 인수 이름에 지정된 이름을 부여합니다(이름은 자유롭게 선택할 수 있음). 이러한 이름이 생략되면 구성 요소는 번호로만 지정됩니다. 리스트를 형성하는 데 사용된 구성 요소는 새 리스트를 형성할 때 @emph{복사}되며 원본에는 영향을 주지 않습니다.

첨자가 지정된 객체와 마찬가지로, 리스트도 추가 구성 요소를 지정하여 확장할 수 있습니다. 예를 들면,

@example
> Lst[5] <- list(matrix=Mat)
@end example

@menu
* 리스트 결합하기::         
@end menu

@node 리스트 결합하기,  , 리스트 생성과 수정, 리스트 생성과 수정
@subsection 리스트 결합하기
@cindex 리스트 결합하기

@findex c
연결 함수 @code{c()}에 리스트 인수가 주어지면 결과는 구성 요소가 인수 리스트가 순차적으로 결합된 모드 리스트인 객체입니다.

@example
> list.ABC <- c(list.A, list.B, list.C)
@end example

벡터 객체가 인수로 주어진 경우, 연결 함수는 마찬가지로 모든 인수를 하나의 벡터 구조로 결합했습니다. 이 경우, @code{dim} 속성과 같은 모든 기타 속성이 삭제됩니다.

@node 데이터 프레임,  , 리스트 생성과 수정, 리스트와 데이터 프레임
@section 데이터 프레임
@cindex 데이터 프레임

@emph{데이터 프레임}은 클래스가 @code{"data.frame"}인 리스트입니다. 데이터 프레임으로 만들 수 있는 리스트에는 제한이 있으며, 다음과 같습니다.

@itemize @bullet
@item
구성 요소는 벡터(숫자, 문자 또는 논리), 요인, 숫자 행렬, 리스트 또는 다른 데이터 프레임이어야 합니다.
@item
행렬, 리스트, 데이터 프레임은 새로운 데이터 프레임에 각각 열, 요소 또는 변수만큼의 변수를 제공합니다.
@item
데이터 프레임의 변수로 나타나는 벡터 구조는 모두 @emph{동일한 길이}를 가져야 하며, 행렬 구조는 모두 @emph{동일한 행의 수}를 가져야 합니다.
@end itemize

데이터 프레임은 많은 목적으로 열이 다른 모드와 속성을 가진 행렬로 간주할 수 있습니다. 행렬 형태로 표시할 수 있으며 행렬 색인 규칙을 사용하여 행과 열을 추출할 수 있습니다.

@menu
* 데이터 프레임 만들기::          
* attach() 함수와 detach() 함수::       
* 데이터 프레임과 작업하기::    
* 임의의 목록 첨부하기::   
* 검색 경로 관리하기::    
@end menu

@node 데이터 프레임 만들기, attach() 함수와 detach() 함수, 데이터 프레임, 데이터 프레임
@subsection 데이터 프레임 만들기

데이터 프레임의 열(구성 요소)에 대해 제한을 만족하는 객체는 @code{data.frame} 함수를 사용하여 하나를 형성하는 데 사용할 수 있습니다.
@findex data.frame

@example
> accountants <- data.frame(home=statef, loot=incomes, shot=incomef)
@end example

데이터 프레임의 제한을 준수하는 구성 요소가 있는 리스트는 함수 @code{as.data.frame()}을 사용하여 데이터 프레임으로 @emph{강제} 변환할 수 있습니다.
@findex as.data.frame

데이터 프레임을 처음부터 만드는 가장 간단한 방법은 @code{read.table()} 함수를 사용하여 외부 파일에서 전체 데이터 프레임을 읽는 것입니다. 이에 대해서는 @ref{파일에서 데이터 읽기}에서 더 자세히 설명하겠습니다.

@node attach() 함수와 detach() 함수, 데이터 프레임과 작업하기, 데이터 프레임 만들기, 데이터 프레임
@subsection @code{attach()} 함수와 @code{detach() 함수}
@findex attach
@findex detach

@code{$} 표기법, 예를 들어 @code{accountants$home}과 같은 리스트 구성 요소는 항상 편리하지는 않습니다. 리스트나 데이터 프레임의 구성 요소를 구성 요소 이름에 따라 변수로서 임시로 표시할 수 있는 유용한 기능이 있으면 좋겠습니다.

@code{attach()} 함수는 리스트 또는 데이터 프레임과 같은 '데이터베이스'를 인수로 취합니다. 따라서 @code{lentils}이 변수 @code{lentils$u}, @code{lentils$v}, @code{lentils$w}가 있는 데이터 프레임이라고 가정하면, 첨부

@example

attach(lentils)
@end example

@noindent
검색 경로에서 @w{위치 2}에 데이터 프레임을 배치하고, @w{위치 1}에 변수 @code{u}, @code{v}, @code{w}가 없는 경우 데이터 프레임에서 변수로 사용할 수 있습니다. 이 시점에서 다음과 같은 할당이 있으면

@example

u <- v+w
@end example

@noindent
데이터 프레임의 구성 요소 @code{u}를 대체하지 않고, 검색 경로의 @w{위치 1}에 있는 작업 디렉토리에서 다른 변수 @code{u}로 마스킹합니다. 데이터 프레임 자체에 영구적인 변경을 만들려면, 다시 한번 @code{$} 표기법을 사용하는 것이 가장 간단한 방법입니다.

@example

lentils$u <- v+w
@end example

그러나 구성 요소 @code{u}의 새로운 값은 데이터 프레임이 분리되어 다시 연결될 때까지 표시되지 않습니다.

데이터 프레임을 분리하려면 다음 함수를 사용하십시오.

@example

detach()
@end example

보다 정확하게는, 이 문장은 검색 경로의 @w{위치 2}에 있는 개체를 분리합니다. 따라서 현재 상황에서 변수 @code{u}, @code{v}, @code{w}는 @code{lentils$u} 등의 목록 표기법으로만 표시되지 않습니다. 검색 경로의 위치 2보다 큰 위치에 있는 개체는 @code{detach}에 번호를 주어 분리할 수 있지만, @code{detach(lentils)} 또는 @code{detach("lentils")}와 같이 항상 이름을 사용하는 것이 훨씬 안전합니다.

@quotation 참고
@R{}에서 리스트와 데이터 프레임은 위치 2 이상에서만 첨부할 수 있으며, 첨부되는 것은 원래 객체의 @emph{복사본}입니다. 첨부된 값을 @code{assign}을 통해 변경할 수 있지만, 원래의 리스트 또는 데이터 프레임은 변경되지 않습니다.
@end quotation

@node 데이터 프레임과 작업하기, 임의의 목록 첨부하기, attach() 함수와 detach() 함수, 데이터 프레임
@subsection 데이터 프레임과 작업하기

같은 작업 디렉토리에서 여러 다른 문제를 편안하게 함께 작업할 수 있는 유용한 관례는 다음과 같습니다.

@itemize @bullet
@item
적절한 정보를 가진 이름으로 정의된 별도의 문제에 대한 모든 변수를 데이터 프레임에 모읍니다.
@item
문제를 처리할 때 적절한 데이터 프레임을 @w{위치 2}에 첨부하고, 작업 디렉토리의 @w{레벨 1}에서 운영량과 임시 변수를 사용합니다.
@item
문제를 떠나기 전에, 미래 참조를 위해 유지하려는 변수를 @code{$} 형태의 할당을 사용하여 데이터 프레임에 추가한 다음 @code{detach()} 합니다.
@item
마지막으로 작업 디렉토리에서 원치 않는 변수를 모두 제거하고, 남은 임시 변수를 최대한 정리합니다.
@end itemize

이런 방식으로 같은 디렉토리에서 여러 문제를 처리하는 것이 꽤 간단합니다. 예를 들어, 모든 문제에서 변수가 @code{x}, @code{y}, @code{z}로 명명되어 있습니다.

@node 임의의 목록 첨부하기, 검색 경로 관리하기, 데이터 프레임과 작업하기, 데이터 프레임
@subsection 임의의 목록 첨부하기

@code{attach()}는 검색 경로에 디렉토리와 데이터 프레임뿐만 아니라 다른 클래스의 객체도 첨부할 수 있는 일반적인 함수입니다. 특히, 모드가 @code{"list"}인 모든 객체는 동일한 방식으로 첨부할 수 있습니다.

@example
> attach(any.old.list)
@end example

첨부된 모든 것은 위치 번호 또는 선호하는 이름으로 @code{detach}를 사용하여 분리할 수 있습니다.

@node 검색 경로 관리하기,  , 임의의 목록 첨부하기, 데이터 프레임
@subsection 검색 경로 관리하기
@findex search
@cindex 검색 경로

함수 @code{search}는 현재 검색 경로를 보여주므로 첨부 및 분리된 데이터 프레임과 목록(및 패키지)을 추적하는 데 매우 유용합니다. 초기에는 다음과 같습니다.

@example
> search()
[1] ".GlobalEnv"   "Autoloads"    "package:base"
@end example
@noindent
여기서 @code{.GlobalEnv}는 작업 공간입니다.@footnote{@code{autoload}의 두 번째 용어의 의미에 대해서는 온라인 도움말을 참조하십시오.}

@code{lentils}이 첨부된 후에는 다음과 같습니다.

@example
> search()
[1] ".GlobalEnv"   "lentils"      "Autoloads"    "package:base"
> ls(2)
[1] "u" "v" "w"
@end example

@noindent
그리고 보이는대로 @code{ls}(또는 @code{objects})를 사용하여 검색 경로의 위치를 검사할 수 있습니다.

마지막으로 데이터 프레임을 분리하고 검색 경로에서 제거되었음을 확인합니다.

@example
> detach("lentils")
> search()
[1] ".GlobalEnv"   "Autoloads"    "package:base"
@end example

@node 파일에서 데이터 읽기, 확률 분포, 리스트와 데이터 프레임, 상위
@chapter 파일에서 데이터 읽기
@cindex 파일에서 데이터 읽기

대규모 데이터 객체는 일반적으로 외부 파일에서 값을 읽어올 것이며, 키보드에서 @R{} 세션 중에 입력되지 않을 것입니다. @R{} 입력 기능은 간단하며 요구 사항이 상당히 엄격하고 심지어 유연하지 않습니다. @R{}의 설계자들은 파일 편집기나 Perl@footnote{UNIX에서는 @command{sed} 또는 @command{awk} 유틸리티를 사용할 수 있습니다.}과 같은 다른 도구를 사용하여 입력 파일을 수정하여 @R{}의 요구 사항에 맞추어 질 수 있다는 명백한 가정이 있습니다. 일반적으로 이 작업은 매우 간단합니다.

변수가 주로 데이터 프레임에 저장될 것이라면, 우리가 강력하게 제안하는 것처럼, 전체 데이터 프레임은 @code{read.table()} 함수를 사용하여 직접 읽을 수 있습니다. 또한 더 원시적인 입력 함수인 @code{scan()}을 직접 호출할 수도 있습니다.

@R{}에서 데이터를 가져오는 방법과 데이터를 내보내는 방법에 대한 자세한 내용은 @emph{R Data Import/Export} 설명서를 참조하십시오.

@menu
* read.table() 함수::   
* scan() 함수::         
* 내장 데이터셋에 접근하기::  
* 데이터 편집하기::                
@end menu

@node read.table() 함수, scan() 함수, 파일에서 데이터 읽기, 파일에서 데이터 읽기
@section @code{read.table()} 함수
@findex read.table

전체 데이터 프레임을 직접 읽으려면 외부 파일은 일반적으로 특수한 형태를 가지고 있어야 합니다.

@itemize @bullet
@item
파일의 첫 번째 줄에는 데이터 프레임의 각 변수에 대한 @emph{이름}이 있어야 합니다.

@item
파일의 추가 줄은 @emph{행 레이블}과 각 변수의 값을 첫 번째 항목으로 가지고 있습니다.
@end itemize

파일의 첫 번째 줄에 두 번째 줄보다 하나 적은 항목이 있는 경우, 이러한 배치가 시행되고 있다고 가정합니다. 따라서 데이터 프레임으로 읽힐 파일의 처음 몇 줄은 다음과 같습니다.

@quotation
@cartouche
@example
@r{이름과 행 레이블이 있는 입력 파일 형식:}

     Price    Floor     Area   Rooms     Age  Cent.heat
01   52.00    111.0      830     5       6.2      no
02   54.75    128.0      710     5       7.5      no
03   57.50    101.0     1000     5       4.2      no
04   57.50    131.0      690     6       8.8      no
05   59.75     93.0      900     5       1.9     yes
...
@end example
@end cartouche
@end quotation

기본적으로 숫자 항목(행 레이블 제외)은 숫자 변수로 읽히고, 예제의 @code{Cent.heat}와 같은 비숫자 변수는 문자 변수로 읽힙니다. 필요한 경우 이를 변경할 수 있습니다.

함수 @code{read.table()}을 사용하여 데이터 프레임을 직접 읽을 수 있습니다.

@example

HousePrice <- read.table("houses.data")
@end example

종종 행 레이블을 직접 포함하지 않고 기본 레이블을 사용하려고 할 것입니다. 이 경우 파일에서 행 레이블 열을 생략할 수 있습니다.

@quotation
@cartouche
@example
@r{행 레이블 없는 입력 파일 형식:}

Price Floor Area Rooms Age Cent.heat
52.00 111.0 830 5 6.2 no
54.75 128.0 710 5 7.5 no
57.50 101.0 1000 5 4.2 no
57.50 131.0 690 6 8.8 no
59.75 93.0 900 5 1.9 yes
...
@end example
@end cartouche
@end quotation

그런 다음 데이터 프레임은 다음과 같이 읽을 수 있습니다.

@example

HousePrice <- read.table("houses.data", header=TRUE)
@end example

@noindent
여기서 @code{header=TRUE} 옵션은 첫 번째 줄이 제목 행임을 지정하고, 따라서 파일 형식에서 암시하는 것처럼 명시적인 행 레이블이 주어지지 않습니다.


@menu
* scan() 함수::
@end menu

@node scan() 함수, 내장 데이터셋에 접근하기, read.table() 함수, 파일에서 데이터 읽기
@section @code{scan()} 함수
@findex scan

데이터 벡터가 길이가 같고 병렬로 읽혀야 한다고 가정해 보겠습니다. 또한 첫 번째 벡터는 문자 모드이고 나머지 두 개의 벡터는 숫자 모드이며 파일은 @file{input.dat}입니다. 첫 번째 단계는 @code{scan()}을 사용하여 세 개의 벡터를 리스트로 읽어 들이는 것입니다.

@example
> inp <- scan("input.dat", list("",0,0))
@end example

두 번째 인수는 읽을 세 개의 벡터 모드를 결정하는 더미 리스트 구조입니다. 결과는 @code{inp}에 저장되는데, 이는 읽은 세 개의 벡터가 있는 리스트입니다. 데이터 항목을 세 개의 별도의 벡터로 분리하려면 다음과 같은 할당을 사용합니다.

@example
> label <- inp[[1]]; x <- inp[[2]]; y <- inp[[3]]
@end example

더 편리하게는 더미 리스트에 이름이 지정된 구성 요소가 있을 수 있으며, 이 경우 읽어들인 벡터에 접근하는 데 이름을 사용할 수 있습니다. 예를 들면,

@example
> inp <- scan("input.dat", list(id="", x=0, y=0))
@end example

변수를 따로 사용하려면 작업 프레임의 변수에 다시 할당할 수 있습니다.

@example
> label <- inp$id; x <- inp$x; y <- inp$y
@end example

@noindent
또는 검색 경로의 @w{위치 2}에 목록이 첨부될 수 있습니다 (@pxref{임의의 목록 첨부하기}).

두 번째 인수가 단일 값이고 목록이 아닌 경우, 하나의 벡터가 읽히며, 이 벡터의 모든 구성 요소는 더미 값과 동일한 모드여야 합니다.

@example
> X <- matrix(scan("light.dat", 0), ncol=5, byrow=TRUE)
@end example

더 정교한 입력 기능들이 있으며, 이러한 기능들은 메뉴얼에 자세히 설명되어 있습니다.

@node 내장 데이터셋에 접근하기, 데이터 편집하기, scan() 함수, 파일에서 데이터 읽기
@section 내장 데이터셋에 접근하기
@cindex 내장 데이터셋에 접근하기
@findex data

약 100개의 데이터셋이 @R{}(패키지 @pkg{datasets}에 포함)과 함께 제공되며, 다른 패키지(또한 @R{}과 함께 제공되는 권장 패키지 포함)에서도 사용할 수 있습니다. 현재 사용 가능한 데이터셋 목록을 보려면

@example
data()
@end example

@noindent
@R{}에 제공되는 모든 데이터셋은 이름으로 직접 사용할 수 있습니다. 그러나 많은 패키지는 @code{data}를 사용하여 @R{}에 데이터셋을 로드하는 데 사용했던 구식 규칙을 사용합니다. 예를 들면,

@example
data(infert)
@end example

@noindent
이 방식은 표준 패키지(이 예시와 같이)에서 여전히 사용할 수 있습니다. 대부분의 경우, 동일한 이름의 @R{} 객체를 로드합니다. 그러나 일부 경우에는 여러 객체를 로드하므로, 어떤 것을 기대해야 할지 알려면 온라인 도움말에서 해당 객체를 확인하십시오.

@subsection 다른 R 패키지에서 데이터 로드하기

특정 패키지에서 데이터에 접근하려면 @code{package} 인수를 사용하십시오. 예를 들면,

@example
data(package="rpart")
data(Puromycin, package="datasets")
@end example

@code{library}에 의해 패키지가 첨부되면 해당 패키지의 데이터셋이 검색에 자동으로 포함됩니다.

사용자가 제공한 패키지는 데이터셋의 풍부한 출처가 될 수 있습니다.

@node 데이터 편집하기,  , 내장 데이터셋에 접근하기, 파일에서 데이터 읽기
@section 데이터 편집하기

@findex edit
데이터 프레임이나 행렬에서 호출될 때 @code{edit}는 편집을 위한 별도의 스프레드시트와 같은 환경을 제공합니다. 이는 데이터 세트를 읽은 후 작은 변경사항을 적용할 때 유용합니다. 다음 명령어를 사용하면

@example

xnew <- edit(xold)
@end example

@noindent
데이터 세트 @code{xold}를 편집할 수 있으며 완료되면 변경된 객체가 @code{xnew}에 할당됩니다. 원래 데이터셋 @code{xold}를 변경하려면 @code{fix(xold)}를 사용하는 것이 가장 간단한 방법이며, 이는 @code{xold <- edit(xold)}와 동일합니다.

다음을 사용하여

@example

xnew <- edit(data.frame())
@end example

@noindent
스프레드시트 인터페이스를 통해 새 데이터를 입력할 수 있습니다.

@node 확률 분포, 루프와 조건 실행, 파일에서 데이터 읽기, 상위
@chapter 확률 분포
@cindex 확률 분포

@menu
* 통계표 집합으로서의 R::
* 데이터 집합의 분포 검사::
* 일표본 및 이표본 검정::
@end menu
@node 통계표 집합으로서의 R, 데이터 집합의 분포 검사, 확률 분포, 확률 분포
@section 통계표 집합으로서의 R

@R{}의 편리한 용도 중 하나는 통계 표를 포괄적으로 제공하는 것입니다. 누적 분포 함수 @eqn{P(X \le x), P(X <= x)}, 확률 밀도 함수, 및 분위수 함수(주어진 @math{q}에 대해 @eqn{P(X \le x) > q, P(X <= x) > q}를 만족하는 가장 작은 @math{x})를 평가하고 분포에서 시뮬레이션하는 함수가 제공됩니다.

@quotation
@example
@multitable @columnfractions .3 .3 .4
@headitem Distribution @tab @R{} name @tab Additional arguments
@item beta @tab @code{beta} @tab @code{shape1, shape2, ncp}
@item binomial @tab @code{binom} @tab @code{size, prob}
@item Cauchy @tab @code{cauchy} @tab @code{location, scale}
@item chi-squared @tab @code{chisq} @tab @code{df, ncp}
@item exponential @tab @code{exp} @tab @code{rate}
@item F @tab @code{f} @tab @code{df1, df2, ncp}
@item gamma @tab @code{gamma} @tab @code{shape, scale}
@item geometric @tab @code{geom} @tab @code{prob}
@item hypergeometric @tab @code{hyper} @tab @code{m, n, k}
@item lognormal @tab @code{lnorm} @tab @code{meanlog, sdlog}
@item logistic @tab @code{logis} @tab @code{location, scale}
@item negative binomial @tab @code{nbinom} @tab @code{size, prob}
@item normal @tab @code{norm} @tab @code{mean, sd}
@item Poisson @tab @code{pois} @tab @code{lambda}
@item signed rank @tab @code{signrank} @tab @code{n}
@item Student's t @tab @code{t} @tab @code{df, ncp}
@item uniform @tab @code{unif} @tab @code{min, max}
@item Weibull @tab @code{weibull} @tab @code{shape, scale}
@item Wilcoxon @tab @code{wilcox} @tab @code{m, n}
@end multitable
@end example
@end quotation

@noindent
여기에 주어진 이름 앞에 @samp{d}를 붙여 밀도, @samp{p}를 붙여 누적 분포 함수(CDF), @samp{q}를 붙여 분위수 함수, @samp{r}을 붙여 시뮬레이션(@emph{r}andom deviates)을 사용합니다. 첫 번째 인수는 @code{d@var{xxx}}에 대한 @code{x}, @code{p@var{xxx}}에 대한 @code{q}, @code{q@var{xxx}}에 대한 @code{p} 및 @code{r@var{xxx}}에 대한 @code{n}(단, @code{rhyper}, @code{rsignrank} 및 @code{rwilcox}의 경우 @code{nn}임)입니다. 아직 모든 경우에 비중심성 매개변수 @code{ncp}를 사용할 수는 없습니다. 자세한 내용은 온라인 도움말을 참조하십시오.

@code{p@var{xxx}} 및 @code{q@var{xxx}} 함수는 모두 논리 인수 @code{lower.tail}과 @code{log.p}를 가지며, @code{d@var{xxx}} 함수는 @code{log}를 가집니다. 이를 통해 누적(또는 "통합된") @emph{위험} 함수를 @eqn{H(t) = - \log(1 - F(t)), H(t) = - log(1 - F(t))}와 같이 얻을 수 있습니다.

@example
 - p@var{xxx}(t, ..., lower.tail = FALSE, log.p = TRUE)
@end example

@noindent
또는 더 정확한 로그 가능도를 (@code{d@var{xxx}(..., log = TRUE)}를 사용하여) 직접 얻을 수 있습니다.

추가로, 정규 분포에서 추출한 표본의 학생화 범위 분포에 대한 함수 @code{ptukey}와 @code{qtukey} 그리고 다항 분포에 대한 @code{dmultinom} 및 @code{rmultinom} 함수가 있습니다. 더 많은 분포는 기여된 패키지에 있으며, 특히 @CRANpkg{SuppDists}를 참조하십시오.

다음은 몇 가지 예입니다.

@example
> ## @r{t 분포의 2-꼬리 p 값}
> 2*pt(-2.43, df = 13)
> ## @r{F(2, 7) 분포의 상위 1% 지점}
> qf(0.01, 2, 7, lower.tail = FALSE)
@end example

@R{}에서 난수 생성이 어떻게 이루어지는지에 대한 정보는 온라인 도움말의 @code{RNG}를 참조하십시오.

@node 데이터 집합의 분포 검사, 일표본 및 이표본 검정, 통계표 집합으로서의 R, 확률 분포
@section 데이터 집합의 분포 검사

(단변량) 데이터 집합이 주어지면 다양한 방법으로 분포를 살펴볼 수 있습니다. 가장 간단한 방법은 숫자를 검토하는 것입니다. @code{summary}와 @code{fivenum}에 의해 약간 다른 요약이 제공됩니다.
@findex summary
@findex fivenum
그리고 숫자를 표시하는 @code{stem} (``줄기와 잎'' 플롯)이 있습니다.
@findex stem

@example
> attach(faithful)
> summary(eruptions)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  1.600   2.163   4.000   3.488   4.454   5.100
> fivenum(eruptions)
[1] 1.6000 2.1585 4.0000 4.4585 5.1000
> stem(eruptions)

  소수점은 |의 왼쪽에 1 자리 있습니다.

  16 | 070355555588
  18 | 000022233333335577777777888822335777888
  20 | 00002223378800035778
  22 | 0002335578023578
  24 | 00228
  26 | 23
  28 | 080
  30 | 7
  32 | 2337
  34 | 250077
  36 | 0000823577
  38 | 2333335582225577
  40 | 0000003357788888002233555577778
  42 | 03335555778800233333555577778
  44 | 02222335557780000000023333357778888
  46 | 0000233357700000023578
  48 | 00000022335800333
  50 | 0370
@end example

줄기와 잎 플롯은 히스토그램과 비슷하며, @R{}에는 히스토그램을 그리는 함수인 @code{hist}가 있습니다.
@findex hist

@example
> hist(eruptions)
## @r{구간을 작게 만들고 밀도 플롯을 그립니다}
> hist(eruptions, seq(1.6, 5.2, 0.2), prob=TRUE)
> lines(density(eruptions, bw=0.1))
> rug(eruptions) # @r{실제 데이터 포인트를 표시합니다}
@end example

@findex density
@cindex 밀도 추정
보다 세련된 밀도 플롯은 @code{density}를 사용하여 만들 수 있으며, 이 예에서는 @code{density}에 의해 생성된 선을 추가했습니다. 대역폭 @code{bw}는 기본값이 너무 많은 평활화를 제공하기 때문에 시행착오를 통해 선택되었습니다(일반적으로 "흥미로운" 밀도에 대해서는 그렇습니다). (더 나은 자동 대역폭 선택 방법이 사용 가능하며, 이 예에서는 @code{bw = "SJ"}이 좋은 결과를 제공합니다.)

@ifnotinfo
@image{images/hist,9cm}
@end ifnotinfo

우리는 함수 @code{ecdf}를 사용하여 경험적 누적 분포 함수를 그릴 수 있습니다.
@findex ecdf
@cindex 경험적 CDF

@example
> plot(ecdf(eruptions), do.points=FALSE, verticals=TRUE)
@end example

이 분포는 명백하게 표준 분포와 거리가 멉니다.
오른쪽 모드, 즉 3분 이상의 분출에 대해서는 어떨까요?
정규 분포를 적합하고 적합한 CDF를 겹쳐 그립니다.

@example
> long <- eruptions[eruptions > 3]
> plot(ecdf(long), do.points=FALSE, verticals=TRUE)
> x <- seq(3, 5.4, 0.01)
> lines(x, pnorm(x, mean=mean(long), sd=sqrt(var(long))), lty=3)
@end example

@ifnotinfo
@image{images/ecdf,9cm}
@end ifnotinfo

분위수-분위수(Q-Q) 그림은 이를 더 자세히 검토하는 데 도움이 됩니다.
@cindex 분위수-분위수 그림
@findex qqnorm
@findex qqline

@example
par(pty="s") # 정사각형 그림 영역 배열
qqnorm(long); qqline(long)
@end example

@noindent
이는 합리적인 적합도를 보여주지만, 정규 분포에서 기대할 수 있는 것보다 오른쪽 꼬리가 짧습니다. 이를 t 분포에서 시뮬레이션한 데이터와 비교해 봅시다.

@ifnotinfo
@image{images/QQ,7cm}
@end ifnotinfo

@example
x <- rt(250, df = 5)
qqnorm(x); qqline(x)
@end example

@noindent
이는 보통(랜덤 샘플인 경우) 정규분포에서 기대하는 것보다 긴 꼬리를 보여줍니다. 생성 분포에 대한 Q-Q 그림을 그리려면 다음과 같이 합니다.

@example
qqplot(qt(ppoints(250), df = 5), x, xlab = "Q-Q plot for t dsn")
qqline(x)
@end example

마지막으로, 정규성과의 더 정식적인 일치 여부를 검증하려면 다음과 같이 합니다. @R{}는 Shapiro-Wilk 검정을 제공합니다.
@cindex Shapiro-Wilk 검정
@findex shapiro.test

@example
> shapiro.test(long)

         Shapiro-Wilk normality test

data:  long
W = 0.9793, p-value = 0.01052
@end example

@noindent
그리고 Kolmogorov-Smirnov 검정도 제공합니다.
@cindex Kolmogorov-Smirnov 검정
@findex ks.test

@example
> ks.test(long, "pnorm", mean = mean(long), sd = sqrt(var(long)))

         One-sample Kolmogorov-Smirnov test

data:  long
D = 0.0661, p-value = 0.4284
alternative hypothesis: two.sided
@end example

@noindent
(여기서 분포 이론은 유효하지 않습니다. 왜냐하면 동일한 표본에서 정규 분포의 매개 변수를 추정했기 때문입니다.)

@node 일표본 및 이표본 검정, , 데이터 집합의 분포 검사, 확률 분포
@section 일표본 및 이표본 검정
@cindex 일표본 및 이표본 검정

지금까지 하나의 표본을 정규 분포와 비교했습니다. 두 개의 표본의 측면을 비교하는 것이 훨씬 더 일반적인 작업입니다. @R{}에서는 아래에서 사용되는 모든 "고전적인" 검정을 포함하여 일반적으로 로드되는 @pkg{stats} 패키지에 있습니다.

Rice (1995, p.490)에서 빙상의 잠재열(@emph{cal/gm})에 대한 다음 데이터 세트를 고려해 보십시오.

@example
방법 A: 79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97
          80.05 80.03 80.02 80.00 80.02
방법 B: 80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97
@end example

@noindent
상자 그림은 두 표본의 간단한 그래픽 비교를 제공합니다.

@c NOTE scan() from stdin is not parse()able, hence not source()able
@c Hence ./R-intro.R uses c(..)
@example
A <- scan()
79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97
80.05 80.03 80.02 80.00 80.02

B <- scan()
80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97

boxplot(A, B)
@end example
@findex boxplot
@cindex Box plots

@noindent
이것은 첫 번째 그룹이 두 번째 그룹보다 높은 결과를 주는 경향이 있음을 나타냅니다.

@ifnotinfo
@image{images/ice,7cm}
@end ifnotinfo

두 예제의 평균이 동일한지 검정하기 위해, @emph{짝이 맞지 않는} @math{t}-검정을 사용할 수 있습니다.
@cindex Student's @math{t} 검정
@findex t.test

@example
> t.test(A, B)

         Welch Two Sample t-test

data:  A and B
t = 3.2499, df = 12.027, p-value = 0.00694
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 0.01385526 0.07018320
sample estimates:
mean of x mean of y
 80.02077  79.97875
@end example

@noindent
이는 정규성을 가정할 때 유의한 차이를 나타냅니다. 기본적으로 @R{} 함수는 두 표본에서 분산의 동일성을 가정하지 않습니다.
@c (비슷한 @SPLUS{} @code{t.test} 함수와는 대조적으로).
두 표본이 정규 모집단에서 나온 경우, F 검정을 사용하여 분산의 동일성을 검정할 수 있습니다.

@example
> var.test(A, B)

         F test to compare two variances

data:  A and B
F = 0.5837, num df = 12, denom df =  7, p-value = 0.3938
alternative hypothesis: true ratio of variances is not equal to 1
95 percent confidence interval:
 0.1251097 2.1052687
sample estimates:
ratio of variances
         0.5837405
@end example
@findex var.test

@noindent
이 결과는 유의한 차이가 없음을 보여주며, 따라서 분산이 동일하다고 가정하는 고전적인 @math{t}-검정을 사용할 수 있습니다.

@example
> t.test(A, B, var.equal=TRUE)

         Two Sample t-test

data:  A and B
t = 3.4722, df = 19, p-value = 0.002551
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 0.01669058 0.06734788
sample estimates:
mean of x mean of y
 80.02077  79.97875
@end example

이러한 모든 검정은 두 표본의 정규성을 가정합니다. 이표본 Wilcoxon(또는 Mann-Whitney) 검정은 귀무 가설 하에서 공통 연속 분포만을 가정합니다.

@cindex Wilcoxon 검정
@findex wilcox.test
@example
> wilcox.test(A, B)

         Wilcoxon rank sum test with continuity correction

data:  A and B
W = 89, p-value = 0.007497
alternative hypothesis: true location shift is not equal to 0

Warning message:
Cannot compute exact p-value with ties in: wilcox.test(A, B)
@end example

@noindent
주의사항: 각 표본에 여러 개의 동점이 있으며, 이는 이러한 데이터가 이산 분포(반올림으로 인한 가능성이 높음)에서 나온 것을 강력하게 제안합니다.

두 표본을 그래픽으로 비교하는 여러 가지 방법이 있습니다. 우리는 이미 상자 그림 쌍을 보았습니다. 다음과 같은 작업을 수행하면

@example
> plot(ecdf(A), do.points=FALSE, verticals=TRUE, xlim=range(A, B))
> plot(ecdf(B), do.points=FALSE, verticals=TRUE, add=TRUE)
@end example

@noindent
두 경험적 CDF를 보여주며, @code{qqplot}은 두 표본의 Q-Q 플롯을 수행합니다. Kolmogorov-Smirnov 검정은 두 ecdf 사이의 최대 수직 거리를 공통 연속 분포를 가정하여 검정합니다:

@example
> ks.test(A, B)

         Two-sample Kolmogorov-Smirnov test

data:  A and B
D = 0.5962, p-value = 0.05919
alternative hypothesis: two-sided

Warning message:
cannot compute correct p-values with ties in: ks.test(A, B)
@end example

@node 루프와 조건 실행, 직접 함수 작성하기, 확률 분포, 상위
@chapter 그룹핑, 루프 및 조건부 실행
@cindex 루프와 조건 실행

@menu
* 그룹화된 표현::         
* 제어문::          
@end menu

@node 그룹화된 표현, 제어문, 루프와 조건 실행, 루프와 조건 실행
@section 그룹화된 표현
@cindex 그룹화된 표현

@R{}은 결과를 반환하는 함수 또는 식이 유일한 명령 유형인 의미에서 표현 언어입니다. 할당조차도 할당된 값이 결과인 식이며, 어떤 식이든 사용될 수 있는 곳에서 사용할 수 있습니다. 특히 여러 할당이 가능합니다.

명령어는 중괄호, @code{@{@var{expr_1}; @var{@dots{}}; @var{expr_m}@}} 안에 함께 그룹화 될 수 있으며, 이 경우 그룹의 값은 그룹 내에서 평가된 마지막 표현식의 결과입니다. 이러한 그룹도 식이므로 예를 들어 괄호 안에 포함되어 더 큰 식의 일부로 사용될 수 있습니다.

@node 제어문,  , 그룹화된 표현, 루프와 조건 실행
@section 제어문
@cindex 제어문

@menu
* 조건부 실행::       
* 반복적 실행::        
@end menu

@node 조건부 실행, 반복적 실행, 제어문, 제어문
@subsection 조건부 실행: @code{if} 문
@findex if

이 언어는 다음 형식의 조건부 구문을 사용할 수 있습니다.

@example
> if (@var{expr_1}) @var{expr_2} else @var{expr_3}
@end example
@findex if
@findex else

@noindent
여기서 @var{expr_1}은 단일 논리 값으로 평가되어야 하며 전체 식의 결과는 그 다음 명확해집니다.

@findex &&
@findex ||
"단락 평가(short-circuit)" 연산자인 @code{&&}와 @code{||}은 종종 @code{if} 문의 조건 부분에 사용됩니다. @code{&}와 @code{|}는 벡터에 원소별로 적용되는 반면, @code{&&}와 @code{||}는 길이가 1인 벡터에 적용되며 필요한 경우에만 두 번째 인수를 평가합니다.

@findex ifelse
@code{if}/@code{else} 구조의 벡터화된 버전인 @code{ifelse} 함수가 있습니다. 이 함수는 @code{ifelse(condition, a, b)} 형식을 가지며, @code{condition}과 같은 길이의 벡터를 반환합니다. @code{condition[i]}가 참인 경우 요소는 @code{a[i]}이고, 그렇지 않으면 @code{b[i]}입니다(여기서 @code{a}와 @code{b}는 필요에 따라 재사용됩니다).

@node 반복적 실행,  , 조건부 실행, 제어문
@subsection 반복적 실행: @code{for} 루프, @code{repeat} 및 @code{while}
@findex for

또한 @code{for} 루프 구문이 있으며 형식은 다음과 같습니다.

@example
> for (@code{@var{name}} in @var{expr_1}) @var{expr_2}
@end example

@noindent
여기서 @code{@var{name}}은 루프 변수입니다. @var{expr_1}은 벡터 표현식이며(대개 @code{1:20}과 같은 시퀀스가 사용됩니다), @var{expr_2}는 종종 더미 @emph{name} 관련하여 작성된 하위 표현식을 가진 그룹화된 표현식입니다. @var{expr_2}는 @var{name}이 @var{expr_1}의 벡터 결과 값들을 순회하며 반복적으로 평가됩니다.

예를 들어, @code{ind}가 클래스 지시자의 벡터이고 클래스 내에서 @code{y} 대 @code{x}의 별도의 플롯을 생성하려고 한다고 가정해 봅시다. 여기서 사용할 수 있는 한 가지 방법은 @code{coplot()}을 사용하는 것입니다. 이렇게 하면 요소의 각 레벨에 해당하는 플롯 배열이 생성됩니다. 이제 모든 플롯을 하나의 디스플레이에 놓는 또 다른 방법은 다음과 같습니다:

@example
> xc <- split(x, ind)
> yc <- split(y, ind)
> for (i in 1:length(yc)) @{
    plot(xc[[i]], yc[[i]])
    abline(lsfit(xc[[i]], yc[[i]]))
  @}
@end example

@findex split

(@code{split()} 함수에 유의하세요. 이 함수는 인수에 의해 지정된 클래스에 따라 더 큰 벡터를 분할하여 벡터 목록을 생성합니다. 이 함수는 주로 상자 그림과 관련하여 사용되며 유용한 함수입니다. 자세한 내용은 @code{help} 기능을 참조하세요.)

@quotation
@strong{경고}: @code{for()} 루프는 @R{} 코드에서 컴파일된 언어보다 훨씬 덜 사용됩니다. '전체 객체' 관점을 취하는 코드는 @R{}에서 더 명확하고 빠를 가능성이 높습니다.
@end quotation

기타 루핑 기능에는

@example
> repeat @var{expr}
@end example
@findex repeat

@noindent
문과

@example
> while (@var{condition}) @var{expr}
@end example
@findex while

@noindent
문이 포함됩니다.

@code{break} 문을 사용하여 모든 루프를 종료할 수 있으며, 이는 비정상적으로 종료될 수 있습니다. 이것은 @code{repeat} 루프를 종료하는 유일한 방법입니다.
@findex break

@code{next} 문을 사용하여 특정 사이클을 중단하고 "다음"으로 건너뛸 수 있습니다.
@findex next

제어문은 주로 @ref{직접 함수 작성하기}에서 논의되는 @emph{함수}와 관련하여 사용되며 여기에서 더 많은 예제가 나타납니다.

@node 직접 함수 작성하기, R에서의 통계 모델, 루프와 조건 실행, 상위
@chapter 직접 함수 작성하기
@cindex 함수 작성

우리가 지금까지 비공식적으로 살펴본 바와 같이, @R{} 언어는 사용자가 모드 @emph{function}의 객체를 생성할 수 있습니다. 이것들은 특수한 내부 형식으로 저장되는 진정한 @R{} 함수이며, 추가 표현식 등에서 사용할 수 있습니다. 이 과정에서 언어는 힘, 편리성 및 우아함에서 엄청난 발전을 이루며, 유용한 함수를 작성하는 방법을 배우는 것은 @R{} 사용을 편안하고 생산적으로 만드는 주요 방법 중 하나입니다.

@R{} 시스템의 일부로 제공되는 대부분의 함수(예: @code{mean()}, @code{var()}, @code{postscript()} 등)는 @R{}에서 작성되었으므로 사용자가 작성한 함수와 본질적으로 다르지 않다는 점을 강조할 필요가 있습니다.

함수는 다음과 같은 형식의 할당으로 정의됩니다.

@example
> @var{name} <- function(@var{arg_1}, @var{arg_2}, @dots{}) @var{expression}
@end example
@findex function

@noindent
@var{expression}은 인수 @var{arg_i}를 사용하여 값을 계산하는 @R{} 표현식입니다(일반적으로 그룹화된 표현식). 표현식의 값은 함수의 반환 값입니다.

그런 다음 함수 호출은 일반적으로 @code{@var{name}(@var{expr_1}, @var{expr_2}, @dots{})} 형식을 취하며 함수 호출이 합당한 어디에서나 발생할 수 있습니다.

@menu
* 간단한 예제::             
* 새로운 이진 연산자 정의하기::  
* 이름 지정 인자와 기본값::  
* 세 점 인자::     
* 함수 내 할당::  
* 더 고급 예제들::      
* 영역::                       
* 환경 사용자 정의하기::  
* 객체 지향::          
@end menu

@node 간단한 예제, 새로운 이진 연산자 정의하기, 직접 함수 작성하기, 직접 함수 작성하기
@section 간단한 예제

첫 번째 예로, 두 표본의 @math{t}-통계량을 계산하는 함수를 생각해 보세요. 이것은 인위적인 예제입니다. 왜냐하면 같은 목적을 달성하는 더 간단한 방법이 있기 때문입니다.

함수는 다음과 같이 정의됩니다:

@example
> twosam <- function(y1, y2) @{
    n1  <- length(y1); n2  <- length(y2)
    yb1 <- mean(y1);   yb2 <- mean(y2)
    s1  <- var(y1);    s2  <- var(y2)
    s <- ((n1-1)*s1 + (n2-1)*s2)/(n1+n2-2)
    tst <- (yb1 - yb2)/sqrt(s*(1/n1 + 1/n2))
    tst
  @}
@end example

이 함수가 정의되면 다음과 같은 호출을 사용하여 두 표본의 @math{t}-검정을 수행할 수 있습니다.

@example
> tstat <- twosam(data$male, data$female); tstat
@end example

두 번째 예로, @sc{Matlab} 백슬래시 명령을 직접 에뮬레이션하는 함수를 고려해 보십시오. 이 명령은 벡터 @math{y}의 정사영을 행렬 @math{X}의 열 공간에 대한 계수를 반환합니다. (이것은 일반적으로 회귀 계수의 최소 제곱 추정값이라고 합니다.) 이것은 일반적으로 @code{qr()} 함수로 수행되지만, 때로는 이것을 직접 사용하는 것이 조금 까다롭기 때문에 다음과 같은 간단한 함수를 사용하는 것이 좋습니다.

따라서 @math{n} by @math{1} 벡터 @math{y}와 @math{n} by @math{p} 행렬 @math{X}가 주어지면 @math{X \ y}는 
@ifnottex
(X'X)^@{-@}X'y, 여기서 (X'X)^@{-@}
@end ifnottex
@tex
$(X^T X)^{-}X^T y$, 여기서 $(X^T X)^{-}$
@end tex
은 @math{X'X}의 일반화된 역행렬입니다.

@example
> bslash <- function(X, y) @{
  X <- qr(X)
  qr.coef(X, y)
@}
@end example

이 객체가 생성된 후에는 다음과 같은 문장에서 사용할 수 있습니다.

@example
> regcoeff <- bslash(Xmat, yvar)
@end example

@noindent
등등.

클래식한 @R{} 함수인 @code{lsfit()}은 이 작업을 상당히 잘 수행하며, 더 많은 작업을 수행합니다@footnote{@ref{R에서의 통계 모델}에서 설명하는 메서드도 참조하십시오}. 이 함수는 앞에서 언급한 약간 직관에 어긋나는 방식으로 함수 @code{qr()} 및 @code{qr.coef()}를 사용하여 계산의 이 부분을 수행합니다. 따라서 자주 사용할 경우 간단한 사용 함수에서 이 부분만 분리하는 것이 어느 정도 가치가 있을 것입니다. 그렇다면 이를 행렬 이진 연산자로 만들어 더 편리하게 사용할 수 있을 것입니다.

@node 새로운 이진 연산자 정의하기, 이름 지정 인자와 기본값, 간단한 예제, 직접 함수 작성하기
@section 새로운 이진 연산자 정의하기
@cindex 이진 연산자

@code{bslash()} 함수에 다른 이름을 지정했다면, 즉 다음 형식의 이름을 지정했다면

@example
%@var{anything}%
@end example

@noindent
이 함수는 함수 형식이 아닌 표현식에서 @emph{이진 연산자}로 사용할 수 있었습니다. 예를 들어 내부 문자로 @code{!}을 선택한다고 가정해 봅시다. 그러면 함수 정의는 다음과 같이 시작됩니다.

@example
> "%!%" <- function(X, y) @{ @dots{} @}
@end example

@noindent
(따옴표 사용에 주목하세요.) 그러면 함수를 @code{X %!% y}로 사용할 수 있습니다. (역 슬래시 기호 자체는 이 문맥에서 특별한 문제를 제기하기 때문에 편리한 선택이 아닙니다.)

행렬 곱셈 연산자 @code{%*%}와 외적 행렬 연산자 @code{%o%}는 이와 같은 방식으로 정의된 이진 연산자의 다른 예입니다.

@node 이름 지정 인자와 기본값, 세 점 인자, 새로운 이진 연산자 정의하기, 직접 함수 작성하기
@section 이름 지정 인자와 기본값
@cindex 명명된 인자
@cindex 기본값

@ref{규칙적인 수열 생성}에서 처음으로 언급했듯이, 호출된 함수에 대한 인수가 "@code{@var{name}=@var{object}}" 형식으로 주어진 경우에는 임의의 순서로 제공될 수 있습니다. 더욱이 인수 시퀀스는 이름이 지정되지 않은 위치 형식으로 시작하여 위치 인수 뒤에 명명된 인수를 지정할 수 있습니다.

따라서 다음과 같이 정의된 함수 @code{fun1}이 있다면

@example
> fun1 <- function(data, data.frame, graph, limit) @{
    @r{[function body omitted]}
  @}
@end example

@noindent
그런 다음 함수는 여러 가지 방법으로 호출될 수 있습니다. 예를 들어

@example
> ans <- fun1(d, df, TRUE, 20)
> ans <- fun1(d, df, graph=TRUE, limit=20)
> ans <- fun1(data=d, limit=20, graph=TRUE, data.frame=df)
@end example

@noindent
모두 동일합니다.

많은 경우 인수에 일반적으로 적절한 기본값을 지정할 수 있으며, 이 경우 기본값이 적절할 때 호출에서 완전히 생략할 수 있습니다. 예를 들어, @code{fun1}이 다음과 같이 정의된 경우

@example
> fun1 <- function(data, data.frame, graph=TRUE, limit=20) @{ @dots{} @}
@end example

@noindent
다음과 같이 호출할 수 있습니다.

@example
> ans <- fun1(d, df)
@end example

@noindent
이제 위의 세 가지 경우와 동일하거나 다음과 같이 호출할 수 있습니다.

@example
> ans <- fun1(d, df, limit=10)
@end example

@noindent
기본값 중 하나를 변경합니다.

중요한 것은 기본값이 상수로만 제한되지 않고 임의의 표현식이 될 수 있다는 것입니다. 여기에 나온 간단한 예제처럼 다른 함수의 인수로 사용되기도 합니다.

@node 세 점 인자, 함수 내 할당, 이름 지정 인자와 기본값, 직접 함수 작성하기
@section @samp{@dots{}} 인자

@c The ?Reserved topic links here, so please update it
@c if changing the node name.

다른 일반적인 요구 사항은 하나의 함수가 인수 설정을 다른 함수에 전달하도록 허용하는 것입니다. 예를 들어, 많은 그래픽 함수는 @code{par()} 함수를 사용하고 @code{plot()}과 같은 함수들은 사용자가 그래픽 출력을 제어하기 위해 @code{par()}에 그래픽 매개변수를 전달할 수 있도록 합니다. (@xref{par() 함수}에서 @code{par()} 함수에 대한 자세한 내용을 확인할 수 있습니다.) 이것은 함수에 추가 인수, 문자 그대로 @samp{@dots{}},를 포함시켜 전달할 수 있습니다. 아래에 개요 예제가 있습니다.

@example
fun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) @{
@r{[omitted statements]}
if (graph)
par(pch="*", ...)
@r{[more omissions]}
@}
@end example

덜 자주 사용되지만, 함수가 @samp{@dots{}}의 구성 요소를 참조해야 하는 경우가 있습니다. 표현식 @code{list(...)}는 모든 해당 인수를 평가하고 이름이 있는 목록으로 반환하며, @code{..1}, @code{..2} 등은 한 번에 하나씩 평가합니다. @samp{..n}은 n 번째 매치되지 않은 인수를 반환합니다.

@node 함수 내 할당, 더 고급 예제들, 세 점 인자, 직접 함수 작성하기
@section 함수 내 할당

함수 내에서 수행되는 일반적인 할당은 @emph{지역적이고 일시적이며 함수에서 종료 후 사라집니다}. 따라서 @code{X <- qr(X)}와 같은 할당은 호출 프로그램의 인수 값에 영향을 주지 않습니다.

@R{} 할당의 범위를 지배하는 규칙을 완전히 이해하려면 독자가 평가 @emph{프레임} 개념에 익숙해야 합니다. 이것은 다소 고급이지만 어렵지 않은 주제이며 여기서는 더 이상 다루지 않습니다.

함수 내에서 전역적이고 영구적인 할당이 의도된 경우, "슈퍼 할당" 연산자인 @code{<<-} 또는 함수 @code{assign()}을 사용할 수 있습니다. 자세한 내용은 @code{help} 문서를 참조하십시오.
@c @SPLUS{} 사용자들은 @code{<<-}가 @R{}에서 다른 의미를 가진다는 것을 알아야 합니다. 이것들은 @ref{영역}에서 더 자세히 논의되어 있습니다.

@node 더 고급 예제들, 영역, 함수 내 할당, 직접 함수 작성하기
@section 더 고급 예제들

@menu
* 블록 설계에서의 효율성 요소::
* 출력된 배열에서 모든 이름 삭제하기::
* 재귀적 수치 적분::
@end menu
@node 블록 설계에서의 효율성 요소, 출력된 배열에서 모든 이름 삭제하기, 더 고급 예제들, 더 고급 예제들
@subsection 블록 설계에서의 효율성 요소

블록 디자인의 효율성 요소를 찾는 것을 고려해 함수의 좀 더 완전한 예시를 살펴보겠습니다. (이 문제의 일부 측면은 이미 @ref{색인 행렬}에서 논의되었습니다.)

블록 디자인은 두 요인, 즉 @code{blocks} (@code{b} 수준)과 @code{varieties} (@code{v} 수준)에 의해 정의됩니다. @math{R}과 @math{K}가 각각 @math{v} x @math{v} 및 @math{b} x @math{b} @emph{복제} 및 @emph{블록 크기} 행렬이고 @math{N}이 @math{b} x @math{v} 발생 행렬이라면, 효율성 요소는 다음과 같이 정의됩니다.
@ifnottex
E = I_v - R^@{-1/2@}N'K^@{-1@}NR^@{-1/2@} = I_v - A'A, where
A = K^@{-1/2@}NR^@{-1/2@}.
@end ifnottex
@tex
$$E = I_v - R^{-1/2}N^T K^{-1}NR^{-1/2} = I_v - A^T A,$$
where $A = K^{-1/2}NR^{-1/2}$.
@end tex
함수를 작성하는 한 가지 방법은 아래와 같습니다.

@example
> bdeff <- function(blocks, varieties) @{
    blocks <- as.factor(blocks)             # @r{minor safety move}
    b <- length(levels(blocks))
    varieties <- as.factor(varieties)       # @r{minor safety move}
    v <- length(levels(varieties))
    K <- as.vector(table(blocks))           # @r{remove dim attr}
    R <- as.vector(table(varieties))        # @r{remove dim attr}
    N <- table(blocks, varieties)
    A <- 1/sqrt(K) * N * rep(1/sqrt(R), rep(b, v))
    sv <- svd(A)
    list(eff=1 - sv$d^2, blockcv=sv$u, varietycv=sv$v)
@}
@end example

이번 경우에는 고유값 루틴보다 특이값 분해를 사용하는 것이 수치적으로 약간 더 좋습니다.

함수의 결과는 첫 번째 구성 요소로 효율성 요소뿐만 아니라 블록과 다양한 대수 변환도 제공하는 리스트입니다. 이 정보들은 때때로 추가적인 유용한 질적 정보를 제공하기 때문입니다.

@node 출력된 배열에서 모든 이름 삭제하기, 재귀적 수치 적분, 블록 설계에서의 효율성 요소, 더 고급 예제들
@subsection 출력된 배열에서 모든 이름 삭제하기

큰 행렬이나 배열을 다룰 때 인쇄 목적으로, 배열 이름이나 번호 없이 밀집된 블록 형태로 인쇄하는 것이 종종 유용합니다. @code{dimnames} 속성을 제거하면 이 효과를 얻을 수 없습니다. 대신 배열에 빈 문자열로 구성된 @code{dimnames} 속성을 지정해야 합니다. 예를 들어 행렬 @code{X}를 인쇄하려면

@example
> temp <- X
> dimnames(temp) <- list(rep("", nrow(X)), rep("", ncol(X)))
> temp; rm(temp)
@end example

이것은 함수 @code{no.dimnames()}를 사용하여 훨씬 더 편리하게 수행할 수 있으며, 아래에 나와 있는 것처럼 동일한 결과를 얻기 위한 "래핑"으로 사용됩니다. 또한 몇 가지 효과적이고 유용한 사용자 함수가 꽤 짧을 수 있다는 것을 보여줍니다.

@example
no.dimnames <- function(a) @{

@r{배열에서 모든 차원 이름을 제거하여 압축된 인쇄를 가능하게 함.}
d <- list()
l <- 0
for(i in dim(a)) @{
d[[l <- l + 1]] <- rep("", i)
@}
dimnames(a) <- d
a
@}
@end example

이 함수가 정의되면, 배열을 밀집 형식으로 인쇄할 수 있습니다.

@example

no.dimnames(X)
@end example

이는 특히 값보다 패턴에 관심이 있는 큰 정수 배열에 유용합니다.

@node 재귀적 수치 적분, , 출력된 배열에서 모든 이름 삭제하기, 더 고급 예제들
@subsection 재귀적 수치 적분

함수는 재귀적일 수 있고, 함수 내부에서 자체 함수를 정의할 수도 있습니다. 그러나 이러한 함수나 변수는 검색 경로에 있을 경우처럼 상위 평가 프레임에서 호출된 함수로 상속되지 않습니다.

아래 예제는 일차원 수치 적분을 수행하는 간단한 방법을 보여줍니다. 피적분 함수는 범위의 끝점과 중간에서 평가됩니다. 한 패널의 사다리꼴 규칙 대답이 충분히 가깝다면, 후자가 값으로 반환됩니다. 그렇지 않으면 각 패널에 대해 동일한 프로세스가 재귀적으로 적용됩니다. 결과적으로 적분 함수가 선형에서 가장 멀리 떨어진 영역에서 함수 평가를 집중하는 적응 적분 프로세스가 생성됩니다. 그러나 무거운 오버헤드가 있고, 피적분 함수가 매끄럽고 평가하기 매우 어려울 때만 다른 알고리즘과 경쟁력이 있습니다.

이 예제는 또한 R 프로그래밍에서 약간의 퍼즐처럼 제공됩니다.

@example
area <- function(f, a, b, eps = 1.0e-06, lim = 10) @{
fun1 <- function(f, a, b, fa, fb, a0, eps, lim, fun) @{
## @r{함수 fun1'은 area' 내부에서만 볼 수 있습니다.}
    d <- (a + b)/2
    h <- (b - a)/4
    fd <- f(d)
    a1 <- h * (fa + fd)
    a2 <- h * (fd + fb)
    if(abs(a0 - a1 - a2) < eps || lim == 0)
      return(a1 + a2)
    else @{
      return(fun(f, a, d, fa, fd, a1, eps, lim - 1, fun) +
             fun(f, d, b, fd, fb, a2, eps, lim - 1, fun))
    @}
  @}
  fa <- f(a)
  fb <- f(b)
  a0 <- ((fa + fb) * (b - a))/2
  fun1(f, a, b, fa, fb, a0, eps, lim, fun1)
@}
@end example

@menu
* 영역::
* 객체 지향::
@end menu

@node 영역, 환경 사용자 정의하기, 더 고급 예제들, 직접 함수 작성하기
@section 영역
@cindex 영역더

이 문서의 다른 부분에 비해 이 섹션의 논의는 약간 더 기술적입니다. 그러나 이것은 @SPLUS{}와 @R{} 사이의 주요 차이점 중 하나를 상세하게 설명합니다.

함수 본문에 나타나는 기호는 세 가지 클래스로 나눌 수 있습니다; 형식 매개변수, 지역 변수 및 자유 변수입니다. 함수의 형식 매개변수는 함수 인수 목록에 나타나는 변수들입니다. 이들의 값은 실제 함수 인수를 형식 매개변수에 @emph{바인딩}하는 과정에 의해 결정됩니다. 지역 변수는 함수 본문의 표현식을 평가함으로써 결정되는 값입니다. 형식 매개변수 또는 지역 변수가 아닌 변수를 자유 변수라고 합니다. 자유 변수는 그것들에게 할당되면 지역 변수가 됩니다. 다음 함수 정의를 고려하십시오.

@example
f <- function(x) @{
  y <- 2*x
  print(x)
  print(y)
  print(z)
@}
@end example

이 함수에서 @code{x}는 형식 매개변수, @code{y}는 지역 변수, @code{z}는 자유 변수입니다.

@R{}에서 자유 변수 바인딩은 함수가 생성된 환경에서 먼저 찾아보도록 결정됩니다. 이것을 @emph{어휘 범위}라고 합니다. 먼저 @code{cube}라는 함수를 정의합니다.

@example
cube <- function(n) @{
  sq <- function() n*n
  n*sq()
@}
@end example

함수 @code{sq}의 변수 @code{n}은 해당 함수의 인수가 아닙니다. 따라서 자유 변수이며, 유효 범위 규칙을 사용하여 그것과 관련된 값을 확인해야 합니다. 정적 범위(@SPLUS{})에서 값은 전역 변수 @code{n}에 연결된 값입니다. 어휘 범위(@R{})에서는 함수 @code{sq}가 정의된 시점에 변수 @code{n}에 대한 활성 바인딩인 함수 @code{cube}의 매개변수입니다. @R{}에서 평가와 @SPLUS{}에서 평가의 차이점은 @SPLUS{}가 @code{n}이라는 전역 변수를 찾는 반면, @R{}은 먼저 @code{cube}가 호출될 때 생성된 환경에서 @code{n}이라는 변수를 찾습니다.

@example

@r{S에서의 첫 번째 평가}
S> cube(2)
Error in sq(): 객체 "n"을 찾을 수 없음
Dumped
S> n <- 3
S> cube(2)
[1] 18

@r{그런 다음 R에서 동일한 함수 평가}
R> cube(2)
[1] 8
@end example

어휘 범위는 또한 함수에 @emph{가변 상태}를 제공하는 데 사용할 수 있습니다. 다음 예제에서는 @R{}이 은행 계좌를 모방하는 방법을 보여줍니다. 정상적인 은행 계좌는 잔액 또는 총액, 인출을 위한 함수, 입금을 위한 함수, 그리고 현재 잔액을 알려주는 함수가 필요합니다. 우리는 @code{account} 내에서 세 가지 함수를 생성한 다음 그것들을 포함하는 목록을 반환함으로써 이를 달성합니다. @code{account}가 호출되면 숫자 인수 @code{total}을 사용하고 세 가지 함수를 포함하는 목록을 반환합니다. 이 함수들은 @code{total}을 포함하는 환경에서 정의되므로 해당 값에 액세스할 수 있습니다.

특별한 할당 연산자 @code{<<-}는 @code{total}과 관련된 값을 변경하는 데 사용됩니다. 이 연산자는 @code{total}이라는 기호가 포함된 환경을 찾을 때까지 상위 환경을 검색하고 그러한 환경을 찾으면 해당 환경의 값을 오른쪽 값으로 대체합니다. @code{total}이라는 기호를 찾지 못한 채 전역 또는 최상위 환경에 도달하면 해당 변수가 생성되고 할당됩니다. 대부분의 사용자들에게 @code{<<-}는 전역 변수를 생성하고 오른쪽 값으로 할당합니다@footnote{어떤 의미에서 이것은 @SPLUS{}에서의 동작을 모방합니다. 왜냐하면 @SPLUS{}에서 이 연산자는 항상 전역 변수를 생성하거나 할당하기 때문입니다.}. 다른 함수의 값으로 반환된 함수에서 @code{<<-}를 사용했을 때만 여기서 설명한 특별한 동작이 발생합니다.

@example
open.account <- function(total) @{
  list(
    deposit = function(amount) @{
      if(amount <= 0)
        stop("Deposits must be positive!\n")
      total <<- total + amount
      cat(amount, "deposited.  Your balance is", total, "\n\n")
    @},
    withdraw = function(amount) @{
      if(amount > total)
        stop("You don't have that much money!\n")
      total <<- total - amount
      cat(amount, "withdrawn.  Your balance is", total, "\n\n")
    @},
    balance = function() @{
      cat("Your balance is", total, "\n\n")
    @}
  )
@}

ross <- open.account(100)
robert <- open.account(200)

ross$withdraw(30)
ross$balance()
robert$balance()

ross$deposit(50)
ross$balance()
ross$withdraw(500)
@end example

@node 환경 사용자 정의하기, 객체 지향, 영역, 직접 함수 작성하기
@section 환경 사용자 정의하기
@cindex 환경 사용자 정의하기

사용자는 여러 가지 방법으로 환경을 사용자 정의할 수 있습니다. 사이트 초기화 파일이 있고 모든 디렉토리에는 고유한 특수 초기화 파일이 있을 수 있습니다. 마지막으로 특수 함수인 @code{.First}와 @code{.Last}를 사용할 수 있습니다.

사이트 초기화 파일의 위치는 @env{R_PROFILE} 환경 변수의 값에서 가져옵니다. 해당 변수가 설정되지 않은 경우, @R{} 홈 서브디렉토리 @file{etc}의 @file{Rprofile.site} 파일이 사용됩니다. 이 파일에는 시스템에서 @R{}을 시작할 때마다 실행하려는 명령어를 포함해야 합니다. 두 번째 개인 프로필 파일인 @file{.Rprofile}@footnote{UNIX에서 숨겨져 있습니다.}는 모든 디렉토리에 위치할 수 있습니다. 해당 디렉토리에서 @R{}이 호출되면 해당 파일이 로드됩니다. 이 파일은 개별 사용자가 작업 공간을 제어할 수 있게 해주며, 다른 작업 디렉토리에서 다른 시작 프로시저를 허용합니다. 시작 디렉토리에서 @file{.Rprofile} 파일을 찾을 수 없는 경우, @R{}은 사용자의 홈 디렉토리에서 @file{.Rprofile} 파일을 찾고 해당 파일이 있으면 사용합니다. @env{R_PROFILE_USER} 환경 변수가 설정된 경우, 해당 변수가 가리키는 파일이 @file{.Rprofile} 파일 대신 사용됩니다.

두 프로필 파일이나 @file{.RData} 이미지에 있는 @code{.First()}라는 함수는 특별한 지위를 가지고 있습니다. 이 함수는 @R{} 세션 시작 시 자동으로 수행되며 환경을 초기화하는 데 사용됩니다. 예를 들어, 아래 예제에서의 정의는 프롬프트를 @code{$}로 변경하고 세션의 나머지 부분에서 당연하게 간주할 수 있는 다양한 유용한 것들을 설정합니다.

따라서 파일이 실행되는 순서는 다음과 같습니다. @file{Rprofile.site}, 사용자 프로필, @file{.RData}, 그리고 나서 @code{.First()}. 후속 파일에서의 정의는 이전 파일에서의 정의를 가리게 됩니다.

@example
> .First <- function() @{
  options(prompt="$ ", continue="+\t")  # @r{@code{$}는 프롬프트입니다}
  options(digits=5, length=999)         # @r{사용자 정의 숫자 및 출력}
  x11()                                 # @r{그래픽용}
  par(pch = "+")                        # @r{플로팅 문자}
  source(file.path(Sys.getenv("HOME"), "R", "mystuff.R"))
                                        # @r{내 개인 함수들}
  library(MASS)                         # @r{패키지 연결}
@}
@end example
@findex .First

마찬가지로 정의된 경우 함수 @code{.Last()}는 (보통) 세션의 맨 끝에서 실행됩니다. 아래에 예제가 나와 있습니다.

@example
> .Last <- function() @{
  graphics.off()                        # @r{작은 안전 조치.}
  cat(paste(date(),"\n안녕히 가세요\n"))        # @r{점심시간인가요?}
@}
@end example
@findex .Last

@node 객체 지향,  , 환경 사용자 정의하기, 직접 함수 작성하기
@section 클래스, 일반 함수 및 객체 지향
@cindex 클래스
@cindex 일반 함수
@cindex 객체 지향

객체의 클래스는 @emph{일반 함수}로 알려진 것이 어떻게 처리될지 결정합니다. 반대로 말하면, 일반 함수는 인수의 클래스에 따라 인수에 대한 작업이나 동작을 수행합니다. 인수에 @code{class} 속성이 없거나, 해당 일반 함수에서 특별히 처리되지 않는 클래스가 있으면 항상 기본 동작이 제공됩니다.

예를 들어 명확하게 하자면, 클래스 메커니즘은 사용자에게 특별한 목적을 위해 일반 함수를 설계하고 작성할 수 있는 기능을 제공합니다. 다른 일반 함수로는 객체를 그래픽으로 표시하는 @code{plot()}, 다양한 유형의 분석을 요약하는 @code{summary()}, 통계 모델을 비교하는 @code{anova()}가 있습니다.

특정 방식으로 클래스를 처리할 수 있는 일반 함수의 수는 꽤 많을 수 있습니다. 예를 들어, 클래스 @code{"data.frame"}의 객체를 어떤 방식으로든 수용할 수 있는 함수에는 다음과 같은 것들이 포함됩니다.

@example
[     [[<-    any    as.matrix
[<-   mean    plot   summary
@end example

@findex methods
현재 완전한 목록은 @code{methods()} 함수를 사용하여 얻을 수 있습니다.

@example
> methods(class="data.frame")
@end example

반대로 일반 함수가 처리할 수 있는 클래스의 수도 꽤 많을 수 있습니다. 예를 들어 @code{plot()} 함수는 기본 메서드와 클래스 @code{"data.frame"}, @code{"density"}, @code{"factor"} 등의 객체에 대한 변형이 있습니다. 완전한 목록을 다시 얻으려면 @code{methods()} 함수를 사용하십시오.

@example
> methods(plot)
@end example

많은 일반 함수의 경우 함수 본문이 꽤 짧습니다. 예를 들어

@example
> coef
function (object, ...)
UseMethod("coef")
@end example

@noindent
@code{UseMethod}의 존재는 이것이 일반 함수임을 나타냅니다.
어떤 메서드들이 사용 가능한지 확인하기 위해 @code{methods()}를 사용할 수 있습니다.

@example
> methods(coef)
[1] coef.aov*         coef.Arima*       coef.default*     coef.listof*
[5] coef.nls*         coef.summary.nls*

   보이지 않는 함수는 별표로 표시되어 있음
@end example

@noindent
이 예에서는 이름을 입력하여 볼 수 없는 6개의 메서드가 있습니다. 이들을 읽는 방법은 다음 중 하나를 사용합니다.

@findex getAnywhere
@findex getS3method
@example
> getAnywhere("coef.aov")
A single object matching 'coef.aov' was found
It was found in the following places
  registered S3 method for coef from namespace stats
  namespace:stats
with value

function (object, ...)
@{
    z <- object$coef
    z[!is.na(z)]
@}

> getS3method("coef", "aov")
function (object, ...)
@{
    z <- object$coef
    z[!is.na(z)]
@}
@end example

함수의 이름이 @code{@var{gen}.@var{cl}}로 지정되면 일반 함수 @code{@var{gen}}에 클래스 @code{@var{cl}}에 대해 호출되므로, 메서드가 아닌 경우 이러한 스타일로 함수를 명명하지 마십시오.

더 완전한 이 메커니즘에 대한 논의는 @emph{R 언어 정의}를 참조하십시오.

@node R에서의 통계 모델, 그래픽스, 직접 함수 작성하기, 상위
@chapter R에서의 통계 모델
@cindex 통계 모델

이 섹션에서는 독자가 통계 방법론, 특히 회귀 분석 및 분산 분석에 대해 어느 정도 친숙하다고 가정합니다. 나중에는 조금 더 야심 찬 가정을 합니다. 즉, 일반화 선형 모델 및 비선형 회귀에 대해 알려진 것이 있다고 가정합니다.

통계 모델을 적합시키기 위한 요구 사항은 충분히 잘 정의되어 넓은 범위의 문제에 적용되는 일반 도구를 구축할 수 있습니다.

@R{}은 통계 모델을 매우 간단하게 적합시키는 기능들이 서로 결합된 일련의 시설을 제공합니다. 서론에서 언급했듯이 기본 출력은 최소하며, 세부 사항을 추출 함수를 호출하여 요청해야 합니다.

@menu
* 통계 모델을 위한 공식::  
* 선형 모델::               
* 모델 정보 추출을 위한 일반 함수::  
* 분산 분석 및 모델 비교::  
* 적합된 모델 업데이트::      
* 일반화 선형 모델::   
* 비선형 최소 제곱 및 최대 우도 모델::  
* 일부 비-표준 모델::    
@end menu

@node 통계 모델을 위한 공식, 선형 모델, R에서의 통계 모델, R에서의 통계 모델
@section 통계 모델 정의하기; 공식
@cindex 공식

통계 모델의 템플릿은 독립적이고 등분산 오차를 가진 선형 회귀 모델입니다.

@ifnottex
@display
y_i = sum_@{j=0@}^p beta_j x_@{ij@} + e_i, @ @ @ @ i = 1, @dots{}, n,
@end display
@noindent
여기서 e_i는 NID(0, sigma^2)입니다.
@end ifnottex
@tex
$$ y_i = \sum_{j=0}^p \beta_j x_{ij} + e_i,
   \qquad e_i \sim {\rm NID}(0,\sigma^2),
   \qquad i = 1, @dots{}, n
$$
@end tex
행렬 용어로는 다음과 같이 작성됩니다.

@ifnottex
@display
y = X @ beta + e
@end display
@end ifnottex
@tex
�
=
�
�
+
�
y=Xβ+e
@end tex

@noindent
여기서 @math{y}는 응답 벡터, @math{X}는 @emph{모델 행렬} 또는 @emph{디자인 행렬}로서
@math{x_0, x_1, @dots{}, x_p} 열을 가지며, 이는 결정 변수입니다. 매우 자주 @math{x_0}
는 @emph{절편} 항을 정의하는 열로 사용됩니다.

@subsubheading 예시

정식 명세를 제공하기 전에 몇 가지 예가 유용하게 그림을 그릴 수 있습니다.

@code{y}, @code{x}, @code{x0}, @code{x1}, @code{x2}, @dots{}이 숫자 변수이고, @code{X}는 행렬이며, @code{A}, @code{B}, @code{C}, @dots{}은 요인이라고 가정합니다. 아래 왼쪽에 있는 다음 수식은 오른쪽에 설명된 통계 모델을 지정합니다.

@table @code
@item y ~ x
@itemx y ~ 1 + x
둘 다 @math{y}와 @math{x}에 대한 동일한 단순 선형 회귀 모델을 의미합니다. 첫 번째는 암시적 절편 항을 가지고 있고, 두 번째는 명시적 절편 항을 가지고 있습니다.

@item y ~ 0 + x
@itemx y ~ -1 + x
@itemx y ~ x - 1
원점을 지나는 @math{y}와 @math{x}에 대한 단순 선형 회귀(즉, 절편 항 없음).

@item log(y) ~ x1 + x2
변환된 변수에 대한 다중 회귀,
@ifnottex
log(y),
@end ifnottex
@tex
$\log(y)$,
@end tex
@math{x1} 및 @math{x2}에 대해 (암시적 절편 항 포함).

@item y ~ poly(x,2)
@itemx y ~ 1 + x + I(x^2)
@math{y}에 대한 2차 다항 회귀 분석. 첫 번째 형식은 직교 다항식을 사용하고 두 번째 형식은 명시적 제곱을 사용하여 기저를 형성합니다.

@item y ~ X + poly(x,2)
행렬 @math{X}와 @math{x}의 2차 다항식 항을 포함하는 모델 행렬로 이루어진 다중 회귀 @math{y}.

@item y ~ A
@math{A}에 의해 결정된 클래스로 @math{y}의 단일 분류 분산 분석 모델.

@item y ~ A + x
@math{A}에 의해 결정된 클래스와 공변량 @math{x}를 가진 @math{y}의 단일 분류 공분산 분석 모델.

@item y ~ A*B
@itemx y ~ A + B + A:B
@itemx y ~ B %in% A
@itemx y ~ A/B
@math{A}와 @math{B}에 대한 @math{y}의 두 요인 비첨가 모델. 처음 두 개는 교차 분류를 지정하고 두 번째 두 개는 중첩 분류를 지정합니다. 추상적인 용어로 모든 네 개는 동일한 모델 부분 공간을 지정합니다.

@item y ~ (A + B + C)^2
@itemx y ~ A*B*C - A:B:C
주 효과와 두 요인 간 상호 작용만을 포함하는 모델로서의 세 요인 실험. 두 가지 공식 모두 같은 모델을 지정합니다.

@item y ~ A * x
@itemx y ~ A/x
@itemx y ~ A/(1 + x) - 1
@math{A}의 수준 내에서 @math{y}와 @math{x}에 대한 별도의 단순 선형 회귀 모델, 서로 다른 코딩이 있습니다. 마지막 형식은 @math{A}의 수준에 따라 서로 다른 절편과 기울기의 명시적 추정치를 생성합니다.

@item y ~ A*B + Error(C)
처리 요인 @math{A}와 @math{B}와 오차 계층이 요인 @math{C}에 의해 결정되는 실험. 예를 들어, 전체 플롯(따라서 서브 플롯도)이 요인 @math{C}에 의해 결정되는 분할 플롯 실험.
@end table

@findex ~
연산자 @code{~}는 @R{}에서 @emph{모델 수식}을 정의하는 데 사용됩니다.
일반적인 선형 모델의 형태는 다음과 같습니다.

@example
@var{response} ~ @var{op_1} @var{term_1} @var{op_2} @var{term_2} @var{op_3} @var{term_3} @var{@dots{}}
@end example

@noindent
여기서

@table @var
@item response
응답 변수를 정의하는 벡터 또는 행렬입니다(또는 벡터 또는 행렬로 평가되는 표현식).
@item op_i
항을 모델에 포함시키거나 제외시키는 것을 의미하는 연산자로, @code{+} 또는 @code{-} 중 하나입니다(첫 번째는 선택 사항입니다).
@item term_i
다음 중 하나입니다.
@itemize @bullet
@item
벡터 또는 행렬 표현식 또는 @code{1},
@item
요인(factor), 또는
@item
요인, 벡터 또는 행렬로 구성된 @emph{공식 표현식}이며, 이들은 @emph{공식 연산자}에 의해 연결됩니다.
@end itemize
모든 경우 각 항은 모델 행렬에 추가되거나 제거될 열의 모음을 정의합니다. @code{1}은 절편 열을 나타내며 명시적으로 제거되지 않는 한 모델 행렬에 기본적으로 포함됩니다.

@end table

@emph{공식 연산자}는 Glim과 Genstat과 같은 프로그램에서 사용되는 Wilkinson과 Rogers 표기법과 유사한 효과를 가집니다. 하나의 필연적인 변화는 @R{}에서 기간이 유효한 이름 문자이기 때문에 @samp{@code{.}} 연산자가 @samp{@code{:}}로 바뀌는 것입니다.

아래에 표기법이 요약되어 있습니다 (Chambers & Hastie, 1992, p.29를 기반으로):

@table @code
@item @var{Y} ~ @var{M}
@var{Y}는 @var{M}으로 모델링됩니다.

@item @var{M_1} + @var{M_2}
@var{M_1}과 @var{M_2}를 포함합니다.

@item @var{M_1} - @var{M_2}
@var{M_2}의 항을 제외한 @var{M_1}을 포함합니다.

@item @var{M_1} : @var{M_2}
@var{M_1}과 @var{M_2}의 텐서 곱입니다. 두 항이 모두 요인인 경우, "하위 클래스" 요인입니다.

@item @var{M_1} %in% @var{M_2}
@code{@var{M_1}:@var{M_2}}와 유사하지만, 다른 코딩이 있습니다.

@item @var{M_1} * @var{M_2}
@code{@var{M_1} + @var{M_2} + @var{M_1}:@var{M_2}}.

@item @var{M_1} / @var{M_2}
@code{@var{M_1} + @var{M_2} %in% @var{M_1}}.

@item @var{M}^@var{n}
@var{M} 내의 모든 항과 최대 @var{n}차까지의 "상호 작용"

@item I(@var{M})
@var{M}을 격리시킵니다. @var{M} 내부에서 모든 연산자는 일반적인 산술 의미를 가지며, 해당 항이 모델 행렬에 나타납니다.
@end table

함수 인수를 일반적으로 둘러싸는 괄호 안에서 모든 연산자는 일반적인 산술 의미를 갖는다는 점에 유의하세요. 함수 @code{I()}는 산술 연산자를 사용하여 모델 수식에서 항을 정의할 수 있도록 허용하는 항등 함수입니다.

특히 모델 수식이 @emph{모델 행렬의 열}을 지정하며, 매개변수의 명세는 암시적입니다. 이는 다른 맥락에서, 예를 들어 비선형 모델을 지정할 때는 그렇지 않습니다.

@menu
* 대조::
@end menu
@node 대조, , 통계 모델을 위한 공식, 통계 모델을 위한 공식
@subsection 대조
@cindex 대조

모델 수식이 모델 행렬의 열을 어떻게 지정하는지에 대한 최소한의 아이디어가 필요합니다. 연속 변수가 있는 경우에는 간단하게 각 변수가 모델 행렬의 한 열을 제공합니다(그리고 절편이 모델에 포함되어 있다면 1로 이루어진 열을 제공합니다).

@cindex 요인
@cindex 정렬된 요인
@math{k}-레벨 요인 @code{A}는 어떨까요? 정렬되지 않은 요인과 정렬된 요인에 대한 답변이 다릅니다. @emph{정렬되지 않은} 요인의 경우 요인의 두 번째, @dots{}, @math{k}번째 레벨의 지표를 나타내는 @math{k - 1} 열이 생성됩니다(따라서 암시적인 매개변수화는 각 레벨에서의 응답과 첫 번째 레벨에서의 응답을 대조하는 것입니다). @emph{정렬된} 요인의 경우 @math{k - 1} 열은 @math{1, @dots{}, k}에서의 직교 다항식으로, 상수항을 생략합니다.

답변이 이미 복잡하지만, 전체 이야기는 아닙니다. 첫째, 절편이 요인 항이 포함된 모델에서 생략되면, 이러한 항 중 첫 번째는 모든 레벨에 대한 지표를 제공하는 @math{k} 열로 인코딩됩니다. 둘째, 전체 행동은 @code{contrasts}에 대한 @code{options} 설정에 의해 변경될 수 있습니다. @R{}에서의 기본 설정은 다음과 같습니다.

@example
options(contrasts = c("contr.treatment", "contr.poly"))
@end example

@noindent
이를 언급하는 주요 이유는 @R{}과 @Sl{}이 정렬되지 않은 요인에 대해 다른 기본값을 사용하고 있으며, @Sl{}은 Helmert 대조를 사용합니다. 따라서 @SPLUS{}를 사용한 교과서나 논문의 결과와 비교해야 할 경우 다음을 설정해야 합니다.

@example
options(contrasts = c("contr.helmert", "contr.poly"))
@end example

@noindent
이 차이는 고의적인 차이로, 처리 대조(@R{}의 기본값)는 초보자가 해석하기에 더 쉽다고 여겨집니다.

아직 끝나지 않았습니다. 대조 방식은 모델 내 각 항에 대해 @code{contrasts}와 @code{C} 함수를 사용하여 설정할 수 있습니다.
@findex contrasts
@findex C

아직 상호 작용 항을 고려하지 않았습니다. 이들은 구성 항목에 대해 도입된 열의 곱을 생성합니다.

세부 사항은 복잡하지만, @R{}에서의 모델 공식은 일반적으로 전문 통계학자가 예상하는 모델을 생성할 것입니다. 단, 주변성이 유지되어야 합니다. 예를 들어, 상호 작용은 있는데 해당 주요 효과가 없는 모델을 적합시키면 일반적으로 놀라운 결과를 얻게 되며, 전문가만이 사용할 수 있습니다.


@node 선형 모델, 모델 정보 추출을 위한 일반 함수, 통계 모델을 위한 공식, R에서의 통계 모델
@section 선형 모델
@cindex 선형 모델

기본적인 일반 다중 모델 적합 함수는 @code{lm()}이며, 간소화된 호출 버전은 다음과 같습니다:
@findex lm

@example
> @var{fitted.model} <- lm(@var{formula}, data = @var{data.frame})
@end example

예를 들어

@example
> fm2 <- lm(y ~ x1 + x2, data = production)
@end example

@noindent
은 @math{y}를 @math{x1}과 @math{x2}에 대한 다중 회귀 모델로 적합시킵니다(암시적 절편 항 포함).

중요한(하지만 기술적으로 선택 사항인) 매개변수 @code{data = production}은 모델 구성에 필요한 변수가 우선적으로 @code{production} @emph{데이터 프레임}에서 가져와야 함을 지정합니다. @emph{데이터 프레임 @code{production}이 검색 경로에 연결되어 있든 아니든 상관없이 이 경우가 적용됩니다}.

@node 모델 정보 추출을 위한 일반 함수, 분산 분석 및 모델 비교, 선형 모델, R에서의 통계 모델
@section 모델 정보 추출을 위한 일반 함수

@code{lm()}의 값은 적합된 모델 객체입니다. 기술적으로는 @code{"lm"} 클래스의 결과 목록입니다. 적합된 모델에 대한 정보는 @code{"lm"} 클래스의 객체를 대상으로하는 일반 함수를 사용하여 표시, 추출, 그리기 등이 가능합니다. 이러한 함수에는 다음이 포함됩니다.

@example
add1 deviance formula predict step
alias drop1 kappa print summary
anova effects labels proj vcov
coef family plot residuals
@end example

아래에 가장 일반적으로 사용되는 함수들에 대한 간단한 설명이 제공됩니다.

@table @code
@findex anova
@item anova(@var{object_1}, @var{object_2})
하위 모델과 외부 모델을 비교하고 분산 분석 표를 생성합니다.

@findex coefficients
@findex coef
@item coef(@var{object})
회귀 계수(행렬)를 추출합니다.

긴 형태: @code{coefficients(@var{object})}.

@findex deviance
@item deviance(@var{object})
적절한 경우 가중치가 적용된 잔차 제곱합입니다.

@findex formula
@item formula(@var{object})
모델 공식을 추출합니다.

@findex plot
@item plot(@var{object})
잔차, 적합 값 및 일부 진단을 보여주는 네 개의 그림을 생성합니다.

@findex predict
@item predict(@var{object}, newdata=@var{data.frame})
제공된 데이터 프레임은 원래와 동일한 레이블로 지정된 변수를 가져야 합니다. 값은 @var{data.frame}의 결정 변수 값에 대응하는 예측 값 벡터 또는 행렬입니다.

@c  @item @code{predict.gam(@var{object},}
@c  @item @w{@ @ @ @code{newdata=@var{data.frame})}}
@c  @tab @code{predict.gam()}은 @code{lm}, @code{glm}, @code{gam} 적합 객체에 사용할 수 있는 @code{predict()}의 안전한 대안입니다. 예를 들어, 원래 기본 함수로 직교 다항식이 사용되고 새 데이터 추가로 인해 원래와 다른 기본 함수가 발생하는 경우에 사용해야 합니다.

@findex print
@item print(@var{object})
객체의 간결한 버전을 출력합니다. 대부분 암시적으로 사용됩니다.

@findex residuals
@findex resid
@item residuals(@var{object})
적절하게 가중된 잔차(행렬)를 추출합니다.

짧은 형태: @code{resid(@var{object})}.

@findex step
@item step(@var{object})
용어를 추가하거나 삭제하고 계층 구조를 유지함으로써 적합한 모델을 선택합니다. 단계별 검색에서 발견된 AIC (아카이케 정보 기준)의 가장 작은 값의 모델이 반환됩니다.

@findex summary
@item summary(@var{object})
회귀 분석 결과에 대한 포괄적인 요약을 출력합니다.

@findex vcov
@item vcov(@var{object})
적합된 모델 객체의 주요 파라미터의 공분산 행렬을 반환합니다.
@end table

@node 분산 분석 및 모델 비교, 적합된 모델 업데이트, 모델 정보 추출을 위한 일반 함수, R에서의 통계 모델
@section 분산 분석 및 모델 비교
@cindex 분산분석

모델 적합 함수 @code{aov(@var{formula}, data=@var{data.frame})}
@findex aov
는 가장 간단한 수준에서 함수 @code{lm()}과 매우 유사한 방식으로 작동하며, @ref{모델 정보 추출을 위한 일반 함수}의 표에 나열된 대부분의 일반 함수가 적용됩니다.

또한 @code{aov()}는 분할 플롯 실험 또는 블록 간 정보 회복을 포함한 균형 잡힌 불완전 블록 설계와 같은 여러 오차 계층을 가진 모델을 분석할 수 있습니다. 모델 공식은

@example
@var{response} ~ @var{mean.formula} + Error(@var{strata.formula})
@end example
@findex Error

@noindent
에서 오차 계층이 @var{strata.formula}에 의해 정의된 다 계층 실험을 지정합니다. 가장 간단한 경우 @var{strata.formula}는 단순히 요인이고, 이는 요인 수준 간 및 내에서 두 계층 실험을 정의합니다.

예를 들어, 모든 결정 변수가 요인인 경우 다음과 같은 모델 공식을 사용합니다:

@example
> fm <- aov(yield ~ v + n*p*k + Error(farms/blocks), data=farm.data)
@end example

@noindent
일반적으로 평균 모델 @code{v + n*p*k}와 세 개의 오차 계층, 즉 "농장 간", "농장 내, 블록 간" 및 "블록 내"의 실험을 설명하는 데 사용됩니다.

@menu
* ANOVA 표::                
@end menu

@node ANOVA 표,  , 분산 분석 및 모델 비교, 분산 분석 및 모델 비교
@subsection ANOVA 표

분산분석 표(또는 표)는 적합된 모델들의 순서에 대한 것이라는 점에 유의하십시오. 표시된 제곱합은 모델에 @emph{해당 용어}가 포함되어 순서에 따라 잔차 제곱합이 감소합니다. 따라서 서로 직교하는 실험에서만 포함 순서가 중요하지 않습니다.

다 계층 실험의 경우 먼저 오차 계층에 응답을 투영한 다음, 순서대로 각 투영에 평균 모델을 적합시킵니다. 자세한 내용은 Chambers & Hastie (1992)를 참조하십시오.

기본 전체 ANOVA 표보다 더 유연한 대안은 @code{anova()} 함수를 사용하여 두 개 이상의 모델을 직접 비교하는 것입니다.
@findex anova

@example
> anova(@var{fitted.model.1}, @var{fitted.model.2}, @dots{})
@end example

그런 다음 표시는 순서대로 적합된 모델 간의 차이를 보여주는 ANOVA 표입니다. 비교되는 적합된 모델은 일반적으로 계층적 순서일 것입니다. 이것은 기본값과 다른 정보를 제공하지 않고, 이해하고 제어하기 쉽게 합니다.

@node 적합된 모델 업데이트, 일반화 선형 모델, 분산 분석 및 모델 비교, R에서의 통계 모델
@section 적합된 모델 업데이트
@cindex 적합된 모델 업데이트

@code{update()} 함수는 대부분 편의 기능으로, 이전에 적합된 것과 약간 다른 몇 가지 추가 또는 제거된 항목이 있는 모델을 적합할 수 있습니다. 형식은 다음과 같습니다.
@findex update

@example
> @var{new.model} <- update(@var{old.model}, @var{new.formula})
@end example

@var{new.formula}에서 기간, 즉 @samp{@code{.}}로만 구성된 특수한 이름을 사용하여 "이전 모델 공식의 해당 부분"을 나타낼 수 있습니다. 예를 들면,

@example
> fm05 <- lm(y ~ x1 + x2 + x3 + x4 + x5, data = production)
> fm6  <- update(fm05, . ~ . + x6)
> smf6 <- update(fm6, sqrt(.) ~ .)
@end example

@noindent
데이터 프레임 @code{production}에서 변수(무리지어)로 구성된 다변량 회귀분석을 적합시키고, 여섯 번째 회귀 변수를 포함하는 추가 모델을 적합시키고, 응답에 제곱근 변환을 적용한 모델의 변형을 적합시킵니다.

특히 원래 모델 적합 함수에 @code{data=} 인수가 지정된 경우, 이 정보는 적합된 모델 객체를 통해 @code{update()} 및 그 동료에게 전달됩니다.

@samp{.} 이름은 다른 맥락에서도 사용할 수 있지만, 의미는 약간 다릅니다. 예를 들면

@example
> fmfull <- lm(y ~ . , data = production)
@end example

@noindent
응답 변수가 @code{y}이고 회귀 변수가 @emph{데이터 프레임 @code{production}의 모든 다른 변수인} 모델을 적합시킵니다.

모델의 점진적인 시퀀스를 탐색하기 위한 다른 함수로는 @code{add1()}, @code{drop1()} 및 @code{step()}가 있습니다.
@findex add1
@findex drop1
@findex step
이들의 이름은 그 목적에 대한 좋은 단서를 제공하지만, 자세한 내용은 온라인 도움말을 참조하십시오.

@node 일반화 선형 모델, 비선형 최소 제곱 및 최대 우도 모델, 적합된 모델 업데이트, R에서의 통계 모델
@section 일반화 선형 모델
@cindex 일반화 선형 모델

일반화 선형 모델링은 선형 모델을 발전시켜 비정규 응답 분포와 선형성 변환을 깔끔하고 직접적인 방법으로 수용합니다. 일반화 선형 모델은 다음 가정 순서에 따라 설명될 수 있습니다:

@itemize @bullet
@item
관심 있는 응답 @math{y}와 자극 변수가 있습니다.
@ifnottex
x_1, x_2, @dots{},
@end ifnottex
@tex
$x_1$, $x_2$, @dots{},
@end tex
이 값들은 응답의 분포에 영향을 줍니다.

@item
자극 변수는 @emph{단일 선형 함수를 통해서만} @math{y}의 분포에 영향을 줍니다. 이 선형 함수를 @emph{선형 예측 변수}라고 하며, 일반적으로 다음과 같이 쓰입니다.
@ifnottex
@display
eta = beta_1 x_1 + beta_2 x_2 + @dots{} + beta_p x_p,
@end display
따라서 x_i는 beta_i가 0일 때만 @math{y}의 분포에 영향을 주지 않습니다.
@end ifnottex
@tex
$$ \eta = \beta_1 x_1 + \beta_2 x_2 + \cdots + \beta_p x_p, $$
따라서 $x_i$는 $\beta_i=0$일 때만 @math{y}의 분포에 영향을 주지 않습니다.
@end tex

@item
@math{y}의 분포는 다음과 같은 형태입니다.
@ifnottex
@display
f_Y(y; mu, phi)
  = exp((A/phi) * (y lambda(mu) - gamma(lambda(mu))) + tau(y, phi))
@end display
여기서 phi는 @emph{스케일 매개변수}(아마 알려진 값일 수 있음)이며 모든 관측값에 대해 일정하고, @math{A}는 사전 가중치를 나타내며 알려진 값이지만 관측값에 따라 다를 수 있습니다. $\mu$는 @math{y}의 평균입니다.
@math{y}.
@end ifnottex
@tex
$$
f_Y(y;\mu,\varphi)
= \exp\left[{A \over \varphi}\left\{y\lambda(\mu) -
\gamma\left(\lambda(\mu)\right)\right\} + \tau(y,\varphi)\right]
$$
여기서 $\varphi$는 @emph{스케일 매개변수}(알려진 경우도 있음)로 모든 관측치에 대해 일정하며, $A$는 관측치에 따라 변할 수 있는 알려진 사전 가중치를 나타내고, $\mu$는 $y$의 평균입니다.
@end tex
따라서 @math{y}의 분포가 평균과 스케일 매개변수에 의해 결정된다고 가정합니다.

@item
@ifnottex
평균, mu,는 선형 예측 변수의 부드러운 가역 함수입니다:
@display
mu = m(eta),    eta = m^@{-1@}(mu) = ell(mu)
@end display
이 역함수, ell(),은 @emph{링크 함수}라고 불립니다.
@end ifnottex
@tex
평균, $\mu$,는 선형 예측 변수의 부드러운 가역 함수입니다:
$$ \mu = m(\eta),\qquad \eta = m^{-1}(\mu) = \ell(\mu) $$
이 역함수, $\ell()$,은 @emph{링크 함수}라고 불립니다.
@end tex

@end itemize

이러한 가정은 통계적 실무에 유용한 광범위한 모델 클래스를 포함할 수 있을 정도로 느슨하지만, 적어도 근사적으로 추정 및 추론의 통합된 방법론 개발을 가능하게 할 정도로 타이트합니다. 독자는 이 주제에 대한 최신 참고 자료를 참고하십시오. 예를 들어 McCullagh & Nelder (1989) 또는 Dobson (1990) 등입니다.

@menu
* 가족::                    
* glm() 함수::          
@end menu

@node 가족, glm() 함수, 일반화 선형 모델, 일반화 선형 모델
@subsection 가족
@cindex 가족

@R{}에서 제공하는 일반화 선형 모델의 클래스에는 @emph{가우시안}, @emph{이항}, @emph{포아송}, @emph{역 가우시안} 및 @emph{감마} 반응 분포와 함께 반응 분포가 명시적으로 지정되지 않은 @emph{준우도} 모델이 포함됩니다. 후자의 경우 @emph{분산 함수}는 평균의 함수로 지정되어야 하지만, 다른 경우에는 이 함수가 반응 분포에 의해 함축됩니다.

각 반응 분포는 평균과 선형 예측 변수를 연결하는 다양한 링크 함수를 허용합니다. 자동으로 사용할 수 있는 링크 함수는 다음 표에 나와 있습니다:

@quotation
@multitable @columnfractions 0.25 0.55
@headitem 가족 이름 @tab 링크 함수
@item @code{binomial} @tab @code{logit}, @code{probit}, @code{log}, @code{cloglog}
@item @code{gaussian} @tab @code{identity}, @code{log}, @code{inverse}
@item @code{Gamma} @tab @code{identity}, @code{inverse}, @code{log}
@item @code{inverse.gaussian} @tab @code{1/mu^2}, @code{identity}, @code{inverse}, @code{log}
@item @code{poisson} @tab @code{identity}, @code{log}, @code{sqrt}
@item @code{quasi} @tab @code{logit}, @code{probit}, @code{cloglog},
@code{identity}, @code{inverse}, @code{log}, @code{1/mu^2}, @code{sqrt}
@end multitable
@end quotation

응답 분포, 링크 함수 및 모델링 작업을 수행하는 데 필요한 다양한 기타 정보의 조합을 일반화 선형 모델의 @emph{가족}이라고 합니다.

@node glm() 함수,  , 가족, 일반화 선형 모델
@subsection @code{glm()} 함수
@findex glm

응답의 분포가 자극 변수에 따라 @emph{단지} 하나의 선형 함수를 통해 의존하기 때문에, 선형 모델에 사용된 것과 동일한 메커니즘이 일반화된 모델의 선형 부분을 지정하는 데 사용될 수 있습니다. 가족은 다른 방식으로 지정해야 합니다.

일반화 선형 모델을 맞추기 위한 @R{} 함수는 @code{glm()}이며, 다음과 같은 형식을 사용합니다.

@example
> @var{fitted.model} <- glm(@var{formula}, family=@var{family.generator}, data=@var{data.frame})
@end example

유일한 새로운 특징은 @var{family.generator}로, 가족이 설명되는 수단입니다. 이것은 모델과 추정 과정을 정의하고 제어하는 함수와 표현식의 목록을 생성하는 함수의 이름입니다. 처음에는 조금 복잡해 보일 수 있지만, 사용법은 꽤 간단합니다.

표준 공급 가족 생성기의 이름은 @ref{가족}의 표에서 "가족 이름"에 나와 있습니다. 링크 선택이 있는 경우, 가족 이름과 함께 괄호 안에 매개변수로 링크 이름도 제공될 수 있습니다. @code{quasi} 가족의 경우, 이 방법으로 분산 함수도 지정할 수 있습니다.

일부 예제를 통해 과정을 명확하게 설명합니다.

@subsubheading @code{gaussian} 가족

다음과 같은 호출은

@example
> fm <- glm(y ~ x1 + x2, family = gaussian, data = sales)
@end example

@noindent
아래와 동일한 결과를 얻지만 효율이 훨씬 떨어집니다.

@example
> fm <- lm(y ~ x1+x2, data=sales)
@end example

@noindent
가우시안 가족은 자동으로 링크 선택이 제공되지 않으므로 매개변수를 허용하지 않습니다. 문제가 비표준 링크를 가진 가우시안 가족을 필요로 하는 경우, 이것은 대부분 @code{quasi} 가족을 통해 나중에 볼 수 있듯이 달성할 수 있습니다.

@subsubheading @code{binomial} 가족

Silvey (1970)에서 작은 인공 예제를 고려해봅시다.

에게해의 Kalythos 섬에서 남성 주민들은 선천적인 안질환을 앓고 있으며, 이 질환의 영향은 나이가 들수록 더욱 두드러집니다. 다양한 연령대의 섬 주민 남성들을 시험하여 실명 여부를 기록하였습니다. 아래에 데이터가 나와 있습니다:

@iftex
@quotation
@multitable {No.@: tested::} {50} {50} {50} {50} {50}
@item 나이:          @tab  20 @tab  35 @tab  45 @tab  55 @tab  70
@item 검사 인원: @tab  50 @tab  50 @tab  50 @tab  50 @tab  50
@item 실명 인원:  @tab  @w{ 6} @tab  17 @tab  26 @tab  37 @tab  44
@end multitable
@end quotation
@end iftex
@ifnottex
@multitable {No.@: tested::} {50} {50} {50} {50} {50}
@item 나이:          @tab  20 @tab  35 @tab  45 @tab  55 @tab  70
@item 검사 인원: @tab  50 @tab  50 @tab  50 @tab  50 @tab  50
@item 실명 인원:  @tab  @w{ 6} @tab  17 @tab  26 @tab  37 @tab  44
@end multitable
@end ifnottex

고려하는 문제는 이 데이터에 로지스틱과 프로빗 모델을 모두 적합시키고, 각 모델의 LD50, 즉 남성 주민의 실명 확률이 50%인 나이를 추정하는 것입니다.

@math{y}가 나이 @math{x}에서의 실명 인원 수이고 @math{n}이 검사한 인원 수일 때, 두 모델 모두 다음 형식을 가집니다.
@ifnottex
y ~ B(n, F(beta_0 + beta_1 x))
@end ifnottex
@tex
$$ y \sim {\rm B}(n, F(\beta_0 + \beta_1 x)) $$
@end tex
여기서 프로빗 경우,
@eqn{F(z) = \Phi(z), F(z) = Phi(z)}
는 표준 정규 분포 함수이고, 로짓 경우(기본값),
@eqn{F(z) = e^z/(1+e^z),F(z) = e^z/(1+e^z)}.
두 경우 모두 LD50은
@ifnottex
LD50 = - beta_0/beta_1
@end ifnottex
@tex
$$ \hbox{LD50} = -\beta_0/\beta_1 $$
@end tex
즉, 분포 함수의 인수가 0인 지점입니다.

첫 번째 단계는 데이터를 데이터 프레임으로 설정하는 것입니다.

@example
> kalythos <- data.frame(x = c(20,35,45,55,70), n = rep(50,5),
y = c(6,17,26,37,44))
@end example

@code{glm()}을 사용하여 이항 모델을 적합시키려면 응답에 대해 세 가지 가능성이 있습니다.

@itemize @bullet
@item
응답이 @emph{벡터}인 경우 @emph{이진} 데이터로 가정하며, 따라서 @math{0/1} 벡터여야 합니다.

@item
응답이 @emph{두 열 행렬}인 경우 첫 번째 열이 시행의 성공 횟수를, 두 번째 열이 실패 횟수를 저장한다고 가정합니다.

@item
응답이 @emph{요인}인 경우 첫 번째 수준이 실패(0)로 간주되고 다른 모든 수준이 '성공'(1)으로 간주됩니다.
@end itemize

여기서는 이러한 관례 중 두 번째가 필요하므로 데이터 프레임에 행렬을 추가합니다.

@example
> kalythos$Ymat <- cbind(kalythos$y, kalythos$n - kalythos$y)
@end example

모델을 적합시키기 위해 다음을 사용합니다.

@example
> fmp <- glm(Ymat ~ x, family = binomial(link=probit), data = kalythos)
> fml <- glm(Ymat ~ x, family = binomial, data = kalythos)
@end example

로짓 링크가 기본값이므로 두 번째 호출에서 매개변수를 생략할 수 있습니다. 각 적합 결과를 보려면 다음을 사용할 수 있습니다.

@example
> summary(fmp)
> summary(fml)
@end example

두 모델 모두 (너무나도) 잘 적합됩니다. LD50 추정치를 찾으려면 간단한 함수를 사용할 수 있습니다.

@example
> ld50 <- function(b) -b[1]/b[2]
> ldp <- ld50(coef(fmp)); ldl <- ld50(coef(fml)); c(ldp, ldl)
@end example

이 데이터로부터 실제 추정치는 각각 43.663년과 43.601년입니다.

@subsubheading 포아송 모델

포아송 가족에서 기본 링크는 @code{log}이며, 이 가족의 주요 사용처는 실제 분포가 종종 다항 분포인 빈도 데이터에 대한 대체 포아송 로그 선형 모델을 적합하는 것입니다. 이것은 여기서 더 이상 논의하지 않을 큰 그리고 중요한 주제입니다. 실제로 비가우시안 일반화 모델 전체의 주요 사용 부분을 차지하고 있습니다.

가끔 포아송 데이터가 실제로 발생하고 과거에는 로그 또는 제곱근 변환 후 가우시안 데이터로 분석되곤 했습니다. 후자에 대한 우아한 대안으로, 다음 예제와 같이 포아송 일반화 선형 모델을 적합할 수 있습니다.

@example

fmod <- glm(y ~ A + B + x, family = poisson(link=sqrt),
data = worm.counts)
@end example

@subsubheading 준우도 모델

모든 가족에 대해 응답의 분산은 평균에 따라 달라지며 스케일 매개변수가 곱수로 작용합니다. 분산이 평균에 따라 어떻게 달라지는지는 응답 분포의 특성입니다. 예를 들어, 포아송 분포의 경우 @eqn{\hbox{Var}[y] = \mu,Var(y) = mu}입니다.

준우도 추정 및 추론에서는 정확한 응답 분포가 지정되지 않고, 대신 링크 함수와 평균에 따른 분산 함수의 형태만 지정됩니다. 준우도 추정은 가우시안 분포에 대한 기법과 형식적으로 동일한 기법을 사용하므로, 이 가족은 비표준 링크 함수 또는 분산 함수가 있는 가우시안 모델을 적합하는 방법을 제공합니다.

예를 들어, 다음과 같은 비선형 회귀를 적합해 보겠습니다.
@ifnottex
y = theta_1 z_1 / (z_2 - theta_2) + e
@end ifnottex
@tex
$$ y = {\theta_1z_1 \over z_2 - \theta_2} + e $$
@end tex
이는 다음과 같이 다르게 작성할 수 있습니다.
@ifnottex
y = 1 / (beta_1 x_1 + beta_2 x_2) + e
@end ifnottex
@tex
$$ y = {1 \over \beta_1x_1 + \beta_2x_2} + e $$
@end tex
where
@ifnottex
x_1 = z_2/z_1, x_2 = -1/z_1, beta_1 = 1/theta_1, and beta_2 =
theta_2/theta_1.
@end ifnottex
@tex
$x_1 = z_2/z_1$, $x_2=-1/z_1$, $\beta_1=1/\theta_1$ and
$\beta_2=\theta_2/\theta_1$.
@end tex
절한 데이터 프레임이 설정되었다고 가정하면, 이 비선형 회귀를 다음과 같이 적합시킬 수 있습니다.

@example
> nlfit <- glm(y ~ x1 + x2 - 1,
               family = quasi(link=inverse, variance=constant),
               data = biochem)
@end example

필요한 경우 독자는 매뉴얼과 도움말 문서를 참조하시기 바랍니다.

@node 비선형 최소 제곱 및 최대 우도 모델, 일부 비-표준 모델, 일반화 선형 모델, R에서의 통계 모델
@section 비선형 최소 제곱 및 최대 우도 모델
@cindex 비선형 최소 제곱

비선형 모델의 특정 형태는 일반화 선형 모델(@code{glm()})로 적합할 수 있습니다. 그러나 대부분의 경우 비선형 곡선 적합 문제를 비선형 최적화 문제로 접근해야 합니다. @R{}의 비선형 최적화 루틴은 @code{optim()}, @code{nlm()} 및 @code{nlminb()}입니다.
@findex nlm
@findex optim
@findex nlminb
@c which provide the functionality (and more) of @SPLUS{}'s @code{ms()} and
@c @code{nlminb()}.
우리는 적합성 부족의 어떤 지수를 최소화하는 매개변수 값을 찾고자 합니다. 이것들은 반복적으로 다양한 매개변수 값을 시도함으로써 이를 수행합니다. 예를 들어 선형 회귀와 달리 절차가 만족스러운 추정치에 수렴할 것이라는 보장이 없습니다. 모든 방법들은 시도할 매개변수 값에 대한 초기 추측이 필요하며, 수렴은 시작 값의 품질에 대해 결정적으로 의존할 수 있습니다.

@menu
* 최소 제곱::               
* 최대 우도::          
@end menu

@node 최소 제곱, 최대 우도, 비선형 최소 제곱 및 최대 우도 모델, 비선형 최소 제곱 및 최대 우도 모델
@subsection 최소 제곱

비선형 모델을 적합시키는 한 가지 방법은 제곱된 오차(SSE) 또는 잔차의 합을 최소화하는 것입니다. 이 방법은 관측된 오차가 정규 분포에서 발생할 수 있다고 타당하게 생각되는 경우에 의미가 있습니다.

다음은 Bates & Watts (1988), 51페이지의 예제입니다. 데이터는 다음과 같습니다.

@example
> x <- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56,
         1.10, 1.10)
> y <- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)
@end example

최소화할 적합 기준은 다음과 같습니다.

@example
> fn <- function(p) sum((y - (p[1] * x)/(p[2] + x))^2)
@end example

적합을 위해 매개변수의 초기 추정치가 필요합니다. 데이터를 그래프로 그리고 매개변수 값을 추측한 다음 해당 값으로 모델 곡선을 겹쳐 그리는 것이 좋습니다.

@example
> plot(x, y)
> xfit <- seq(.02, 1.1, .05)
> yfit <- 200 * xfit/(0.1 + xfit)
> lines(spline(xfit, yfit))
@end example

더 나은 결과를 얻을 수 있지만, 200과 0.1의 시작 값은 적절해 보입니다. 이제 적합을 수행합니다.

@example
> out <- nlm(fn, p = c(200, 0.1), hessian = TRUE)
@end example
@findex nlm

Aft적합 후, @code{out$minimum}은 SSE이고, @code{out$estimate}는 매개변수의 최소 제곱 추정치입니다.
추정치의 근사 표준 오차(SE)를 구하려면 다음을 수행합니다.

@example
> sqrt(diag(2*out$minimum/(length(y) - 2) * solve(out$hessian)))
@end example

위 코드에서 빼는 @code{2}는 매개변수의 수를 나타냅니다. 95% 신뢰 구간은 매개변수 추정치에 @eqn{\pm, +/-} 1.96 SE를 더하거나 뺀 값입니다. 새 그래프에 최소 제곱 적합을 겹쳐 그릴 수 있습니다.

@example
> plot(x, y)
> xfit <- seq(.02, 1.1, .05)
> yfit <- 212.68384222 * xfit/(0.06412146 + xfit)
> lines(spline(xfit, yfit))
@end example

표준 패키지 @pkg{stats}는 최소 제곱에 의한 비선형 모델 적합을 위한 훨씬 더 광범위한 기능을 제공합니다. 우리가 방금 적합한 모델은 Michaelis-Menten 모델이므로 다음을 사용할 수 있습니다.

@example
> df <- data.frame(x=x, y=y)
> fit <- nls(y ~ SSmicmen(x, Vm, K), df)
> fit
Nonlinear regression model
  model:  y ~ SSmicmen(x, Vm, K)
   data:  df
          Vm            K
212.68370711   0.06412123
 residual sum-of-squares:  1195.449
> summary(fit)

Formula: y ~ SSmicmen(x, Vm, K)

Parameters:
    Estimate Std. Error t value Pr(>|t|)
Vm 2.127e+02  6.947e+00  30.615 3.24e-11
K  6.412e-02  8.281e-03   7.743 1.57e-05

Residual standard error: 10.93 on 10 degrees of freedom

Correlation of Parameter Estimates:
      Vm
K 0.7651
@end example

@node 최대 우도,  , 최소 제곱, 비선형 최소 제곱 및 최대 우도 모델
@subsection 최대 우도
@cindex 최대 우도

최대 우도는 오차가 정규분포가 아닌 경우에도 적용되는 비선형 모델 적합 방법입니다. 이 방법은 로그 우도를 최대화하거나 동등하게 음의 로그 우도를 최소화하는 매개변수 값을 찾습니다. 다음은 Dobson (1990), pp.@: 108-111에서 가져온 예입니다. 이 예제는 용량-반응 데이터에 로지스틱 모델을 적합시키며, 분명히 @code{glm()}을 사용하여 적합할 수 있습니다. 데이터는 다음과 같습니다.

@example
> x <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113,
         1.8369, 1.8610, 1.8839)
> y <- c( 6, 13, 18, 28, 52, 53, 61, 60)
> n <- c(59, 60, 62, 56, 63, 59, 62, 60)
@end example

최소화할 음의 로그 우도는:

@example
> fn <- function(p)
   sum( - (y*(p[1]+p[2]*x) - n*log(1+exp(p[1]+p[2]*x))
           + log(choose(n, y)) ))
@end example

@noindent
합리적인 시작 값들을 선택하고 적합을 진행합니다:

@example
> out <- nlm(fn, p = c(-50,20), hessian = TRUE)
@end example
@findex nlm

@noindent
A적합 후에, @code{out$minimum}은 음의 로그 우도이고, @code{out$estimate}은 매개변수의 최대 우도 추정값입니다. 추정값의 근사적인 표준 오차를 구하기 위해 다음을 수행합니다:

@example
> sqrt(diag(solve(out$hessian)))
@end example

95% 신뢰 구간은 매개변수 추정값 @eqn{\pm, +/-} 1.96 표준 오차입니다.

@node 일부 비-표준 모델,  , 비선형 최소 제곱 및 최대 우도 모델, R에서의 통계 모델
@section 일부 비-표준 모델

이 장을 특수 회귀 및 데이터 분석 문제에 대한 @R{}에서 사용 가능한 다른 기능들에 대한 간단한 언급으로 마칩니다.

@itemize @bullet
@item
@cindex 혼합 모델
@strong{혼합 모델.} 권장되는 @CRANpkg{nlme} 패키지는 선형 및 비선형 혼합효과 모델에 대한 함수 @code{lme()}와 @code{nlme()}를 제공합니다.
@findex lme
@findex nlme
즉, 일부 계수가 무작위 효과에 대응하는 선형 및 비선형 회귀입니다. 이러한 함수는 모델을 지정하기 위해 공식을 많이 사용합니다.

@item
@cindex 지역 근사 회귀
@strong{지역 근사 회귀.} @code{loess()}
@findex loess
함수는 지역 가중 회귀를 사용하여 비모수 회귀를 적합합니다. 이러한 회귀는 지저분한 데이터에서 추세를 강조하거나 큰 데이터 집합에 대한 통찰력을 제공하기 위한 데이터 축소에 유용합니다.

함수 @code{loess}는 표준 패키지 @pkg{stats}에 있으며, 그곳에서 projection pursuit regression 코드와 함께 제공됩니다.
@findex loess

@item
@cindex 견고한 회귀
@strong{견고한 회귀.} 데이터에서 극단적인 이상치의 영향을 견디는 방식으로 회귀 모델을 적합하기 위해 사용할 수 있는 몇 가지 함수가 있습니다. 권장되는 패키지 @CRANpkg{MASS}의 함수 @code{lqs}
@findex lqs
는 매우 저항력 있는 적합을 위한 최첨단 알고리즘을 제공합니다. 저항력이 덜하지만 통계적으로 더 효율적인 방법은 패키지에서 사용할 수 있으며, 예를 들어 패키지 @CRANpkg{MASS}의 함수 @code{rlm}이 있습니다.
@findex rlm

@item
@cindex 가산 모델
@strong{가산 모델.} 이 기법은 결정 변수의 부드러운 가산 함수(보통 각 결정 변수마다 하나씩)로부터 회귀 함수를 구성하는 것을 목표로 합니다. 패키지 @CRANpkg{acepack}의 함수 @code{avas}와 @code{ace}와
@findex avas
@findex ace
패키지 @CRANpkg{mda}의 함수 @code{bruto}와 @code{mars}에서
@findex bruto
@findex mars
@R{}의 사용자 기여 패키지에서 이러한 기법의 몇 가지 예를 확인할 수 있습니다. 확장된 개념인 @strong{일반화 가산 모델}은 사용자 기여 패키지 @CRANpkg{gam}과 @CRANpkg{mgcv}에서 구현되어 있습니다.

@item
@cindex 트리 기반 모델
@strong{트리 기반 모델.} 예측이나 해석을 위한 명시적인 전역 선형 모델을 찾는 대신 트리 기반 모델은 데이터를 결정 변수의 중요한 포인트에서 순환적으로 이분화하여 가능한 한 균질하게 그룹으로 데이터를 나눕니다. 결과는 다른 데이터 분석 방법이 산출하지 못하는 통찰력을 제공합니다.

모델은 다시 일반 선형 모델 형식으로 지정됩니다. 모델 적합 함수는 @code{tree()}입니다.
@findex tree
그러나 @code{plot()} 및 @code{text()}와 같은 많은 다른 일반 함수들은 그래픽 방식으로 트리 기반 모델 적합 결과를 표시하는 데 잘 적응되어 있습니다.

트리 모델은 사용자 기여 패키지 @CRANpkg{rpart} 및 @CRANpkg{tree}를 통해 @R{}에서 사용할 수 있습니다.

@end itemize

@node 그래픽스, 패키지, R에서의 통계 모델, 상위
@chapter 그래픽 프로시저

그래픽 기능은 @R{} 환경의 중요하고 매우 다양한 구성 요소입니다. 그래픽 기능을 사용하여 다양한 통계 그래프를 표시할 수 있으며, 완전히 새로운 유형의 그래프를 작성할 수도 있습니다.

그래픽 기능은 대화형 및 일괄 처리 모드에서 모두 사용할 수 있지만, 대부분의 경우 대화형 사용이 더 생산적입니다. 대화형 사용은 시작 시 @R{}이 그래픽 @emph{디바이스 드라이버}를 초기화하여 대화형 그래픽을 표시하기 위한 특별한 @emph{그래픽 창}을 열기 때문에 쉽습니다. 이 작업은 자동으로 수행되지만, 사용된 명령어가 유닉스에서는 @code{X11()}, 윈도우에서는 @code{windows()}, macOS에서는 @code{quartz()}임을 알고 있으면 유용할 수 있습니다. 새로운 디바이스는 항상 @code{dev.new()}로 열 수 있습니다.

디바이스 드라이버가 실행되면 @R{} 플로팅 명령을 사용하여 다양한 그래픽 디스플레이를 생성하고 완전히 새로운 종류의 디스플레이를 생성할 수 있습니다.

플로팅 명령은 세 가지 기본 그룹으로 나뉩니다:

@itemize @bullet
@item
@strong{고수준} 플로팅 함수는 그래픽 장치에 새로운 플롯을 생성하며, 축, 레이블, 제목 등이 포함될 수 있습니다.
@item
@strong{저수준} 플로팅 함수는 기존 플롯에 추가 정보를 추가합니다. 예를 들면, 추가 점, 선 및 레이블 등입니다.
@item
@strong{대화형} 그래픽 함수는 마우스와 같은 포인팅 장치를 사용하여 기존 플롯에 대화식으로 정보를 추가하거나 정보를 추출할 수 있게 합니다.
@end itemize

또한, @R{}은 사용자 정의 플롯을 조작할 수 있는 @emph{그래픽 파라미터} 목록을 유지합니다.

이 매뉴얼에서는 '기본' 그래픽만 설명합니다. 패키지 @pkg{grid}에는 기본과 함께 사용되는 별도의 그래픽 하위 시스템이 있습니다. 이 시스템은 더 강력하지만 사용하기 어렵습니다. @pkg{grid}를 기반으로 한 @CRANpkg{lattice}라는 추천 패키지가 있으며, 이 패키지는 @Sl{}의 @emph{Trellis} 시스템과 유사한 멀티 패널 플롯을 생성하는 방법을 제공합니다.

@menu
* 고수준 그래프 명령어::
* 저수준 그래프 명령어::
* 그래픽과 상호작용하기::
* 그래픽 파라미터 사용하기::
* 그래픽 파라미터::
* 장치 드라이버::
* 동적 그래픽스::
@end menu
@node 고수준 그래프 명령어, 저수준 그래프 명령어, 그래픽스, 그래픽스
@section 고수준 그래프 명령어

고수준 플로팅 함수는 함수에 전달된 데이터의 완전한 플롯을 생성하도록 설계되었습니다. 필요한 경우, 축, 레이블 및 제목이 자동으로 생성됩니다(다른 것을 요청하지 않는 한). 고수준 그래프 명령어는 항상 새로운 플롯을 시작하며, 필요한 경우 현재 플롯을 지웁니다.

@menu
* plot() 함수::         
* 다변량 데이터 표시::  
* 그래픽 표시::            
* 고수준 그래프 함수에 대한 인자::  
@end menu

@node plot() 함수, 다변량 데이터 표시, 고수준 그래프 명령어, 고수준 그래프 명령어
@subsection @code{plot()} 함수
@findex plot

@R{}에서 가장 자주 사용되는 플로팅 함수 중 하나는 @code{plot()} 함수입니다. 이 함수는 @emph{일반} 함수로, 생성되는 플롯 유형은 첫 번째 인수의 유형 또는 @emph{클래스}에 따라 달라집니다.

@table @code

@item plot(@var{x}, @var{y})
@itemx plot(@var{xy})
@var{x}와 @var{y}가 벡터인 경우, @code{plot(@var{x}, @var{y})}는 @var{y}에 대한 @var{x}의 산점도를 생성합니다. 동일한 효과는 두 요소 @var{x}와 @var{y}를 포함하는 목록이나 두 열 행렬을 포함하는 하나의 인수(두 번째 형식)를 제공함으로써 생성할 수 있습니다.

@item plot(@var{x})
@var{x}가 시계열인 경우, 이 함수는 시계열 플롯을 생성합니다. @var{x}가 숫자 벡터인 경우, 벡터 내의 값에 대한 벡터 인덱스에 대한 플롯을 생성합니다. @var{x}가 복소수 벡터인 경우, 벡터 요소의 허수 부분에 대한 실수 부분의 플롯을 생성합니다.

@item plot(@var{f})
@itemx plot(@var{f}, @var{y})
@var{f}는 요인 객체이고, @var{y}는 숫자 벡터입니다. 첫 번째 형식은 @var{f}의 막대 그래프를 생성하고, 두 번째 형식은 @var{f}의 각 수준에 대한 @var{y}의 상자 그림을 생성합니다.

@item plot(@var{df})
@itemx plot(~ @var{expr})
@itemx plot(@var{y} ~ @var{expr})
@var{df}는 데이터 프레임이고, @var{y}는 임의의 객체이며, @var{expr}는 '@code{+}'로 구분된 객체 이름의 목록입니다(예: @code{a + b + c}). 첫 번째와 두 번째 형식은 데이터 프레임(첫 번째 형식)의 변수 또는 여러 개의 명명된 객체(두 번째 형식)의 분포 플롯을 생성합니다. 세 번째 형식은 @var{y}를 @var{expr}에 명시된 모든 객체에 대해 플롯합니다.
@end table

@node 다변량 데이터 표시, 그래픽 표시, plot() 함수, 고수준 그래프 명령어
@subsection 다변량 데이터 표시

@R{}은 다변량 데이터를 나타내는 데 매우 유용한 두 가지 함수를 제공합니다. @code{X}가 숫자 행렬이거나 데이터 프레임인 경우, 다음 명령을 사용합니다.

@example
> pairs(X)
@end example
@findex pairs

@noindent
@code{X}의 열에 의해 정의된 변수의 쌍별 산점도 행렬을 생성합니다. 즉, @code{X}의 모든 열이 @code{X}의 다른 모든 열과 플롯되며 결과적으로 얻어지는 @math{n(n-1)}개의 플롯은 행렬의 행과 열에 대해 일정한 플롯 스케일로 배열됩니다.

세 개 또는 네 개의 변수가 포함된 경우, @emph{coplot}이 더 설명력이 있을 수 있습니다. @code{a}와 @code{b}가 숫자 벡터이고 @code{c}가 숫자 벡터 또는 요인 객체일 때(모두 같은 길이), 다음 명령을 사용합니다.

@example
> coplot(a ~ b | c)
@end example
@findex coplot

@noindent
@code{c}의 주어진 값에 대해 @code{a}와 @code{b}의 산점도를 여러 개 생성합니다. @code{c}가 요인인 경우, 이는 간단히 @code{c}의 모든 수준에 대해 @code{a}가 @code{b}에 대해 플롯된다는 것을 의미합니다. @code{c}가 숫자일 때는 여러 개의 @emph{조건부 구간}으로 나누어지며 각 구간에 대해 구간 내의 @code{c} 값에 대해 @code{a}가 @code{b}에 대해 플롯됩니다. 구간의 수와 위치는 @code{coplot()}의 @code{given.values=} 인수를 사용하여 조절할 수 있습니다. @code{co.intervals()} 함수는 구간을 선택하는 데 유용합니다. 또한 다음과 같은 명령을 사용하여 두 개의 @emph{주어진} 변수를 사용할 수도 있습니다.

@example
> coplot(a ~ b | c + d)
@end example

@noindent
이렇게 하면 @code{c}와 @code{d}의 모든 공동 조건부 구간에 대해 @code{a}와 @code{b}의 산점도가 생성됩니다.

@code{coplot()} 및 @code{pairs()} 함수는 모두 인수 @code{panel=}을 사용하여 각 패널에 표시되는 플롯 유형을 사용자 지정할 수 있습니다. 기본값은 산점도를 생성하는 @code{points()}이지만 @code{panel=}의 값으로 두 벡터 @code{x}와 @code{y}의 다른 저수준 그래픽 함수를 제공함으로써 원하는 유형의 플롯을 생성할 수 있습니다. coplots에 유용한 예제 패널 함수는 @code{panel.smooth()}입니다.

@node 그래픽 표시, 고수준 그래프 함수에 대한 인자, 다변량 데이터 표시, 고수준 그래프 명령어
@subsection 그래픽 표시

다른 고수준 그래픽 함수는 다양한 종류의 플롯을 생성합니다. 예시로는:

@table @code
@item qqnorm(x)
@itemx qqline(x)
@itemx qqplot(x, y)
@findex qqnorm
@findex qqline
@findex qqplot
분포 비교 플롯. 첫 번째 형태는 숫자 벡터 @code{x}를 정규 순위 점수(정규 점수 플롯)에 대해 플롯하고 두 번째는 분포 및 데이터 사분위수를 통해 직선을 그리는 방식으로 플롯에 직선을 추가합니다. 세 번째 형태는 @code{x}의 분위수를 @code{y}의 분위수에 대해 플롯하여 각각의 분포를 비교합니다.

@item hist(x)
@itemx hist(x, nclass=@var{n})
@itemx hist(x, breaks=@var{b}, @dots{})
@findex hist
숫자 벡터 @code{x}의 히스토그램을 생성합니다. 일반적으로 합리적인 클래스 수가 선택되지만, @code{nclass=} 인수를 사용하여 추천할 수 있습니다. 또한 @code{breaks=} 인수로 구간을 정확하게 지정할 수 있습니다. @code{probability=TRUE} 인수가 주어지면 막대는 카운트 대신 구간 폭으로 나눈 상대 빈도를 나타냅니다.

@item dotchart(x, @dots{})
@findex dotchart
데이터 @code{x}의 도트 차트를 구성합니다. 도트 차트에서 @math{y}축은 @code{x}의 데이터 라벨링을 제공하고 @math{x}축은 해당 값을 제공합니다. 예를 들어 지정된 범위 내에서 값이 있는 모든 데이터 항목을 쉽게 시각적으로 선택할 수 있습니다.

@item image(x, y, z, @dots{})
@itemx contour(x, y, z, @dots{})
@itemx persp(x, y, z, @dots{})
@findex image
@findex contour
@findex persp
세 변수의 플롯입니다. @code{image} 플롯은 @code{z} 값을 나타내기 위해 다양한 색상을 사용하여 사각형 그리드를 그립니다. @code{contour} 플롯은 @code{z} 값을 나타내는 등고선을 그리고, @code{persp} 플롯은 3D 표면을 그립니다.
@end table

@node 고수준 그래프 함수에 대한 인자, , 그래픽 표시, 고수준 그래프 명령어
@subsection 고수준 그래프 함수에 대한 인자

고수준 그래픽 함수에 전달할 수 있는 몇 가지 인자가 있습니다.

@table @code
@item add=TRUE
이 함수를 저수준 그래픽 함수로 작동하게 하여 현재 그래프에 겹쳐 표시합니다(일부 함수에만 해당).

@item axes=FALSE
축 생성을 억제합니다. @code{axis()} 함수를 사용하여 사용자 정의 축을 추가하는 데 유용합니다. 기본값인 @code{axes=TRUE}는 축을 포함하라는 의미입니다.

@item log="x"
@itemx log="y"
@itemx log="xy"
@math{x}, @math{y} 또는 두 축 모두를 로그 축으로 만듭니다. 이는 많은 종류의 플롯에서 작동하지만 모든 플롯에서는 작동하지 않습니다.

@item type=
@code{type=} 인수는 생성되는 플롯 유형을 다음과 같이 제어합니다:

@table @code
@item type="p"
개별 점을 표시합니다(기본값)
@item type="l"
선을 표시합니다
@item type="b"
선으로 연결된 점을 표시합니다(@emph{둘 다})
@item type="o"
선을 겹쳐서 점을 표시합니다
@item type="h"
점에서 0축까지 수직선을 표시합니다(@emph{고밀도})
@item type="s"
@itemx type="S"
계단 함수 플롯입니다. 첫 번째 형식에서는 수직선의 상단이 점을 정의하고, 두 번째 형식에서는 하단이 정의합니다.
@item type="n"
아무것도 그리지 않습니다. 그러나 축은 여전히 기본적으로 그려지고 데이터에 따라 좌표계가 설정됩니다. 이후 저수준 그래픽 함수를 사용하여 그림을 생성하는 데 이상적입니다.
@end table

@item xlab=@var{string}
@itemx ylab=@var{string}
@math{x}축과 @math{y}축의 레이블입니다. 고수준 플로팅 함수 호출에 사용된 객체의 이름이 기본 레이블이므로 이 인수들을 사용하여 기본 레이블을 변경합니다.

@item main=@var{string}
그림 제목이 큰 글꼴로 플롯 상단에 위치합니다.

@item sub=@var{string}
부제목이 작은 글꼴로 @math{x}-축 바로 아래에 위치합니다.
@end table

@node 저수준 그래프 명령어, 그래픽과 상호작용하기, 고수준 그래프 명령어, 그래픽스
@section 저수준 그래프 명령어

때때로 고수준 그래프 함수가 원하는 종류의 그래프를 정확하게 생성하지 못할 수 있습니다. 이 경우, 저수준 그래프 명령어를 사용하여 현재 그래프에 추가 정보(점, 선 또는 텍스트 등)를 추가할 수 있습니다.

더 유용한 저수준 그래픽 함수 중 일부는 다음과 같습니다:

@table @code
@item points(x, y)
@itemx lines(x, y)
@findex points
@findex lines
현재 그래프에 점이나 연결된 선을 추가합니다. @code{plot()}의 @code{type=} 인수도 이러한 함수에 전달될 수 있습니다(기본값은 @code{points()}의 경우 @code{"p"}이고, @code{lines()}의 경우 @code{"l"}입니다.)

@item text(x, y, labels, @dots{})
@findex text
주어진 @code{x, y} 좌표에 해당하는 점에 그래프에 텍스트를 추가합니다. 보통 @code{labels}는 정수 또는 문자 벡터이며, 이 경우 @code{labels[i]}가 점 @code{(x[i], y[i])}에 표시됩니다. 기본값은 @code{1:length(x)}입니다.

@strong{참고}: 이 함수는 다음과 같은 순서로 자주 사용됩니다.

@example

plot(x, y, type="n"); text(x, y, names)
@end example

@noindent
그래픽 매개변수 @code{type="n"}은 점을 표시하지 않지만 축을 설정하고, @code{text()} 함수는 점에 대해 문자 벡터 @code{names}로 지정된 특수 문자를 제공합니다.

@item abline(a, b)
@itemx abline(h=@var{y})
@itemx abline(v=@var{x})
@itemx abline(@var{lm.obj})
@findex abline
현재 그래프에 기울기가 @code{b}이고 절편이 @code{a}인 선을 추가합니다. @code{h=@var{y}}를 사용하여 그래프를 가로질러 수평선의 높이에 대한 @math{y}-좌표를 지정할 수 있고, @code{v=@var{x}}를 사용하여 수직선에 대한 @math{x}-좌표를 비슷하게 지정할 수 있습니다. 또한 @var{lm.obj}는 길이가 2인 @code{coefficients} 컴포넌트를 가진 목록일 수 있으며(예: 모델 피팅 함수의 결과처럼), 이는 절편과 기울기 순서로 사용됩니다.

@item polygon(x, y, @dots{})
@findex polygon
(@code{x}, @code{y})에 정렬된 꼭지점으로 정의된 다각형을 그리고(선택적으로) 해치선으로 음영 처리하거나, 그래픽 장치가 도형을 채우는 것을 허용하는 경우 채웁니다.

@item legend(x, y, legend, @dots{})
@findex legend
지정된 위치에 현재 그래프에 범례를 추가합니다. 플로팅 문자, 선 스타일, 색상 등은 문자 벡터 @code{legend}의 레이블과 함께 표시됩니다. 적어도 하나의 다른 인수 @var{v}(플로팅 단위의 해당 값과 동일한 길이의 벡터)가 @code{legend}와 함께 주어져야 합니다. 다음과 같습니다:

@table @code
@item legend( , fill=@var{v})
색칠된 상자의 색상
@item legend( , col=@var{v})
점이나 선을 그릴 색상
@item legend( , lty=@var{v})
선 스타일
@item legend( , lwd=@var{v})
선 굵기
@item legend( , pch=@var{v})
플로팅 문자(문자 벡터)
@end table

@item title(main, sub)
@findex title
현재 그래프 상단에 큰 글꼴로 제목 @code{main}을 추가하고(선택 사항) 하단에 작은 글꼴로 부제목 @code{sub}을 추가합니다.

@item axis(side, @dots{})
@findex axis
첫 번째 인수(아래에서 시계 방향으로 1부터 4까지 세는 방향)에 따라 현재 그래프에 축을 추가합니다. 다른 인수는 그래프 내부 또는 그래프 옆에 축의 위치를 제어하고, 눈금 위치와 레이블을 설정합니다. @code{plot()}을 @code{axes=FALSE} 인수와 함께 호출한 후 사용자 지정 축을 추가하는 데 유용합니다.
@end table

저수준 플로팅 함수는 일반적으로 새로운 그래프 요소의 위치를 결정하기 위해 일부 위치 정보(예: @math{x} 및 @math{y} 좌표)가 필요합니다. 좌표는 제공된 데이터를 기반으로 선택된 이전 고수준 그래픽 명령에 의해 정의된 @emph{사용자 좌표}를 사용합니다.

@code{x} 및 @code{y} 인수가 필요한 경우, @code{x} 및 @code{y}라는 요소가 있는 리스트를 단일 인수로 제공하는 것으로 충분합니다. 마찬가지로 두 열을 가진 행렬도 유효한 입력입니다. 이 방법을 사용하면 @code{locator()}(아래 참조)와 같은 함수를 사용하여 그래프에 대한 위치를 상호 작용식으로 지정할 수 있습니다.

@menu
* 수학적 주석::     
* Hershey 벡터 글꼴::        
@end menu

@node 수학적 주석, Hershey 벡터 글꼴, 저수준 그래프 명령어, 저수준 그래프 명령어
@subsection 수학적 주석

일부 경우에는 그래프에 수학 기호와 공식을 추가하는 것이 유용합니다. 이는 @code{text}, @code{mtext}, @code{axis}, 또는 @code{title} 중 하나에서 문자열 대신 @emph{식}을 지정함으로써 @R{}에서 구현할 수 있습니다. 예를 들어, 다음 코드는 이항 확률 함수의 공식을 그립니다.

@example
> text(x, y, expression(paste(bgroup("(", atop(n, x), ")"), p^x, q^@{n-x@})))
@end example

자세한 정보 및 사용 가능한 기능의 전체 목록은 다음 @R{} 명령을 사용하여 얻을 수 있습니다.

@example
> help(plotmath)
> example(plotmath)
> demo(plotmath)
@end example

@node Hershey 벡터 글꼴,  , 수학적 주석, 저수준 그래프 명령어
@subsection Hershey 벡터 글꼴

@code{text} 및 @code{contour} 함수를 사용할 때 Hershey 벡터 폰트를 사용하여 텍스트를 렌더링할 수 있습니다. Hershey 폰트를 사용하는 세 가지 이유는 다음과 같습니다.
@itemize @bullet
@item
Hershey 폰트는 회전된 및/또는 작은 텍스트에 대해 특히 컴퓨터 화면에서 더 나은 출력을 제공할 수 있습니다.
@item
Hershey 폰트는 표준 폰트에 없을 수 있는 특정 기호를 제공합니다. 특히, 별자리 기호, 지도 기호 및 천문 기호가 있습니다.
@item
Hershey 폰트는 키릴 문자와 일본어(가나와 한자) 문자를 제공합니다.
@end itemize

Hershey 문자에 대한 표를 포함한 자세한 정보는 @R{} 내에서 다음 명령을 사용하여 얻을 수 있습니다.

@example
> help(Hershey)
> demo(Hershey)
> help(Japanese)
> demo(Japanese)
@end example

@node 그래픽과 상호작용하기, 그래픽 파라미터 사용하기, 저수준 그래프 명령어, 그래픽스
@section 그래픽과 상호작용하기

@R{}는 또한 사용자가 마우스를 사용하여 그래프에 정보를 추출하거나 추가할 수 있는 함수를 제공합니다. 가장 간단한 것은 @code{locator()} 함수입니다.

@table @code
@item locator(n, type)
@findex locator
사용자가 왼쪽 마우스 버튼을 사용하여 현재 그래프에서 위치를 선택할 때까지 기다립니다. 이 작업은 @code{n}(기본값 512) 포인트를 선택하거나 다른 마우스 버튼을 누를 때까지 계속됩니다. @code{type} 인수는 선택한 포인트에서 플로팅을 허용하며 고수준 그래픽 명령에 대해 동일한 효과를 가집니다. 기본값은 플로팅이 없습니다. @code{locator()}는 선택한 포인트의 위치를 @code{x}와 @code{y}라는 두 개의 구성 요소가 있는 목록으로 반환합니다.
@end table

@code{locator()}는 일반적으로 인수 없이 호출됩니다. 이는 레전드나 라벨과 같은 그래픽 요소의 위치를 상호 작용적으로 선택하는 데 특히 유용하며, 그래픽이 배치될 위치를 사전에 계산하기 어려울 때 사용됩니다. 예를 들어, 이상치 근처에 정보가 있는 텍스트를 배치하려면 다음 명령을 사용할 수 있습니다.

@example
> text(locator(1), "Outlier", adj=0)
@end example

@noindent
이 명령어는 유용할 수 있습니다. (@code{locator()}는 현재 장치가 대화식 포인팅을 지원하지 않는 경우, 예를 들어 @code{postscript}인 경우 무시됩니다.)

@table @code
@item identify(x, y, labels)
@findex identify
사용자가 @code{x} 및 @code{y}로 정의된 포인트 중 하나를 강조 표시할 수 있도록 하며(왼쪽 마우스 버튼 사용), 해당 @code{labels} 구성 요소를 인근에 표시하거나(또는 @code{labels}가 없는 경우 포인트의 인덱스 번호) 합니다. 다른 버튼이 눌렸을 때 선택한 포인트의 인덱스를 반환합니다.
@end table

가끔 그래프의 특정 @emph{포인트}를 식별하려는 경우가 있습니다. 예를 들어, 사용자가 그래픽 표시에서 관심 있는 관측값을 선택한 다음 그 관측값을 어떻게든 조작하길 원할 수 있습니다. @code{x}와 @code{y}라는 두 개의 숫자 벡터에서 많은 수의 @math{(x, y)} 좌표가 주어진 경우, 다음과 같이 @code{identify()} 함수를 사용할 수 있습니다.

@example
> plot(x, y)
> identify(x, y)
@end example

@code{identify()} 함수는 그래프 작업을 수행하지 않고 단순히 사용자가 마우스 포인터를 이동하고 포인트 근처에서 왼쪽 마우스 버튼을 클릭할 수 있게 합니다. 마우스 포인터 근처에 포인트가 있으면 해당 인덱스 번호(즉, @code{x}/@code{y} 벡터에서의 위치)가 인근에 표시됩니다. 대안으로 @code{identify()}의 @code{labels} 인수를 사용하여 강조 표시로 정보가 있는 문자열(예: 사례 이름)을 사용하거나 @code{plot = FALSE} 인수로 표시를 완전히 비활성화할 수 있습니다. 프로세스가 종료되면(위 참조), @code{identify()}는 선택한 포인트의 인덱스를 반환합니다. 이 인덱스를 사용하여 원래의 @code{x} 및 @code{y} 벡터에서 선택한 포인트를 추출할 수 있습니다.

@node 그래픽 파라미터 사용하기, 그래픽 파라미터, 그래픽과 상호작용하기, 그래픽스
@section 그래픽 파라미터 사용하기

그래픽을 생성할 때, 특히 발표나 출판 목적으로는 @R{}의 기본값이 항상 필요한 것을 정확히 생성하지는 않습니다. 그러나 @emph{그래픽 파라미터}를 사용하여 디스플레이의 거의 모든 측면을 사용자 정의할 수 있습니다. @R{}은 선 스타일, 색상, 도형 배열 및 텍스트 정렬과 같은 것들을 제어하는 많은 수의 그래픽 파라미터 목록을 유지합니다. 모든 그래픽 파라미터에는 이름(예: 색상을 제어하는 `@code{col}')과 값(예: 색상 번호)이 있습니다.

활성 장치별로 별도의 그래픽 파라미터 목록이 유지되며, 각 장치는 초기화될 때 기본 파라미터 세트가 있습니다. 그래픽 파라미터는 두 가지 방법으로 설정할 수 있습니다. 영구적으로 설정하여 현재 장치에 액세스하는 모든 그래픽 함수에 영향을 주거나, 일시적으로 설정하여 단일 그래픽 함수 호출에만 영향을 줍니다.

@menu
* par() 함수::          
* 그래픽 함수에 대한 인자::  
@end menu

@node par() 함수, 그래픽 함수에 대한 인자, 그래픽 파라미터 사용하기, 그래픽 파라미터 사용하기
@subsection Permanent changes: The @code{par()} function
@findex par
@cindex 그래픽 파라미터

@code{par()} 함수는 현재 그래픽 장치의 그래픽 파라미터 목록에 접근하고 수정하는 데 사용됩니다.

@table @code
@item par()
인수 없이 사용하면, 현재 장치의 모든 그래픽 파라미터와 그 값들을 리스트로 반환합니다.
@item par(c("col", "lty"))
문자 벡터 인수를 사용하면, 지정된 그래픽 파라미터만 반환합니다(다시 말해, 리스트로 반환합니다.)
@item par(col=4, lty=2)
명명된 인수(또는 단일 리스트 인수)를 사용하여 지정된 그래픽 파라미터의 값을 설정하고, 파라미터의 원래 값을 리스트로 반환합니다.
@end table

@code{par()} 함수로 그래픽 파라미터를 설정하면 파라미터의 값이 @emph{영구적으로} 변경됩니다. 이는 현재 장치에서 그래픽 함수를 호출할 때마다 새 값에 영향을 받게 됨을 의미합니다. 이렇게 그래픽 파라미터를 설정하는 것을 파라미터에 대한 "기본" 값으로 설정하고, 대체 값이 제공되지 않는 한 모든 그래픽 함수에 의해 사용됩니다.

@code{par()}를 함수 내에서 호출하더라도 @emph{항상} 그래픽 파라미터의 전역 값에 영향을 준다는 점에 유의하세요. 이는 종종 바람직하지 않은 동작입니다. 보통 우리는 그래픽 파라미터를 설정하고, 그래프를 그린 후, 사용자의 @R{} 세션에 영향을 주지 않도록 원래 값으로 복원하려고 합니다. 변경 사항을 적용할 때 @code{par()}의 결과를 저장하고, 그래프 작업이 완료되면 초기 값으로 복원함으로써 초기 값을 복원할 수 있습니다.

@example
> oldpar <- par(col=4, lty=2)
  @r{@dots{} 그리기 명령어 @dots{}}
> par(oldpar)
@end example

@noindent
@emph{모든} 설정 가능한@footnote{현재 장치의 크기와 같은 일부 그래픽
파라미터는 정보 제공용입니다.} 그래픽 파라미터를 저장하고 복원하려면 다음을 사용하십시오.

@example
> oldpar <- par(no.readonly=TRUE)
  @r{@dots{} 그리기 명령어 @dots{}}
> par(oldpar)
@end example

@node 그래픽 함수에 대한 인자, , par() 함수, 그래픽 파라미터 사용하기
@subsection 일시적 변경: 그래픽 함수에 대한 인자

그래픽 파라미터는 명명된 인수로써 (거의) 모든 그래픽 함수에 전달할 수도 있습니다. 이는 @code{par()} 함수에 인수를 전달하는 것과 동일한 효과를 가지지만, 변경 사항은 함수 호출 동안에만 유지됩니다. 예를 들면:

@example
> plot(x, y, pch="+")
@end example

@noindent
플러스 기호를 그리기 문자로 사용하여 산점도를 그립니다. 이렇게 하면 미래의 그림에 대한 기본 그리기 문자를 변경하지 않습니다.

불행하게도 이것은 완전히 일관성 있게 구현되지 않았으며 때때로 @code{par()}를 사용하여 그래픽 파라미터를 설정하고 재설정해야 할 필요가 있습니다.

@node 그래픽 파라미터, 장치 드라이버, 그래픽 파라미터 사용하기, 그래픽스
@section 그래픽 파라미터 목록

다음 섹션에서는 일반적으로 사용되는 그래픽 파라미터 중 많은 것들에 대한 자세한 설명을 제공합니다. @R{} 도움말 문서에서 @code{par()} 함수에 대한 더 간결한 요약을 제공합니다. 이것은 좀 더 자세한 대안으로 제공됩니다.

그래픽 파라미터는 다음과 같은 형식으로 제시됩니다:

@table @code
@item @var{name}=@var{value}
파라미터의 효과에 대한 설명입니다. @var{name}은 파라미터의 이름으로, @code{par()} 또는 그래픽 함수에서 사용하는 인수 이름입니다. @var{value}는 파라미터를 설정할 때 사용할 수 있는典型적인 값입니다.
@end table

@code{axes}는 @strong{그래픽 파라미터가 아니며}, 몇 가지 @code{plot} 메소드에 대한 인수입니다. @code{xaxt}와 @code{yaxt}를 참조하십시오.

@menu
* 그래픽 요소::          
* 축과 눈금::         
* 그림 여백::              
* 여러 그림 환경::  
@end menu

@node 그래픽 요소, 축과 눈금, 그래픽 파라미터, 그래픽 파라미터
@subsection 그래픽 요소

@R{} 그림은 점, 선, 텍스트, 다각형(채워진 영역)으로 구성됩니다. 이러한 @emph{그래픽 요소}를 그리는 방법을 제어하는 그래픽 파라미터가 존재합니다.

@table @code
@item pch="+"
플로팅 포인트에 사용할 문자입니다. 기본값은 그래픽 드라이버에 따라 다르지만, 대부분
@ifnottex
원입니다.
@end ifnottex
@tex
`$\circ$'.
@end tex
플로팅 문자로 @code{"."}를 사용하지 않는 경우, 플로팅된 점들이 적절한 위치보다 약간 위 또는 아래에 나타납니다. 이 문자를 사용하면 가운데 정렬된 점이 생성됩니다.

@item pch=4
@code{pch}가 0에서 25 사이의 정수로 주어지면 특수한 그리기 기호가 생성됩니다. 기호가 무엇인지 알아보려면 다음 명령을 사용하십시오.

@example
> legend(locator(1), as.character(0:25), pch = 0:25)
@end example

@noindent
21에서 25까지의 기호는 이전 기호와 중복되는 것처럼 보일 수 있지만, 다른 방식으로 색칠할 수 있습니다. @code{points}의 도움말과 예제를 참조하십시오.

또한, @code{pch}는 현재 글꼴의 문자를 나타내는 범위 @code{32:255} 내의 문자 또는 숫자가 될 수 있습니다.

@item lty=2
선 유형입니다. 대체 선 스타일은 모든 그래픽 장치에서 지원되지 않으며(지원하는 경우에도 다양함), 선 유형 1은 항상 실선이고, 선 유형 0은 항상 보이지 않으며, 선 유형 2 이상은 점선이나 파선 또는 둘 다의 조합입니다.

@item lwd=2
선 너비입니다. "표준" 선 너비의 배수로 선의 너비를 설정합니다. @code{lines()} 등으로 그린 선뿐만 아니라 축 선에도 영향을 줍니다. 모든 장치가 이 기능을 지원하지는 않으며, 사용할 수 있는 너비에 대한 제한이 있는 장치도 있습니다.

@item col=2
점, 선, 텍스트, 채워진 영역 및 이미지에 사용할 색상입니다. 현재 팔레트에서 숫자(참조 @code{?palette}) 또는 명명된 색상입니다.

@item col.axis
@itemx col.lab
@itemx col.main
@itemx col.sub
각각 축 주석, @math{x} 및 @math{y} 레이블, 메인 및 서브 제목에 사용할 색상입니다.

@item font=2
텍스트에 사용할 글꼴을 지정하는 정수입니다. 가능한 경우, 장치 드라이버는 @code{1}이 일반 텍스트, @code{2}가 굵은 글꼴, @code{3}이 이탤릭체, @code{4}가 굵은 이탤릭체, @code{5}가 기호 글꼴(그리스 문자 포함)에 해당하도록 배열합니다.

@item font.axis
@itemx font.lab
@itemx font.main
@itemx font.sub
각각 축 주석, @math{x} 및 @math{y} 레이블, 메인 및 서브 제목에 사용할 글꼴입니다.

@item adj=-0.1
그래픽 위치에 대한 텍스트 정렬입니다. @code{0}은 왼쪽 정렬을 의미하고, @code{1}은 오른쪽 정렬을 의미하며, @code{0.5}는 그래픽 위치를 기준으로 수평 가운데 정렬을 의미합니다. 실제 값은 그래픽 위치 왼쪽에 나타나는 텍스트 비율이므로, @code{-0.1} 값은 텍스트와 그래픽 위치 사이에 텍스트 너비의 10% 공백을 남깁니다.

@item cex=1.5
문자 확장입니다. 값은 기본 텍스트 크기에 대한 텍스트 문자(그리기 문자 포함)의 원하는 크기입니다.

@item cex.axis
@itemx cex.lab
@itemx cex.main
@itemx cex.sub
각각 축 주석, @math{x} 및 @math{y} 레이블, 메인 및 서브 제목에 사용할 문자 확장입니다.
@end table

@node 축과 눈금, 그림 여백, 그래픽 요소, 그래픽 파라미터
@subsection 축과 눈금

@R{}의 고수준 그림 중 많은 것들이 축을 가지고 있으며, 저수준 @code{axis()} 그래픽 함수로 직접 축을 만들 수 있습니다. 축에는 @emph{축 선}(선 스타일은 @code{lty} 그래픽 매개변수로 제어됨), @emph{눈금 표시}(축 선을 따라 단위 구분 표시) 및 @emph{눈금 레이블}(단위 표시)이라는 세 가지 주요 구성 요소가 있습니다. 이러한 구성 요소는 다음 그래픽 매개변수로 사용자 정의할 수 있습니다.

@table @code
@item lab=c(5, 7, 12)
첫 번째와 두 번째 숫자는 각각 @math{x} 축과 @math{y} 축에서 원하는 눈금 간격의 개수입니다. 세 번째 숫자는 문자(소수점 포함)로서 축 레이블의 원하는 길이입니다. 이 매개변수에 너무 작은 값을 선택하면 모든 눈금 레이블이 같은  숫자로 반올림될 수 있습니다!

@item las=1
축 레이블의 방향. @code{0}은 항상 축과 평행을 의미하고, @code{1}은 항상 수평을 의미하며, @code{2}는 항상 축에 수직을 의미합니다.

@item mgp=c(3, 1, 0)
축 구성요소의 위치입니다. 첫 번째 구성요소는 축 레이블과 축 위치 사이의 거리를 텍스트 줄 단위로 나타냅니다. 두 번째 구성요소는 눈금 레이블까지의 거리이고, 마지막 구성요소는 축 위치에서 축 선까지의 거리입니다(보통 0). 양수는 플롯 영역 외부에서 측정하고, 음수는 내부에서 측정합니다.

@item tck=0.01
눈금의 길이, 플로팅 영역 크기의 일부입니다. @code{tck}가 작을 때(0.5보다 작음) @math{x}와 @math{y} 축의 눈금 크기가 동일하게 강제됩니다. 값이 1이면 격자선이 생깁니다. 음수 값은 플로팅 영역 바깥에 눈금을 생성합니다. 내부 눈금에는 @code{tck=0.01}과 @code{mgp=c(1,-1.5,0)}를 사용하세요.

@item xaxs="r"
@itemx yaxs="i"
각각 @math{x} 및 @math{y} 축에 대한 축 스타일입니다. 스타일 @code{"i"} (내부) 및 @code{"r"} (기본값)은 눈금이 항상 데이터 범위 내에 있으며, 스타일 @code{"r"}은 가장자리에 약간의 여백을 남깁니다.
@c (@Sl{}은 @R{}에서 구현되지 않은 다른 스타일이 있습니다.)

@c 이 매개변수를 @code{"d"} (직접 축)로 설정하면 현재 축이 @emph{고정되어} 모든 향후 플롯에 사용됩니다(적어도 위의 다른 값 중 하나로 설정할 때까지). 고정 스케일 플롯 시리즈를 생성하는 데 유용합니다.
@end table

@node 그림 여백, 여러 그림 환경, 축과 눈금, 그래픽 파라미터
@subsection 그림 여백


@R{}에서 단일 플롯은 @code{figure}로 알려져 있으며, 여백(축 레이블, 제목 등이 포함될 수 있음)으로 둘러싸인 @emph{플롯 영역}과 (보통) 축 자체로 둘러싸인 영역으로 구성됩니다.

@ifnotinfo
전형적인 그림은 다음과 같습니다.

@image{images/fig11,7cm}
@end ifnotinfo

그림 레이아웃을 제어하는 그래픽 파라미터에는 다음이 포함됩니다.

@table @code
@item mai=c(1, 0.5, 0.5, 0)
각각 아래쪽, 왼쪽, 위쪽, 오른쪽 여백의 너비로 인치 단위로 측정됩니다.

@item mar=c(4, 2, 2, 1)
@code{mai}와 유사하지만, 측정 단위가 텍스트 줄입니다.
@end table

@code{mar}과 @code{mai}는 한 가지를 설정하면 다른 가지 값이 변경되는 의미에서 동등합니다. 이 매개변수에 대해 선택된 기본값은 대개 너무 큽니다. 오른쪽 여백은 거의 필요하지 않고, 제목이 사용되지 않는 경우 상단 여백도 필요하지 않습니다. 하단과 왼쪽 여백은 축과 눈금 레이블을 수용할 수 있을 만큼 커야 합니다. 또한, 기본값은 기기 표면 크기와 관계없이 선택됩니다. 예를 들어, @code{postscript()} 드라이버를 사용하여 @code{height=4} 인수와 함께 사용하면 @code{mar} 또는 @code{mai}가 명시적으로 설정되지 않으면 플롯이 약 50%의 여백을 갖게 됩니다. 여러 그림을 사용할 때(아래 참조) 여백이 줄어들지만, 많은 그림이 동일한 페이지를 공유할 때 충분하지 않을 수 있습니다.

@node 여러 그림 환경, , 그림 여백, 그래픽 파라미터
@subsection 여러 그림 환경

@R{}은 하나의 페이지에 @math{n} 행과 @math{m} 열의 그림 배열을 만들 수 있습니다. 각 그림은 자체 여백을 가지며, 그림 배열은 선택적으로 @emph{외부 여백}으로 둘러싸입니다. 다음 그림에서 보여지는 것처럼.

@ifnotinfo
@image{images/fig12,6cm}
@end ifnotinfo

여러 그림과 관련된 그래픽 파라미터는 다음과 같습니다:

@table @code
@item mfcol=c(3, 2)
@itemx mfrow=c(2, 4)
여러 그림 배열의 크기를 설정합니다. 첫 번째 값은 행의 개수이고, 두 번째 값은 열의 개수입니다. 이 두 파라미터의 유일한 차이점은 @code{mfcol}을 설정하면 그림이 열로 채워지고, @code{mfrow}은 행으로 채워진다는 것입니다.

그림의 레이아웃은 @code{mfrow=c(3,2)}를 설정하여 만들어졌을 수 있습니다. 그림은 네 개의 플롯이 그려진 후의 페이지를 보여줍니다.

이들 중 하나를 설정하면 기호와 텍스트의 기본 크기(@code{par("cex")} 및 기기의 포인트 크기로 제어됨)가 줄어들 수 있습니다. 정확히 두 개의 행과 열이 있는 레이아웃에서는 기본 크기가 0.83배로 줄어들고, 행이나 열 중 세 개 이상이 있는 경우 감소 비율은 0.66입니다.

@item mfg=c(2, 2, 3, 2)
여러 그림 환경에서 현재 그림의 위치입니다. 처음 두 숫자는 현재 그림의 행과 열이고, 마지막 두 숫자는 여러 그림 배열의 행과 열 수입니다. 이 매개변수를 설정하여 배열 내의 그림 사이를 이동할 수 있습니다. 같은 페이지에서 크기가 다른 그림을 위해 마지막 두 숫자에 @emph{참} 값과 다른 값을 사용할 수도 있습니다.

@item fig=c(4, 9, 1, 4)/10
페이지에서 현재 그림의 위치입니다. 값은 왼쪽, 오른쪽, 아래쪽, 위쪽 가장자리의 위치를 각각 페이지 하단 왼쪽 모서리에서의 백분율로 나타냅니다. 예제 값은 페이지 하단 오른쪽에 있는 그림에 대한 것입니다. 이 매개변수를 설정하여 페이지 내에서 임의로 그림을 배치하십시오. 현재 페이지에 그림을 추가하려면 @code{new=TRUE}를 사용하세요(S와는 달리).

@item oma=c(2, 0, 3, 0)
@itemx omi=c(0, 0, 0.8, 0)
외부 여백의 크기입니다. @code{mar}과 @code{mai}와 마찬가지로, 첫 번째는 텍스트 줄 단위로 측정하고 두 번째는 인치 단위로 측정하며, 하단 여백에서 시작하여 시계 방향으로 작동합니다.

@end table

외부 여백은 페이지별 제목 등에 특히 유용합니다. @code{mtext()} 함수를 사용하여 @code{outer=TRUE} 인수와 함께 외부 여백에 텍스트를 추가할 수 있습니다. 그러나 기본적으로 외부 여백이 없으므로 @code{oma} 또는 @code{omi}를 사용하여 명시적으로 생성해야 합니다.

외부 여백은 페이지별 제목 등에 특히 유용합니다. @code{mtext()} 함수를 사용하여 @code{outer=TRUE} 인수와 함께 외부 여백에 텍스트를 추가할 수 있습니다. 그러나 기본적으로 외부 여백이 없으므로 @code{oma} 또는 @code{omi}를 사용하여 명시적으로 생성해야 합니다.

더 복잡한 여러 그림의 배열은 @code{split.screen()} 및 @code{layout()} 함수뿐만 아니라 @pkg{grid} 및 @CRANpkg{lattice} 패키지를 사용하여 생성할 수 있습니다.

@node 장치 드라이버, 동적 그래픽스, 그래픽 파라미터, 그래픽스
@section 장치 드라이버
@cindex 그래픽 장치 드라이버

@R{}는 거의 모든 종류의 디스플레이 또는 인쇄 장치에서 다양한 수준의 그래픽을 생성할 수 있습니다. 그러나 이를 시작하기 전에 @R{}에 처리 중인 장치의 종류를 알려야 합니다. 이 작업은 @emph{장치 드라이버}를 시작하여 수행됩니다. 장치 드라이버의 목적은 @R{}에서의 그래픽 명령(예: "선 그리기")을 해당 장치가 이해할 수 있는 형태로 변환하는 것입니다.

장치 드라이버는 장치 드라이버 함수를 호출하여 시작합니다. 각 장치 드라이버에 대해 하나씩 있는 함수가 있습니다. 모든 목록을 보려면 @code{help(Devices)}를 입력하세요. 예를 들어, 다음 명령을 실행하면

@example
> postscript()
@end example

@noindent
앞으로의 모든 그래픽 출력이 PostScript 형식으로 프린터로 전송됩니다. 일반적으로 사용되는 몇 가지 장치 드라이버는 다음과 같습니다.

@table @code
@item X11()
@findex X11
유닉스 계열에서 X11 창 시스템과 함께 사용
@item windows()
@findex windows
Windows에서 사용
@item quartz()
@findex quartz
macOS에서 사용
@item postscript()
@findex postscript
PostScript 프린터에서 인쇄하거나 PostScript 그래픽 파일을 생성하는 데 사용합니다.
@item pdf()
@findex pdf
PDF 파일을 생성하며, PDF 파일에도 포함할 수 있습니다.
@item png()
@findex png
비트맵 PNG 파일을 생성합니다. (항상 사용할 수 없음: 도움말 페이지 참조)
@item jpeg()
@findex jpeg
비트맵 JPEG 파일을 생성하며, @code{image} 플롯에 가장 적합합니다.
(항상 사용할 수 없음: 도움말 페이지 참조)
@end table

장치를 사용한 후에는 반드시 다음 명령을 내려 장치 드라이버를 종료하십시오.

@example
> dev.off()
@end example

이렇게 하면 장치가 깔끔하게 종료됩니다. 예를 들어 하드 카피 장치의 경우 모든 페이지가 완료되어 프린터로 전송되었음을 확인합니다. (이 작업은 세션의 정상 종료시 자동으로 수행됩니다.)

@menu
* 조판 문서용 PostScript 도표::  
* 여러 그래픽 장치::   
@end menu

@node 조판 문서용 PostScript 도표, 여러 그래픽 장치, 장치 드라이버, 장치 드라이버
@subsection 조판 문서용 PostScript 도표

@code{postscript()} 장치 드라이버 함수에 @code{file} 인수를 전달함으로써, 선택한 파일에 PostScript 형식의 그래픽을 저장할 수 있습니다. @code{horizontal=FALSE} 인수가 주어지지 않으면 플롯은 가로 방향이 될 것이며, @code{width} 및 @code{height} 인수를 사용하여 그래픽의 크기를 제어할 수 있습니다(플롯은 이러한 차원에 맞게 적절하게 조정됩니다). 예를 들어, 다음 명령어는

@example

postscript("file.ps", horizontal=FALSE, height=5, pointsize=10)
@end example

@noindent
5인치 높이의 그림을 위한 PostScript 코드가 포함된 파일을 생성할 것입니다. 이를 문서에 포함시키기 위해 사용할 수 있습니다. 명령어에서 지정한 파일이 이미 존재하는 경우, 덮어쓰여질 것이라는 점에 유의해야 합니다. 이는 동일한 @R{} 세션에서 파일이 이전에 생성된 경우에도 마찬가지입니다.

PostScript 출력의 많은 사용법은 다른 문서에 그림을 포함시키는 것입니다. 이 작업은 @emph{캡슐화된} PostScript가 생성될 때 가장 잘 작동합니다. @R{}은 항상 준수한 출력을 생성하지만, @code{onefile=FALSE} 인수가 제공될 때만 출력을 그대로 표시합니다. 이 특이한 표기법은 @Sl{} 호환성에서 비롯되었습니다. 실제로 출력이 단일 페이지일 것임을 의미합니다(EPSF 사양의 일부입니다). 따라서 포함시킬 플롯을 생성하려면 다음과 같은 것을 사용하세요.

@example
> postscript("plot1.eps", horizontal=FALSE, onefile=FALSE,
             height=8, width=6, pointsize=10)
@end example


@node 여러 그래픽 장치,  , 조판 문서용 PostScript 도표, 장치 드라이버
@subsection 여러 그래픽 장치

@R{}의 고급 사용에서는 종종 동시에 여러 그래픽 장치를 사용하는 것이 유용합니다. 물론 한 번에 하나의 그래픽 장치만 그래픽 명령을 받을 수 있으며, 이를 @emph{현재 장치}라고 합니다. 여러 장치가 열려 있을 때, 각 위치에서 장치 종류를 나타내는 이름이 있는 번호가 매겨진 순서를 형성합니다.

여러 장치를 사용하여 작업하기 위한 주요 명령어와 그 의미는 다음과 같습니다:

@table @code
@item X11()
[UNIX]
@item windows()
@itemx win.printer()
@itemx win.metafile()
[Windows]
@item quartz()
[macOS]
@item postscript()
@itemx pdf()
@item png()
@item jpeg()
@item tiff()
@item bitmap()
@itemx @dots{}
장치 드라이버 함수에 대한 새로운 호출은 새로운 그래픽 장치를 열고, 장치 목록을 하나씩 확장합니다. 이 장치는 그래픽 출력이 전송되는 현재 장치가 됩니다.

@item dev.list()
@findex dev.list
모든 활성 장치의 번호와 이름을 반환합니다. 목록의 위치 1에 있는 장치는 항상 그래픽 명령을 전혀 받지 않는 @emph{null 장치}입니다.

@item dev.next()
@itemx dev.prev()
@findex dev.next
@findex dev.prev
각각 현재 장치 다음 또는 이전의 그래픽 장치의 번호와 이름을 반환합니다.

@item dev.set(which=@var{k})
@findex dev.set
장치 목록의 위치 @var{k}에 있는 장치로 현재 그래픽 장치를 변경하는 데 사용할 수 있습니다. 장치의 번호와 라벨을 반환합니다.

@item dev.off(@var{k})
@findex dev.off
장치 목록의 위치 @var{k}에 있는 그래픽 장치를 종료합니다. @code{postscript} 장치와 같은 일부 장치의 경우, 장치가 시작되는 방식에 따라 파일을 즉시 인쇄하거나 나중에 인쇄할 수 있도록 파일을 올바르게 완료합니다.

@item dev.copy(device, @dots{}, which=@var{k})
@itemx dev.print(device, @dots{}, which=@var{k})
장치 @var{k}의 복사본을 만듭니다. 여기서 @code{device}는 @code{postscript}와 같은 장치 함수이며, 필요한 경우 @samp{@dots{}}에 의해 추가 인수를 지정할 수 있습니다. @code{dev.print}는 유사하지만, 복사된 장치가 즉시 닫히므로 종료 작업(예: 하드 카피 인쇄)이 즉시 수행됩니다.

@item graphics.off()
null 장치를 제외한 목록의 모든 그래픽 장치를 종료합니다.
@end table

@node 동적 그래픽스,  , 장치 드라이버, 그래픽스
@section 동적 그래픽스
@cindex 동적 그래픽스

@R{}은 동적 또는 대화형 그래픽, 예를 들어 회전하는 포인트 클라우드 또는 "브러싱"(대화형으로 강조하는) 포인트에 대한 기본 기능을 갖추고 있지 않습니다. 그러나 Swayne, Cook 및 Buja가 개발한 시스템인 GGobi에서 광범위한 동적 그래픽 기능을 사용할 수 있습니다.

@quotation
@uref{http://ggobi.org/}
@end quotation

@noindent
또한 이 기능들은 @R{} 패키지 @CRANpkg{rggobi}를 통해 접근할 수 있으며, @uref{http://ggobi.org/rggobi.html}에서 설명되어 있습니다.

또한 패키지 @CRANpkg{rgl}은 3D 플롯, 예를 들어 표면과 상호 작용하는 방법을 제공합니다.

@node 패키지, 운영체제 기능, 그래픽스, 상위
@chapter 패키지
@cindex 패키지

모든 @R{} 함수와 데이터셋은 @emph{패키지}에 저장됩니다. 패키지가 로드될 때만 해당 내용을 사용할 수 있습니다. 이는 효율성(전체 목록은 메모리를 더 사용하고 검색 시간이 더 길어질 것이며, 부분 집합보다 큼)과 패키지 개발자를 지원하기 위함입니다. 패키지 개발자는 다른 코드와의 이름 충돌로부터 보호받습니다. 패키지 개발 과정은 @ref{Creating R packages, , Creating R packages, R-exts, Writing R Extensions}에서 설명됩니다. 여기서는 사용자의 관점에서 설명하겠습니다.

사이트에 설치된 패키지를 확인하려면 인수 없이 다음 명령어를 실행하세요.

@example
> library()
@end example

@noindent
특정 패키지(예: Davison & Hinkley (1997)의 함수가 포함된 @CRANpkg{boot} 패키지)를 로드하려면 다음과 같은 명령어를 사용하세요.

@example
> library(boot)
@end example

인터넷에 연결된 사용자는 @code{install.packages()} 및 @code{update.packages()} 함수(Windows 및 macOS GUI의 @code{패키지} 메뉴를 통해 사용 가능, @pxref{Installing
packages, , , R-admin, R Installation and Administration})를 사용하여 패키지를 설치하고 업데이트할 수 있습니다.

현재 로드된 패키지를 확인하려면

@example
> search()
@end example

@noindent
를 사용하여 검색 목록을 표시합니다. 일부 패키지는 로드되었지만 검색 목록에서 사용할 수 없을 수 있습니다 (@pxref{네임스페이스}): 이 경우 다음 목록에 포함됩니다.

@example
> loadedNamespaces()
@end example

설치된 패키지에서 사용 가능한 모든 도움말 주제 목록을 보려면

@example
> help.start()
@end example

@noindent
을 사용하여 @HTML{} 도움말 시스템을 시작한 다음 @code{Reference} 섹션에서 패키지 목록으로 이동하십시오.

@menu
* 표준 패키지::           
* 기여 패키지 및 CRAN::  
* 네임스페이스::                  
@end menu

@node 표준 패키지, 기여 패키지 및 CRAN, 패키지, 패키지
@section 표준 패키지

표준(또는 @emph{기본}) 패키지는 @R{} 소스 코드의 일부로 간주됩니다. 이 패키지들은 @R{}을 작동시키는 기본 기능과 이 매뉴얼에 설명된 데이터셋 및 표준 통계 및 그래픽 기능을 포함하고 있습니다. 이 패키지들은 모든 @R{} 설치에서 자동으로 사용할 수 있어야 합니다. 완전한 목록을 보려면 @xref{R에 어떤 추가 패키지가 있나요?, , R 패키지, R-FAQ, R FAQ}를 참조하세요.

@node 기여 패키지 및 CRAN, 네임스페이스, 표준 패키지, 패키지
@section 기여 패키지와 @acronym{CRAN}
@cindex CRAN

수천 개의 기여 패키지들이 많은 다른 저자들에 의해 @R{}에 작성되어 있습니다. 이러한 패키지 중 일부는 전문 통계 방법을 구현하고, 다른 일부는 데이터나 하드웨어에 접근을 제공하며, 또 다른 일부는 교재를 보완하기 위해 설계되었습니다. 일부(@emph{추천} 패키지)는 모든 @R{} 바이너리 배포와 함께 배포됩니다. 대부분은 @acronym{CRAN} (@uref{https://CRAN.R-project.org/} 및 그 미러 사이트) 및 Bioconductor (@uref{https://www.bioconductor.org/})와 같은 다른 저장소에서 다운로드할 수 있습니다.
@c 및 Omegahat (@uref{http://www.omegahat.net/}).
@emph{R FAQ}은 릴리스 시점의 CRAN 패키지 목록을 포함하지만, 사용 가능한 패키지 모음은 매우 자주 변경됩니다.

@node 네임스페이스,  , 기여 패키지 및 CRAN, 패키지
@section 네임스페이스
@cindex 네임스페이스
@findex ::
@findex :::

패키지는 @emph{네임스페이스}를 가지며, 이는 세 가지 기능을 수행합니다. 패키지 작성자가 내부적으로만 사용되는 함수와 데이터를 숨길 수 있게 하고, 사용자(또는 다른 패키지 작성자)가 패키지 내의 이름과 충돌하는 이름을 선택했을 때 함수가 손상되는 것을 방지하며, 특정 패키지 내의 객체를 참조하는 방법을 제공합니다.

예를 들어, @code{t()}는 @R{}에서 전치 함수입니다. 그러나 사용자는 @code{t}라는 자체 함수를 정의할 수 있습니다. 네임스페이스는 사용자의 정의가 우선 순위를 가지고, 행렬을 전치하는 모든 함수가 손상되는 것을 방지합니다.

네임스페이스와 함께 작동하는 두 개의 연산자가 있습니다. 이중 콜론 연산자 @code{::}는 특정 네임스페이스에서 정의를 선택합니다. 위의 예에서 전치 함수는 항상 @code{base::t}로 사용할 수 있습니다. 왜냐하면 이 함수는 @code{base} 패키지에 정의되어 있기 때문입니다. 이 방법으로는 패키지에서 내보낸 함수만 검색할 수 있습니다.

삼중 콜론 연산자 @code{:::}는 R 코드의 몇몇 부분에서 볼 수 있습니다. 이는 이중 콜론 연산자와 비슷하게 작동하지만, 숨겨진 객체에 대한 접근도 허용합니다. 사용자들은 @code{getAnywhere()} 함수를 더 자주 사용할 가능성이 높으며, 이 함수는 여러 패키지를 검색합니다.

패키지들은 종종 상호 의존적이며, 하나를 로드하면 다른 패키지가 자동으로 로드될 수 있습니다. 위에서 설명한 콜론 연산자도 관련 패키지의 자동 로딩을 유발합니다. 네임스페이스가 있는 패키지가 자동으로 로드되면 검색 목록에 추가되지 않습니다.

@node 운영체제 기능, 예제 세션, 패키지, 상위
@chapter 운영체제 기능

@R{}은 실행 중인 운영체제에 액세스하기 위한 상당히 광범위한 기능을 가지고 있습니다. 이를 통해 스크립팅 언어로 사용할 수 있으며, @R{} 자체에서 패키지를 설치하는 데 사용되는 경우도 많습니다.

@R{}의 스크립트는 모든 플랫폼에서 작동해야 하므로, 스크립팅 기능을 가능한 한 플랫폼 독립적으로 만드는 데 상당한 노력이 기울여졌습니다.

@menu
* 파일 및 디렉토리::       
* 파일경로::                   
* 시스템 명령어::             
* 압축 및 아카이브::    
@end menu

@node 파일 및 디렉토리, 파일경로, 운영체제 기능, 운영체제 기능
@section 파일 및 디렉토리

파일과 디렉토리를 조작하는 많은 함수들이 있습니다. 여기서는 더 자주 사용되는 몇 가지 함수에 대한 설명을 제공합니다.

빈 파일이나 디렉토리를 생성하려면 @code{file.create} 또는 @code{dir.create}를 사용합니다. (이들은 POSIX 유틸리티인 @command{touch}와 @command{mkdir}와 대응됩니다.) @R{} 세션 디렉토리의 임시 파일과 디렉토리는 @code{tempfile}에서 확인할 수 있습니다.

파일은 @code{file.remove} 또는 @code{unlink}를 사용하여 삭제할 수 있습니다. 후자는 디렉토리 트리를 제거할 수도 있습니다.

디렉토리 목록을 보려면 @code{list.files}(또는 @code{dir}로도 사용 가능) 또는 @code{list.dirs}를 사용하세요. 정규 표현식을 사용하여 파일을 선택할 수 있습니다. 와일드카드를 사용하여 선택하려면 @code{Sys.glob}을 사용하세요.

파일 경로에 대한 여러 가지 정보(예를 들어 파일인지 디렉토리인지 여부 등)는 @code{file.info}를 통해 찾을 수 있습니다.

파일이 '존재하는지' 확인하는 여러 가지 방법이 있습니다(파일이 파일 시스템에 존재하고 현재 사용자에게 보이지 않을 수 있음). @code{file.exists}, @code{file.access}, @code{file_test} 같은 함수들이 이러한 테스트의 다양한 버전을 제공합니다. @code{file_test}는 쉘 스크립팅에 익숙한 사용자를 위한 POSIX @command{test} 명령의 버전입니다.

@code{file.copy} 함수는 POSIX 명령인 @command{cp}와 대응되는 @R{} 함수입니다.

파일 선택은 @code{file.choose}를 통해 대화식으로 수행할 수 있습니다. Windows 포트는 더 다양한 기능을 제공하는 @code{choose.files}와 @code{choose.dir}가 있으며, @pkg{tcltk} 패키지에도 유사한 기능이 있습니다. @code{tk_choose.files}와 @code{tk_choose.dir}입니다.

@code{file.show}와 @code{file.edit} 함수는 콘솔(예: Windows의 RGui 또는 macOS의 R.app)을 사용하는 경우 적절한 방식으로 하나 이상의 파일을 표시하고 편집할 수 있습니다.

파일 시스템에서 @emph{링크}에 대한 지원이 어느 정도 있습니다. 함수 @code{file.link}와 @code{Sys.readlink}를 참조하세요.


@node 파일경로, 시스템 명령어, 파일 및 디렉토리, 운영체제 기능
@section 파일경로

몇 가지 예외를 제외하고, @R{}은 기본 운영체제(OS) 함수에 의존하여 파일 경로를 조작합니다. 이러한 일부는 운영체제에 따라 달라질 수 있으며, 실제로 운영체제의 버전에 따라 다를 수 있습니다. POSIX 표준은 운영체제가 파일 경로를 어떻게 해석해야 하는지에 대한 기준을 제공하며, 많은 @R{} 사용자들은 POSIX 준수를 가정합니다. 그러나 Windows는 준수를 주장하지 않으며, 다른 운영체제들도 완전히 준수하지 않을 수 있습니다.

다음은 파일 경로와 관련하여 발생한 몇 가지 문제입니다.

@itemize @bullet
@item
POSIX 파일 시스템은 대소문자를 구분하므로, @file{foo.png}와 @file{Foo.PNG}는 서로 다른 파일입니다. 그러나 Windows와 macOS의 기본 설정은 대소문자를 구분하지 않으며, 일반적으로 제거 가능한 저장소에서 사용되는 FAT 파일 시스템은 대소문자를 구분하지 않는 것이 일반적입니다(모든 파일 경로가 소문자로 매핑될 수 있음).

@item
대부분의 Windows OS 서비스는 슬래시나 역슬래시를 파일 경로 구분자로 사용하는 것을 지원하며, @R{}은 알려진 예외를 Windows에서 요구하는 형식으로 변환합니다.

@item
마지막에 슬래시가 있는 파일 경로의 동작은 운영체제에 따라 다릅니다. 이러한 경로는 Windows에서 유효하지 않으므로 작동할 것으로 예상하지 않아야 합니다. POSIX-2008에서는 이러한 경로가 디렉토리에만 일치하도록 요구하지만, 이전 버전에서는 파일에도 일치할 수 있습니다. 따라서 이러한 경우는 피하는 것이 좋습니다.

@item
@file{/abc//def}와 같은 파일 경로의 여러 슬래시는 POSIX 파일 시스템에서 유효하며, 하나의 슬래시만 있는 것처럼 처리됩니다. 이들은 일반적으로 Windows OS 함수에서도 허용됩니다. 그러나 처음 두 개의 슬래시는 다른 의미를 가질 수 있습니다.

@item
Windows의 UNC 파일 경로(예: @file{\\server\dir1\dir2\file} 및 @file{\\?\UNC\server\dir1\dir2\file})는 지원되지 않지만, 일부 @R{} 함수에서 작동할 수 있습니다. POSIX 파일 시스템은 처음 두 개의 슬래시를 특별하게 처리할 수 있습니다.

@item
Windows는 드라이브를 포함하고 드라이브의 현재 디렉토리를 기준으로 한 파일 경로를 허용합니다. 예를 들어, @file{d:foo/bar}는 현재 @emph{드라이브 @file{d:}에서의} 디렉토리가 @file{/a/b/c}인 경우 @file{d:/a/b/c/foo/bar}를 참조합니다. 이러한 경우가 작동하도록 의도되었지만, 절대 경로를 사용하는 것이 더 안전합니다.
@end itemize

함수 @code{basename}과 @code{dirname}은 파일 경로의 일부를 선택합니다. 구성 요소에서 파일 경로를 조립하는 권장 방법은 @code{file.path}입니다. 함수 @code{pathexpand}는 '틸드 확장'을 수행하여 홈 디렉토리(현재 사용자의 경우, 다른 사용자의 경우)에 대한 값을 대체합니다.

링크가 있는 파일 시스템에서는 하나의 파일이 여러 파일 경로로 참조될 수 있습니다. 함수 @code{normalizePath}는 정규 파일 경로를 찾습니다.

Windows에는 짧은 ('8.3') 파일 이름과 긴 파일 이름이라는 개념이 있습니다. @code{normalizePath}는 긴 파일 이름을 사용하는 절대 경로를 반환하고, @code{shortPathName}은 짧은 이름을 사용하는 버전을 반환합니다. 후자에는 공백이 없고 백슬래시를 구분 기호로 사용하므로, @R{}에서 이름을 내보낼 때 유용하게 사용됩니다.

파일 @emph{권한}은 관련된 주제입니다. @R{}는 소유자/그룹/모두에 대한 읽기/쓰기/실행 권한이 있는 POSIX 개념을 지원하지만, 이 기능은 파일 시스템에서 부분적으로만 지원될 수 있으므로 예를 들어 Windows에서는 @R{} 세션을 실행하는 계정에 대한 읽기 전용 파일만 인식됩니다. Access Control 리스트 (ACL)는 여러 파일 시스템에서 사용되지만, 공통 표준이 없으며 @R{}에서는 이를 제어할 수 있는 기능이 없습니다. 권한을 변경하려면 @code{Sys.chmod}를 사용하십시오.

@node 시스템 명령어, 압축 및 아카이브, 파일경로, 운영체제 기능
@section 시스템 명령어

함수 @code{system}과 @code{system2}는 시스템 명령을 호출하고 선택적으로 출력을 수집하는 데 사용됩니다. @code{system2}는 조금 더 일반적이지만, 이를 사용하면 플랫폼 간 코드 작성이 더 쉽습니다.

@code{system}은 Windows와 다른 운영체제에서 다르게 작동합니다(API C 호출이 그렇게 하기 때문입니다). 그 외에는 명령을 실행하기 위해 셸을 호출합니다. @R{}의 Windows 포트에는 이를 수행하는 함수 @code{shell}이 있습니다.

운영 체제에 명령이 포함되어 있는지 확인하려면 @code{Sys.which}를 사용하십시오. 이는 플랫폼 간 방식으로 이를 시도합니다(불행히도 표준 운영 체제 서비스는 아닙니다).

함수 @code{shQuote}는 현재 운영 체제의 명령에 필요한 파일 경로를 인용합니다.

@node 압축 및 아카이브, , 시스템 명령어, 운영체제 기능
@section 압축 및 아카이브

최근 버전의 @R{}은 압축된 파일을 읽고 쓸 수 있는 광범위한 기능을 갖추고 있으며, 이를 종종 투명하게 처리합니다. @R{}에서 파일을 읽는 작업은 대부분 @emph{연결}을 통해 이루어지며, 파일(또는 URL)에 연결을 열기 위해 사용되는 @code{file} 함수는 파일의 '매직' 헤더로부터 사용된 압축을 식별할 수 있습니다.

가장 오래된 지원 압축 유형은 @command{gzip} 압축이며, 이는 좋은 일반적인 절충안을 유지합니다. 이전 Unix @command{compress} 유틸리티로 압축된 파일도 읽을 수 있지만, 이러한 파일은 점점 줄어들고 있습니다. @command{bzip2} 및 @command{xz} 유틸리티의 압축 형식 두 가지도 사용할 수 있습니다. 이들은 일반적으로 더 높은 압축률(파일에 따라 훨씬 높음)을 달성하지만, 압축 해제 속도가 느리고 압축 속도가 매우 느립니다.

@command{xz}와 @command{lzma} 압축(참조: @uref{https://en.wikipedia.org/wiki/Xz} 및 @uref{https://en.wikipedia.org/wiki/LZMA}) 사이에는 약간의 혼란이 있습니다. @R{}은 두 가지 중 대부분의 버전으로 압축된 파일을 읽을 수 있습니다.

파일 아카이브는 여러 파일을 포함하는 단일 파일로, 가장 일반적인 것은 `tarballs` 및 @R{} 패키지 배포에 사용되는 zip 파일입니다. @R{}은 두 가지 모두를 나열하고 압축을 풀 수 있으며(함수 @code{untar} 및 @code{unzip} 참조), 두 가지 모두를 생성할 수 있습니다(@command{zip}의 경우 외부 프로그램의 도움으로).

@node 예제 세션, R 실행하기, 운영체제 기능, 상위
@appendix 예제 세션

다음 세션은 @R{} 환경의 몇 가지 기능을 사용하여 소개하는 것을 목적으로 합니다. 시스템의 많은 기능들이 처음에는 익숙하지 않고 혼란스러울 수 있지만, 이 혼란은 곧 사라질 것입니다.
@c 이것은 유닉스 사용자를 위해 작성되었습니다. 윈도우를 사용하는 사람들은 이에 대한 논의를 약간 수정해야 합니다.

@table @code
@item 플랫폼에 적합한 @R{} 시작 (@pxref{R 실행하기}).

@R{} 프로그램이 시작되며, 배너가 표시됩니다.

(@R{} 코드 내에서 왼쪽 프롬프트는 혼동을 피하기 위해 표시되지 않습니다.)

@item help.start()
온라인 도움말의 @HTML{} 인터페이스를 시작합니다 (사용 가능한 웹 브라우저를 통해). 마우스를 사용하여 이 시설의 기능을 간략하게 탐색해야 합니다.

도움말 창을 아이콘화하고 다음 부분으로 넘어갑니다.

@item x <- rnorm(50)
@itemx y <- rnorm(x)
@math{x} 좌표와 @math{y} 좌표의 두 개의 의사 난수 정규 벡터를 생성합니다.

@item plot(x, y)
평면에 점을 그립니다. 그래픽 창이 자동으로 나타납니다.

@item ls()
@R{} 작업 공간에 어떤 @R{} 객체가 있는지 확인합니다.

@item rm(x, y)
더 이상 필요하지 않은 객체를 제거합니다. (정리)

@item x <- 1:20
@math{x = (1, 2, @dots{}, 20)}를 생성합니다.

@item w <- 1 + sqrt(x)/2
표준 편차의 `가중치' 벡터입니다.

@item dummy <- data.frame(x=x, y= x + rnorm(x)*w)
@itemx dummy
두 열, @math{x}와 @math{y}로 구성된 @emph{데이터 프레임}을 만들고 그것을 살펴봅니다.

@item fm <- lm(y ~ x, data=dummy)
@itemx summary(fm)
간단한 선형 회귀를 적합시키고 분석 결과를 확인합니다. 물결표시 왼쪽에 @code{y}가 있으면, @math{y}를 @math{x}에 의존하는 것으로 모델링합니다.

@item fm1 <- lm(y ~ x, data=dummy, weight=1/w^2)
@itemx summary(fm1)
표준 편차를 알고 있으므로, 가중치를 적용한 회귀를 수행할 수 있습니다.

@item attach(dummy)
데이터 프레임의 열을 변수로 표시합니다.

@item lrf <- lowess(x, y)
비모수적 지역 회귀 함수를 생성합니다.

@item plot(x, y)
표준 점 그림입니다.

@item lines(x, lrf$y)
지역 회귀를 추가합니다.

@item abline(0, 1, lty=3)
진정한 회귀선: (절편 0, 기울기 1).

@item abline(coef(fm))
가중치가 없는 회귀선입니다.

@item abline(coef(fm1), col = "red")
가중치가 있는 회귀선입니다.

@item detach()
검색 경로에서 데이터 프레임을 제거합니다.

@item plot(fitted(fm), resid(fm),
@itemx @w{@ @ @ @ @ xlab="적합된 값"},
@itemx @w{@ @ @ @ @ ylab="잔차"},
@itemx @w{@ @ @ @ @ main="잔차 대 적합"})
이분산성을 확인하기 위한 표준 회귀 진단 그림입니다.
이것을 볼 수 있나요?

@item qqnorm(resid(fm), main="잔차 랭킷 플롯")
왜도, 첨도 및 이상치를 확인하기 위한 정규 점수 플롯입니다. (여기서는 크게 유용하지 않습니다.)

@item rm(fm, fm1, lrf, x, dummy)
다시 정리합니다.
@end table

다음 부분에서는 미셸슨이 빛의 속도를 측정하기 위한 고전적인 실험의 데이터를 살펴볼 것입니다. 이 데이터셋은 @code{morley} 객체에 있지만, @code{read.table} 함수를 설명하기 위해 읽어 올 것입니다.

@table @code
@item filepath <- system.file("data", "morley.tab" , package="datasets")
@itemx filepath
데이터 파일의 경로를 가져옵니다.

@item file.show(filepath)
선택 사항입니다. 파일을 확인합니다.

@item mm <- read.table(filepath)
@itemx mm
미셸슨 데이터를 데이터 프레임으로 읽어들이고 확인합니다.
5개의 실험 (열 @code{Expt})이 있으며 각 실험에는 20개의 실행 (열 @code{Run})이 있고 @code{sl}은 적절하게 코딩된 빛의 속도를 기록한 것입니다.

@item mm$Expt <- factor(mm$Expt)
@itemx mm$Run <- factor(mm$Run)
@code{Expt}와 @code{Run}을 요인으로 변환합니다.

@item attach(mm)
데이터 프레임을 2번 위치(기본값)에서 보이게 합니다.

@item plot(Expt, Speed, main="빛의 속도 데이터", xlab="실험 번호")
간단한 상자 그림으로 5개의 실험을 비교합니다.

@item fm <- aov(Speed ~ Run + Expt, data=mm)
@itemx summary(fm)
`Run'과 `Expt'을 요인으로 하는 무작위 블록으로 분석합니다.

@item fm0 <- update(fm, . ~ . - Run)
@itemx anova(fm0, fm)
`Run'을 생략한 하위 모델을 적합하고 분산분석을 사용하여 공식적으로 비교합니다.

@item detach()
@itemx rm(fm, fm0)
계속 진행하기 전에 정리합니다.

@end table

이제 등고선 및 이미지 플롯과 같은 추가적인 그래픽 기능을 살펴보겠습니다.

@table @code
@item x <- seq(-pi, pi, len=50)
@itemx y <- x
@math{x}는 구간에서 50개의 균일한 간격 값을 가진 벡터입니다.
@ifnottex
[-파이, 파이].
@end ifnottex
@iftex
@tex
$-\pi\leq x \leq \pi$.
@end tex
@end iftex
@math{y}도 동일합니다.

@item f <- outer(x, y, function(x, y) cos(y)/(1 + x^2))
@math{f}는 행과 열이 각각 @math{x}와 @math{y}로 색인화된 정방 행렬로,
함수 @eqn{\cos(y)/(1 + x^2),cos(y)/(1 + x^2)}의 값들로 구성되어 있습니다.

@item oldpar <- par(no.readonly = TRUE)
@itemx par(pty="s")
그리기 매개변수를 저장하고 그리기 영역을 "정사각형"으로 설정합니다.

@item contour(x, y, f)
@itemx contour(x, y, f, nlevels=15, add=TRUE)
@math{f}의 등고선 지도를 생성합니다. 더 자세한 내용을 위해 더 많은 선을 추가합니다.

@item fa <- (f-t(f))/2
@code{fa}는 @math{f}의 "비대칭 부분"입니다. (@code{t()}는 전치입니다).

@item contour(x, y, fa, nlevels=15)
등고선 그림을 생성합니다. @dots{}

@item par(oldpar)
@dots{} 그리고 이전 그래픽 매개변수를 복원합니다.

@item image(x, y, f)
@itemx image(x, y, fa)
고밀도 이미지 그림을 생성합니다(원하는 경우 하드 카피를 얻을 수 있음). @dots{}

@item objects(); rm(x, y, f, fa)
@dots{} 그리고 계속 진행하기 전에 정리합니다.
@end table

@R{}는 복소수 연산도 수행할 수 있습니다.

@table @code
@item th <- seq(-pi, pi, len=100)
@itemx z <- exp(1i*th)
@code{1i}는 복소수 @math{i}를 사용합니다.

@item par(pty="s")
@itemx plot(z, type="l")
복소수 인수를 그리기는 허수 부분과 실수 부분에 대한 그래프입니다. 이것은 원이어야 합니다.

@item w <- rnorm(100) + rnorm(100)*1i
단위 원 내의 점들을 샘플링하려고 합니다. 표준 정규 분포의 실수와 허수 부분을 가진 복소수를 사용하는 것이 한 가지 방법입니다. @dots{}

@item w <- ifelse(Mod(w) > 1, 1/w, w)
@dots{} 원 바깥에 있는 점들은 그 역수로 매핑합니다.

@item plot(w, xlim=c(-1,1), ylim=c(-1,1), pch="+",xlab="x", ylab="y")
@itemx lines(z)
모든 점들이 단위 원 안에 있지만, 분포는 균일하지 않습니다.

@item w <- sqrt(runif(100))*exp(2*pi*runif(100)*1i)
@itemx plot(w, xlim=c(-1,1), ylim=c(-1,1), pch="+", xlab="x", ylab="y")
@itemx lines(z)
두 번째 방법은 균일 분포를 사용합니다. 이제 원판에 더 고르게 배치된 것처럼 보여야 합니다.

@item rm(th, w, z)
다시 정리합니다.

@item q()
@R{} 프로그램을 종료합니다. @R{} 작업 공간을 저장할지 묻습니다. 이와 같은 탐색 세션의 경우 작업 공간을 저장하지 않으려 할 것입니다.
@end table

@node R 실행하기, 명령행 편집기, 예제 세션, 상위
@appendix R 실행하기

Windows 또는 macOS에서 @R{}를 사용하는 사용자는 먼저 OS별 섹션을 읽어야 하지만 명령줄 사용도 지원됩니다.

@menu
* 명령행에서 R 실행하기::
* Windows에서 R 실행하기::
* macOS에서 R 실행하기::
* R로 스크립팅하기::
@end menu

@node 명령행에서 R 실행하기, Windows에서 R 실행하기, R 실행하기, R 실행하기
@appendixsec 명령행에서 R 실행하기

UNIX 또는 Windows의 명령행에서 작업할 때 @samp{R} 명령어는 주요 @R{} 프로그램을 시작하는 데 사용할 수 있으며, 형식은 다음과 같습니다.

@display
@code{R} [@var{옵션}] [@code{<}@var{입력파일}] [@code{>}@var{출력파일}],
@end display

@noindent
또한 @code{R CMD} 인터페이스를 통해, "직접" 호출할 예정이 아닌 @R{} 문서 형식의 파일 처리 또는 추가 패키지 조작과 같은 다양한 @R{} 도구에 대한 래퍼로 사용할 수 있습니다.

Windows 명령행에서는 @command{R} 대신 @command{Rterm.exe}를 선호합니다.

환경 변수 @env{TMPDIR}이 설정되지 않았거나 임시 파일 및 디렉토리를 생성할 수 있는 유효한 위치를 가리켜야 합니다.

대부분의 옵션은 @R{} 세션의 시작과 끝에 어떤 일이 발생하는지를 제어합니다. 시작 메커니즘은 다음과 같습니다(자세한 내용은 온라인 도움말의 @samp{Startup} 주제와 아래의 일부 Windows 관련 세부 정보를 참조하십시오).

@itemize @bullet
@item
@option{--no-environ}이 주어지지 않은 경우, @R{}은 환경 변수를 설정하기 위해 사용자 파일과 사이트 파일을 찾습니다. 사이트 파일의 이름은 환경 변수 @env{R_ENVIRON}이 가리키는 것입니다. 이 변수가 설정되지 않은 경우, @file{@var{R_HOME}/etc/Renviron.site}(존재하는 경우)가 사용됩니다. 사용자 파일은 환경 변수 @env{R_ENVIRON_USER}이 설정된 경우 이 변수가 가리키는 파일입니다. 그렇지 않으면, 현재 디렉터리 또는 사용자의 홈 디렉터리에 있는 @file{.Renviron} 파일을 찾습니다(이 순서대로). 이 파일들은 @samp{@var{name}=@var{value}} 형식의 줄을 포함해야 합니다. (정확한 설명은 @code{help("Startup")}을 참조하세요.) 설정할 수 있는 변수에는 @env{R_PAPERSIZE}(기본 용지 크기), @env{R_PRINTCMD}(기본 인쇄 명령), @env{R_LIBS}(추가 패키지를 검색하기 위해 @R{} 라이브러리 트리 목록을 지정)가 포함됩니다.

@item
그런 다음 명령 줄 옵션 @option{--no-site-file}이 주어지지 않은 경우, @R{}는 사이트 전체의 시작 프로필을 찾습니다. 이 파일의 이름은 환경 변수 @env{R_PROFILE}의 값에서 가져옵니다. 해당 변수가 설정되지 않은 경우, @file{@var{R_HOME}/etc/Rprofile.site}(존재하는 경우)가 기본값으로 사용됩니다.

@item
그런 다음 @option{--no-init-file}이 주어지지 않은 경우, @R{}는 사용자 프로필을 찾고 이를 로드합니다. 이 파일의 이름은 환경 변수 @env{R_PROFILE_USER}에서 가져옵니다. 설정되지 않은 경우, 현재 디렉터리 또는 사용자의 홈 디렉터리에 있는 @file{.Rprofile} 파일을 찾습니다(이 순서대로).

@item
또한, 현재 디렉터리에 @file{.RData} 파일이 있으면 저장된 작업 공간을 불러옵니다(@option{--no-restore} 또는 @option{--no-restore-data}가 지정되지 않은 경우).

@item
마지막으로, @code{.First()} 함수가 있으면 실행됩니다. 이 함수(@code{.Last()} 함수도 마찬가지로 @R{} 세션 종료 시 실행됨)는 적절한 시작 프로필에 정의되어 있거나 @file{.RData}에 존재할 수 있습니다.
@end itemize

또한, @R{} 프로세스에 사용 가능한 메모리를 제어하는 옵션도 있습니다(@samp{Memory} 주제에 대한 온라인 도움말에서 자세한 정보를 확인하세요). 사용자들은 일반적으로 @R{}에서 사용되는 메모리 양을 제한하려고 할 때만 이 옵션을 사용할 필요가 있습니다.

@R{}은 다음 명령줄 옵션을 허용합니다.

@table @option
@item --help
@itemx -h
표준 출력에 짧은 도움말 메시지를 출력하고 성공적으로 종료합니다.

@item --version
표준 출력에 버전 정보를 출력하고 성공적으로 종료합니다.

@item --encoding=@var{enc}
콘솔이나 @code{stdin}에서 입력되는 인코딩을 지정합니다. 이것은 @code{iconv}에서 알려진 인코딩이어야 합니다. 도움말 페이지를 참조하세요. (@code{--encoding @var{enc}}도 허용됩니다.) 입력은 @R{}이 실행 중인 로케일로 다시 인코딩되며 후자의 인코딩에서 표현 가능해야 합니다(예를 들어, UTF-8 인코딩을 사용하지 않는 프랑스어 로케일에서 그리스어 텍스트를 다시 인코딩할 수 없습니다).

@item RHOME
표준 출력에 @R{} "홈 디렉토리" 경로를 출력하고 성공적으로 종료합니다. 프론트엔드 쉘 스크립트와 맨 페이지를 제외하고 @R{} 설치는 모든 것(실행 파일, 패키지 등)을 이 디렉토리에 넣습니다.

@item --save
@itemx --no-save
@R{} 세션 종료 시 데이터 세트를 저장할지 여부를 제어합니다. 대화식 세션에서 두 옵션 중 하나도 주어지지 않은 경우, 사용자는 세션을 @kbd{q()}로 종료할 때 원하는 동작을 요청받습니다. 대화식이 아닌 사용에서는 이 중 하나가 지정되어야 하거나 다른 옵션(아래 참조)에 의해 암시되어야 합니다.

@item --no-environ
환경 변수를 설정하기 위해 사용자 파일을 읽지 않습니다.

@item --no-site-file
시작할 때 사이트 전체 프로파일을 읽지 않습니다.

@item --no-init-file
시작할 때 사용자 프로파일을 읽지 않습니다.

@item --restore
@itemx --no-restore
@itemx --no-restore-data
시작 시 저장된 이미지(@R{}가 시작된 디렉토리의 @file{.RData} 파일)를 복원할지 여부를 제어합니다. 기본적으로 복원합니다.(@option{--no-restore}는 모든 구체적인 @option{--no-restore-*} 옵션을 포함합니다.)

@item --no-restore-history
시작할 때 히스토리 파일(일반적으로 @R{}가 시작된 디렉토리의 @file{.Rhistory} 파일이지만, 환경 변수 @env{R_HISTFILE}에 의해 설정될 수 있음)을 복원할지 여부를 제어합니다. 기본적으로 복원합니다.

@item --no-Rconsole
(Windows 전용) 시작 시 @file{Rconsole} 파일을 로드하지 않습니다.

@item --vanilla
@option{--no-save}, @option{--no-environ}, @option{--no-site-file}, @option{--no-init-file}, @option{--no-restore}를 결합합니다. Windows에서는 @option{--no-Rconsole}도 포함됩니다.

@item -f @var{file}
@itemx --file=@var{file}
(@command{Rgui.exe}이 아님) @var{file}에서 입력을 가져옵니다: @samp{-}는 @code{stdin}을 의미합니다. @option{--save}가 설정되지 않은 경우 @option{--no-save}를 의미합니다. 유닉스 계열에서는 @var{file}에서 셸 메타문자를 피해야 합니다(하지만 공백은 허용됩니다).

@item -e @var{expression}
(@command{Rgui.exe}이 아님) @var{expression}을 입력 라인으로 사용합니다. 하나 이상의 @option{-e} 옵션을 사용할 수 있지만, @option{-f} 또는 @option{--file}과 함께 사용할 수는 없습니다. @option{--save}가 설정되지 않은 경우 @option{--no-save}를 의미합니다. (이 방법으로 사용된 표현식의 전체 길이에는 10,000 바이트의 제한이 있습니다. 공백이나 셸 메타문자가 포함된 표현식은 따옴표로 묶어야 합니다.)

@item --no-readline
(UNIX 전용) @strong{readline}을 통한 명령행 편집을 끕니다. 이것은 Emacs에서 @acronym{ESS} (``Emacs Speaks Statistics'') 패키지를 사용하여 @R{}을 실행할 때 유용합니다. 자세한 정보는 @option{명령행 편집기}를 참조하십시오. 명령행 편집은 기본 대화식 사용(참조 @option{--interactive})에 대해 활성화됩니다. 이 옵션은 또한 틸드 확장에 영향을 미칩니다. @code{path.expand} 도움말을 참조하십시오.

@item --min-vsize=@var{N}
@itemx --min-nsize=@var{N}
전문가 전용: 벡터 힙(바이트 단위)의 가비지 수집에 대한 초기 트리거 크기와 @emph{cons cells}(숫자)를 각각 설정합니다. @samp{M} 접미사는 메가바이트 또는 백만 개의 셀을 지정합니다. 기본값은 각각 6Mb와 350k이며, 환경 변수 @env{R_NSIZE}와 @env{R_VSIZE}로 설정할 수도 있습니다.

@item --max-ppsize=@var{N}
포인터 보호 스택의 최대 크기를 @var{N} 위치로 지정합니다. 이것은 기본적으로 10,000으로 설정되어 있지만, 크고 복잡한 계산을 수행할 수 있도록 증가시킬 수 있습니다. 현재 최대 허용 값은 100,000입니다.

@item --quiet
@itemx --silent
@itemx -q
초기 저작권 및 환영 메시지를 출력하지 않습니다.

@item --no-echo
@R{}을 가능한 한 조용하게 실행하게 만듭니다. 이 옵션은 @R{}을 사용하여 결과를 계산해주는 프로그램을 지원하기 위한 것입니다. @option{--quiet} 및 @option{--no-save}를 의미합니다.

@item --interactive
(UNIX 전용) 입력이 리디렉션되었음에도 불구하고 @R{}이 실제로 대화식으로 실행되고 있다고 확인합니다. 입력이 대화식 프로그램에서 공급되는 FIFO 또는 파이프에서 나올 경우 사용하십시오. (기본적으로 @file{stdin}이 터미널 또는 @code{pty}에 연결되어 있는 경우에만 @R{}이 대화식으로 실행된다고 추론합니다.) @option{-e}, @option{-f} 또는 @option{--file}을 사용하면 @option{--interactive}가 주어진 경우에도 비대화식 사용을 확인합니다.

명령 줄 편집을 켜지 않는 것에 유의하십시오.

@item --ess
(Windows 전용) @acronym{ESS}의 @code{R-inferior-mode}에서 사용하기 위해 @code{Rterm}을 설정하며, 대화식 사용(명령 줄 편집기 없음)과 @file{stdout}의 버퍼링 없음을 확인합니다.

@item --verbose
진행 상황에 대한 더 많은 정보를 출력하고, 특히 @R{}의 옵션 @code{verbose}를 @code{TRUE}로 설정합니다. @R{} 코드는 이 옵션을 사용하여 진단 메시지의 출력을 제어합니다.

@item --debugger=@var{name}
@itemx -d @var{name}
(UNIX 전용) 디버거 @var{name}을 통해 @R{}을 실행합니다. 대부분의 디버거(@command{valgrind}와 최근 버전의 @command{gdb} 제외)의 경우 추가 명령 줄 옵션은 무시되며, 대신 디버거 내부에서 @R{} 실행 파일을 시작할 때 주어져야 합니다.

@item --gui=@var{type}
@itemx -g @var{type}
(UNIX 전용) @var{type}을 그래픽 사용자 인터페이스로 사용합니다(이는 대화식 그래픽도 포함됩니다). 현재 가능한 @var{type} 값은 @samp{X11}(기본값) 및 @samp{Tcl/Tk} 지원이 가능한 경우 @samp{Tk}입니다. (하위 호환성을 위해 @samp{x11} 및 @samp{tk}도 허용됩니다.)

@item --arch=@var{name}
(UNIX 전용) 지정된 하위 아키텍처를 실행합니다.

@item --args
이 플래그는 명령 줄의 나머지 부분을 건너뛰게 하는 것 외에는 아무 것도 하지 않습니다. 이는 @code{commandArgs(TRUE)}를 사용하여 값을 검색하는 데 유용할 수 있습니다.
@end table

입력과 출력은 평소처럼 리디렉션될 수 있습니다(@samp{<} 및 @samp{>} 사용). 그러나 4095바이트의 줄 길이 제한이 여전히 적용됩니다. 경고와 오류 메시지는 오류 채널(@code{stderr})로 전송됩니다.

@code{R CMD} 명령은 @R{}과 함께 사용하기에 유용한 여러 도구를 호출할 수 있습니다. 일반적인 형태는 다음과 같습니다.

@example
R CMD @var{command} @var{args}
@end example

@noindent
여기서 @var{command}는 도구의 이름이고 @var{args}는 그것에 전달된 인수입니다.

현재 다음 도구들이 사용 가능합니다.

@table @code
@item BATCH
배치 모드에서 @R{}을 실행합니다. 추가로 가능한 옵션들(참조: @code{?BATCH})과 함께 @command{R --restore --save}를 실행합니다.
@item COMPILE
(UNIX 전용) @R{}과 함께 사용할 수 있는 C, C++, 포트란 등의 파일을 컴파일합니다.
@item SHLIB
동적 로딩을 위한 공유 라이브러리를 빌드합니다.
@item INSTALL
애드온 패키지를 설치합니다.
@item REMOVE
애드온 패키지를 제거합니다.
@item build
애드온 패키지를 빌드(즉, 패키지)합니다.
@item check
애드온 패키지를 확인합니다.
@item LINK
(UNIX 전용) 실행 가능한 프로그램을 생성하기 위한 프런트 엔드입니다.
@item Rprof
@R{} 프로파일링 파일을 후처리합니다.
@item Rdconv
@itemx Rd2txt
Rd 포맷을 @HTML{}, @LaTeX{}, 일반 텍스트 등 다양한 다른 포맷으로 변환하고 예제를 추출합니다. @code{Rd2txt}는 @code{Rd2conv -t txt}의 줄임말로 사용할 수 있습니다.
@item Rd2pdf
Rd 포맷을 PDF로 변환합니다.
@item Stangle
Sweave 또는 기타 비네트 문서에서 S/R 코드를 추출합니다.
@item Sweave
Sweave 또는 기타 비네트 문서를 처리합니다.
@item Rdiff
헤더 등을 무시하고 @R{} 출력의 차이를 비교합니다.
@item config
구성 정보를 얻습니다.
@item javareconf
(Unix 전용) Java 구성 변수를 업데이트합니다.
@item rtags
(Unix 전용) C, R, 및 Rd 파일에서 Emacs 스타일 태그 파일을 생성합니다.
@item open
(Windows 전용) Windows 파일 연결을 통해 파일을 엽니다.
@item texify
(Windows 전용) R의 스타일 파일로 (La)TeX 파일을 처리합니다.
@end table

사용법

@example
R CMD @var{command} --help
@end example

@noindent
@code{R CMD} 인터페이스를 통해 접근 가능한 각 도구에 대한 사용 정보를 얻습니다.

또한 @command{R}과 @command{CMD} 사이에 옵션 @option{--arch=}, @option{--no-environ}, @option{--no-init-file}, @option{--no-site-file} 및 @option{--vanilla}를 사용할 수 있습니다. 이 옵션들은 도구에 의해 실행되는 모든 @R{} 프로세스에 영향을 줍니다. (여기서 @option{--vanilla}는 @option{--no-environ --no-site-file --no-init-file}와 동일합니다.) 그러나 @command{R CMD} 자체는 어떠한 @R{} 시작 파일도 사용하지 않습니다(특히 사용자 또는 사이트 @file{Renviron} 파일 모두), 이 도구들에 의해 실행되는 모든 @R{} 프로세스는 @command{BATCH}를 제외하고 @option{--no-restore}를 사용합니다. 대부분은 @option{--vanilla}를 사용하여 어떠한 @R{} 시작 파일도 호출하지 않습니다. 현재 예외는 @command{INSTALL}, @command{REMOVE}, @command{Sweave} 및 @command{SHLIB}입니다(이 경우 @option{--no-site-file --no-init-file}를 사용합니다).

@example
R CMD @var{cmd} @var{args}
@end example

@noindent
경로에 있는 다른 실행 가능한 @command{@var{cmd}} 또는 절대 파일 경로로 지정된 경우: 이는 @R{} 또는 특정 명령이 실행되는 것과 동일한 환경을 갖는데 유용합니다. 예를 들어, @command{ldd} 또는 @command{pdflatex}를 실행할 때 사용할 수 있습니다. Windows에서 @var{cmd}는 실행 파일이나 배치 파일이거나, @code{.sh} 또는 @code{.pl} 확장자가 있는 경우 사용 가능한 적절한 인터프리터가 호출되어 실행됩니다.


@node Windows에서 R 실행하기, macOS에서 R 실행하기, 명령행에서 R 실행하기, R 실행하기
@appendixsec Windows에서 R 실행하기

Windows에서 @R{}을 실행하는 두 가지 방법이 있습니다. 터미널 창 내부(예: @code{cmd.exe} 또는 더욱 능력 있는 셸)에서 이전 섹션에서 설명한 방법을 사용하여 @code{R.exe} 또는 @code{Rterm.exe}를 호출할 수 있습니다. 대화형 사용의 경우 콘솔 기반 GUI(@code{Rgui.exe})가 있습니다.

Windows에서의 시작 절차는 UNIX에서와 매우 유사하지만 '홈 디렉토리'에 대한 참조가 명확해야 합니다. 이는 Windows에서 항상 정의되어 있지 않기 때문입니다. 환경 변수 @env{R_USER}가 정의되어 있으면 홈 디렉토리를 지정합니다. 다음으로 환경 변수 @env{HOME}이 정의되어 있으면 홈 디렉토리를 지정합니다. 이 두 가지 사용자가 제어할 수 있는 설정 이후에 @R{}은 시스템에서 정의한 홈 디렉토리를 찾으려고 시도합니다. 먼저 Windows "개인" 디렉토리(일반적으로 최근 Windows 버전에서는 @code{My Documents})를 사용하려고 시도합니다. 그것이 실패하고 환경 변수 @env{HOMEDRIVE}와 @env{HOMEPATH}가 정의되어 있다면(일반적으로 그렇습니다) 이들은 홈 디렉토리를 정의합니다. 그 모든 것이 실패하면 홈 디렉토리는 시작 디렉토리로 간주됩니다.

환경 변수 @env{TMPDIR}, @env{TMP}, @env{TEMP} 중 하나가 설정되지 않았거나 임시 파일과 디렉토리를 생성할 수 있는 유효한 위치를 가리키도록 해야 합니다.

환경 변수는 명령 줄에서 @samp{@var{name}=@var{value}} 쌍으로 제공할 수 있습니다.

인수 중 하나가 @file{.RData}로 끝나는 경우(대소문자 관계 없음) 복원할 작업 공간에 대한 경로로 해석됩니다. 이는 @option{--restore}를 의미하고, 지정된 파일의 상위 디렉토리로 작업 디렉토리를 설정합니다. (이 메커니즘은 끌어다 놓기 및 파일 연결에 사용되는 @code{RGui.exe}에 사용되지만 @code{Rterm.exe}에 대해서도 작동합니다. 지정된 파일이 존재하지 않으면 상위 디렉토리가 존재할 경우 작업 디렉토리를 설정합니다.)

@code{RGui.exe}를 호출할 때 다음과 같은 추가 명령줄 옵션이 사용 가능합니다.

@table @option
@item --mdi
@itemx --sdi
@itemx --no-mdi
@code{Rgui}가 MDI 프로그램(하나의 메인 창 내에 여러 개의 자식 창이 있는)으로 작동할지 아니면 SDI 애플리케이션(콘솔, 그래픽 및 페이저용 여러 개의 최상위 창이 있는)으로 작동할지 제어합니다. 명령 줄 설정은 사용자의 @file{Rconsole} 파일 설정을 무시합니다.

@item --debug
@code{Rgui}에서 "디버거로 중단" 메뉴 항목을 활성화하고, 명령 줄 처리 중 디버거로의 중단을 트리거합니다.
@end table

Windows에서 @code{R CMD}를 사용하여 사용자 정의 @file{.bat}, @file{.exe}, @file{.sh} 또는 @file{.pl} 파일을 지정할 수도 있습니다. 이는 @env{R_HOME}, @env{R_OSTYPE}, @env{PATH}, @env{BSTINPUTS}, @env{TEXINPUTS}를 포함한 적절한 환경 변수가 설정된 상태에서 적절한 인터프리터(예: @file{.pl}에 대해 Perl)에서 실행됩니다. 예를 들어, 이미 @file{latex.exe}가 경로에 있는 경우,

@example
R CMD latex.exe mydoc
@end example
@noindent
@R{}의 @file{share/texmf} 매크로에 대한 경로가 @env{TEXINPUTS}에 추가되어 @file{mydoc.tex}에서 @LaTeX{}를 실행합니다. (불행하게도, 이는 MiKTeX 빌드의 @LaTeX{}에서 도움이 되지 않지만, 그 경우에는 @command{R CMD texify mydoc}가 작동합니다.)

@node macOS에서 R 실행하기, R로 스크립팅하기, Windows에서 R 실행하기, R 실행하기
@appendixsec macOS에서 R 실행하기

macOS에서 @R{}을 실행하는 방법은 두 가지가 있습니다. @code{Terminal.app} 창에서 @code{R}을 호출하여 첫 번째 하위 섹션에서 설명한 방법을 사용할 수 있습니다. 또한 시스템의 @code{Applications} 폴더에 기본적으로 설치되어 있는 콘솔 기반 GUI (@code{R.app})도 있습니다. 이는 일반적인 더블 클릭 가능한 macOS 애플리케이션입니다.

macOS에서의 시작 절차는 UNIX에서의 시작 절차와 매우 유사하지만, @code{R.app}은 명령줄 인수를 사용하지 않습니다. `홈 디렉토리'는 R.framework 내부의 디렉토리이지만, 시작 및 현재 작업 디렉토리는 GUI 내에서 접근 가능한 기본 설정 창에서 다른 시작 디렉토리가 주어지지 않는 한 사용자의 홈 디렉토리로 설정됩니다.

@node R로 스크립팅하기,  , macOS에서 R 실행하기, R 실행하기
@appendixsec R로 스크립팅하기

@R{} 명령어가 있는 @file{foo.R} 파일만 실행하려면 @command{R CMD BATCH foo.R}을 사용하는 것이 좋습니다. 백그라운드에서 실행하거나 배치 작업으로 실행하려면 OS별 기능을 사용하세요. 예를 들어, Unix와 유사한 OS의 대부분의 셸에서 @command{R CMD BATCH foo.R &}는 백그라운드 작업을 실행합니다.

명령 줄에서 추가 인수를 통해 스크립트에 매개 변수를 전달할 수 있습니다. 예를 들어 (사용 중인 셸에 따라 필요한 정확한 따옴표가 달라집니다)

@example
R CMD BATCH "--args arg1 arg2" foo.R &
@end example

@noindent
위의 예시는 다음과 같이 문자 벡터로 검색할 수 있는 인수를 스크립트에 전달합니다.

@example
args <- commandArgs(TRUE)
@end example

이것은 대체 프론트엔드 @command{Rscript}에 의해 더 간단하게 만들어집니다. 다음과 같이 호출할 수 있습니다.

@example
Rscript foo.R arg1 arg2
@end example

@noindent
그리고 이것은 실행 가능한 스크립트 파일을 작성하는 데 사용될 수 있습니다. (적어도 Unix와 유사한 시스템에서, 그리고 일부 Windows 셸에서)

@example
#! /path/to/Rscript
args <- commandArgs(TRUE)
...
q(status=<exit status code>)
@end example

@noindent
이것이 텍스트 파일 @file{runfoo}에 입력되고 실행 가능하게 만들어지면 (예를 들어, @command{chmod 755 runfoo}), 다른 인수에 대해 호출할 수 있습니다.

@example
runfoo arg1 arg2
@end example

@noindent
추가 옵션은 @command{help("Rscript")}를 참조하세요. 이것은 @R{} 출력을 @file{stdout} 및 @file{stderr}에 작성하며, 명령을 실행하는 셸에 대한 일반적인 방법으로 리디렉션할 수 있습니다.

@command{Rscript} 경로를 하드코딩하고 싶지 않고 경로에 포함하려는 경우(일반적으로 설치된 @R{}에서는 Windows를 제외한 경우가 그렇지만 예를 들어 macOS 사용자는 @file{/usr/local/bin}을 경로에 추가해야 할 수도 있습니다),

@example
#! /usr/bin/env Rscript
...
@end example

@noindent
Bourne 및 bash 셸에서는 적어도 @code{#!} 메커니즘이 @code{#! /usr/bin/env Rscript --vanilla}와 같은 추가 인수를 허용하지 @strong{않습니다}.

고려해야 할 한 가지는 @code{stdin()}이 무엇을 참조하는지입니다. 다음과 같은 부분을 포함한 @R{} 스크립트를 작성하는 것이 일반적입니다.

@example
chem <- scan(n=24)
2.90 3.10 3.40 3.40 3.70 3.70 2.80 2.50 2.40 2.40 2.70 2.20
5.28 3.37 3.03 3.03 28.95 3.77 3.40 2.20 3.50 3.60 3.70 3.70
@end example

@noindent
그리고 @code{stdin()}은 이러한 전통적인 사용법을 허용하기 위해 스크립트 파일을 참조합니다. 프로세스의 @file{stdin}을 참조하려면 @code{file} 연결로 @code{"stdin"}을 사용하십시오. 예를 들어, @code{scan("stdin", ...)}.

실행 가능한 스크립트 파일을 작성하는 또 다른 방법(Fran@,{c}ois Pinard가 제안한 방법)은 다음과 같은 @emph{여기 문서}를 사용하는 것입니다.

@example
#!/bin/sh
[여기에 환경 변수를 설정할 수 있습니다]
R --no-echo [기타 옵션] <<EOF

   여기에 R 프로그램이 들어갑니다...

EOF
@end example

@noindent
그러나 여기서 @code{stdin()}은 프로그램 소스를 참조하며 @code{"stdin"}은 사용할 수 없습니다.

짧은 스크립트는 @option{-e} 플래그를 @emph{통해} 명령행에서 @command{Rscript}에 전달할 수 있습니다. (빈 스크립트는 허용되지 않습니다.)

Unix와 유사한 시스템에서 입력 파일명(예: @file{foo.R})은 공백이나 셸 메타문자를 포함해서는 안 됩니다.


@node 명령행 편집기, 함수 및 변수 색인, R 실행하기, 상위
@appendix 명령행 편집기

@appendixsection 사전 준비 사항

@acronym{GNU} @strong{readline} 라이브러리가 UNIX에서 @R{}을 컴파일하는 데 사용되는 시점에 사용 가능한 경우, 이전 명령의 호출, 편집 및 재제출을 허용하는 내장 명령 행 편집기가 사용됩니다. 다른 버전의 @strong{readline}이 있을 수 있으며 내장 명령 행 편집기에서 사용할 수 있습니다. macOS에서 가장 일반적입니다. @R{} 세션에서 @code{extSoftVersion()}을 실행하여 사용 가능한 버전(있는 경우)을 확인할 수 있습니다.

@acronym{ESS} @footnote{`Emacs Speaks Statistics' 패키지; @acronym{URL} @uref{https://ESS.R-project.org/} 참조하세요.}와 함께 사용할 때 시작 옵션 @option{--no-readline}을 사용하여 비활성화할 수 있습니다.

Windows 버전의 @R{}은 명령 행 편집이 좀 더 단순합니다. @acronym{GUI}의 @samp{도움말} 메뉴에서 @samp{콘솔}을 참조하고, @code{Rterm.exe}에서 명령 행 편집을 위한 @file{README.Rterm} 파일을 참조하십시오.

GNU@footnote{@R{}을 빌드할 때 NetBSD의 @strong{editline} (또는 @strong{libedit}라고도 함)을 기반으로 한 GNU @strong{readline} 에뮬레이션과 같은 것을 사용하는 경우, 제공되는 기능이 일부로 제한될 수 있습니다.} @strong{readline} 기능을 사용하여 @R{}을 사용할 때 아래에서 설명하는 함수뿐만 아니라 시스템에서 @command{man readline} 또는 @command{info readline}에 문서화된 다른 함수(아마도)도 사용할 수 있습니다.

이들 중 많은 것들이 Control 또는 Meta 문자를 사용합니다. Control 문자는 @kbd{Control-m}와 같이, @key{CTRL} 키를 누른 채로 @key{m} 키를 누르면 얻을 수 있으며 아래에서 @kbd{C-m}으로 작성됩니다. Meta 문자는 @kbd{Meta-b}와 같이, @key{META}@footnote{PC 키보드에서는 일반적으로 Alt 키이며, 때로는 'Windows' 키입니다. 맥 키보드에서는 일반적으로 메타 키가 사용되지 않습니다.}를 누른 채로 @key{b}를 눌러 입력하며, 다음과 같이 @kbd{M-b}로 작성됩니다. 터미널에 @key{META} 키가 활성화되어 있지 않아도 @kbd{ESC}로 시작하는 두 글자의 문자열을 사용하여 Meta 문자를 입력할 수 있습니다. 따라서 @kbd{M-b}를 입력하려면 @key{ESC}@key{b}를 입력할 수 있습니다. 실제 Meta 키가 있는 터미널에서도 @kbd{ESC} 문자열이 허용됩니다. Meta 문자의 경우 대소문자가 중요하다는 점에 유의하세요.

일부 버전의 @strong{readline}@footnote{특히 버전 6.3 이후의 경우는 아니며, @R{} 3.4.0부터 이 문제를 해결했습니다.}에서는 터미널 창의 크기 조절을 인식하지만, 모든 버전에서 인식하지는 않으므로 피하는 것이 좋습니다.

@appendixsection 편집 동작

@R{} 프로그램은 입력한 명령 행의 기록을 유지하며, 오류가 있는 행을 포함하여 기록에 있는 명령을 다시 호출, 필요한 경우 변경하고 새 명령으로 다시 제출할 수 있습니다. Emacs 스타일의 명령 행 편집에서는 편집 단계에서 입력한 모든 문자가 편집 중인 명령에 삽입되어 커서 오른쪽의 문자를 밀어낼 수 있습니다. @emph{vi} 모드에서는 @kbd{M-i} 또는 @kbd{M-a}로 문자 삽입 모드를 시작하고, 문자를 입력한 후 추가적인 @key{ESC}를 입력하여 삽입 모드를 종료합니다. (기본값은 Emacs 스타일이며, 여기에서는 그것만 설명합니다. @emph{vi} 모드에 대해서는 @strong{readline} 문서를 참조하십시오.)

언제든지 @key{RET} 명령을 누르면 명령이 다시 제출됩니다.

다른 편집 동작은 다음 표에 요약되어 있습니다.

@appendixsection 명령 행 편집기 요약

@subheading 명령 호출 및 수직 이동

@table @kbd
@item C-p
이전 명령으로 이동합니다 (기록에서 뒤로).
@item C-n
다음 명령으로 이동합니다 (기록에서 앞으로).
@item C-r @var{text}
@var{text} 문자열이 포함된 마지막 명령을 찾습니다. 이 작업은 @code{C-g} (그리고 @R{}의 일부 버전에서는 @code{C-c})로 취소할 수 있습니다.
@end table

대부분의 터미널에서는 @kbd{C-p}와 @kbd{C-n} 대신 위쪽 화살표 키와 아래쪽 화살표 키를 사용할 수도 있습니다.

@subheading 커서의 수평 이동

@table @kbd
@item C-a
명령의 시작 부분으로 이동합니다.
@item C-e
행의 끝으로 이동합니다.
@item M-b
한 단어 뒤로 이동합니다.
@item M-f
한 단어 앞으로 이동합니다.
@item C-b
한 문자 뒤로 이동합니다.
@item C-f
한 문자 앞으로 이동합니다.
@end table

대부분의 터미널에서는 @kbd{C-b}와 @kbd{C-f} 대신 왼쪽 화살표 키와 오른쪽 화살표 키를 사용할 수도 있습니다.

@subheading 편집 및 재제출

@table @kbd
@item @var{text}
커서 위치에 @var{text}를 삽입합니다.
@item C-f @var{text}
커서 뒤에 @var{text}를 추가합니다.
@item @key{DEL}
이전 문자를 삭제합니다 (커서의 왼쪽).
@item C-d
커서 아래의 문자를 삭제합니다.
@item M-d
커서 아래의 단어의 나머지 부분을 삭제하고 "저장"합니다.
@item C-k
커서로부터 명령 끝까지 삭제하고 "저장"합니다.
@item C-y
여기에 마지막으로 "저장된" 텍스트를 삽입(끌어오기)합니다.
@item C-t
커서 아래의 문자와 다음 문자를 바꿉니다.
@item M-l
단어의 나머지 부분을 소문자로 변경합니다.
@item M-c
단어의 나머지 부분을 대문자로 변경합니다.
@item @key{RET}
명령을 @R{}에 다시 제출합니다.
@end table

마지막 @key{RET}은 명령 행 편집 시퀀스를 종료합니다.

@strong{readline} 키 바인딩은 일반적인 방법으로 @file{~/.inputrc} 파일을 통해 사용자 정의할 수 있습니다. 이러한 사용자 정의는 애플리케이션 @code{R}에 따라 설정될 수 있습니다. 예를 들어 다음과 같은 섹션을 포함시킵니다.

@example
$if R
  "\C-xd": "q('no')\n"
$endif
@end example

@node 함수 및 변수 색인, 개념 색인, 명령행 편집기, 상위
@appendix 함수 및 변수 색인

@printindex vr

@node 개념 색인, 참조, 함수 및 변수 색인, 상위
@appendix 개념 색인

@printindex cp

@node 참조,  , 개념 색인, 상위
@appendix 참조

D.@: M.@: Bates and  D.@: G.@: Watts (1988), @emph{Nonlinear Regression
Analysis and Its Applications.} John Wiley & Sons, New York.

@noindent
Richard A.@: Becker, John M.@: Chambers and Allan R.@: Wilks (1988),
@emph{The New S Language.} Chapman & Hall, New York.
This book is often called the ``@emph{Blue Book}''.

@noindent
John M.@: Chambers and Trevor J.@: Hastie eds. (1992),
@emph{Statistical Models in S.} Chapman & Hall, New York.
This is also called the ``@emph{White Book}''.

@noindent
John M.@: Chambers (1998)
@emph{Programming with Data}. Springer, New York.
This is also called the ``@emph{Green Book}''.

@noindent
A.@: C.@: Davison and D.@: V.@: Hinkley (1997), @emph{Bootstrap Methods
and Their Applications}, Cambridge University Press.

@noindent
Annette J.@: Dobson (1990), @emph{An Introduction to Generalized Linear
Models}, Chapman and Hall, London.

@noindent
Peter McCullagh and John A.@: Nelder (1989), @emph{Generalized Linear
Models.} Second edition, Chapman and Hall, London.

@noindent
John A.@ Rice (1995), @emph{Mathematical Statistics and Data Analysis.}
Second edition.  Duxbury Press, Belmont, CA.

@noindent
S.@: D.@: Silvey (1970), @emph{Statistical Inference.} Penguin, London.

@bye
