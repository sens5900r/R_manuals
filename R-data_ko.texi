\input texinfo
@c %**start of header
@documentencoding utf-8
@setfilename R-data.info
@settitle R 데이터 가져오기/내보내기
@setchapternewpage on
@c %**end of header

@syncodeindex fn vr

@dircategory 프로그래밍
@direntry
* R Data: (R-data).      R 데이터 가져오기/내보내기.
@end direntry

@finalout

@include R-defs.texi
@include version.texi

@copying
이 매뉴얼은 R, 버전 @value{VERSION}을 위한 것입니다.

@Rcopyright{2000}

@quotation
@permission{}
@end quotation
@end copying

@titlepage
@title R 데이터 가져오기/내보내기
@subtitle 버전 @value{VERSION}
@author R 코어 팀
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifplaintext
@insertcopying
@end ifplaintext

@c @ifnothtml
@contents
@c @end ifnothtml

@ifnottex
@node 상위, 감사의 말, (dir), (dir)
@top R 데이터 가져오기/내보내기

이 문서는 R에서 데이터를 가져오고 내보내는 방법을 안내합니다.

@insertcopying

@end ifnottex

@menu
* 감사의 말::            
* 소개::                
* 스프레드시트와 유사한 데이터::       
* 다른 통계 시스템에서 가져오기::  
* 관계형 데이터베이스::        
* 이진 파일::                
* 이미지 파일::                 
* 연결::                 
* 네트워크 인터페이스::          
* Excel 스프레드시트 읽기::  
* 참조::                  
* 함수 및 변수 색인::  
* 개념 색인::               
@end menu

@node 감사의 말, 소개, 상위, 상위
@unnumbered 감사의 말

이 매뉴얼의 관계형 데이터베이스 부분은 일부가 Douglas Bates와 Saikat DebRoy가 작성한 이전 매뉴얼을 기반으로 합니다. 이 매뉴얼의 주요 저자는 Brian Ripley입니다.

이곳에 사용된 패키지에는 많은 자원봉사자들이 기여했습니다. 언급된 패키지의 주요 저자들은 다음과 같습니다.

@quotation
@table @asis
@item @CRANpkg{DBI}:
David A. James

@item @CRANpkg{dataframes2xls}:
Guido van Steen

@item @CRANpkg{foreign}:
Thomas Lumley, Saikat DebRoy, Douglas Bates, Duncan Murdoch와 Roger Bivand

@item @CRANpkg{gdata}:
Gregory R. Warnes

@item @CRANpkg{ncdf4}:
David Pierce

@item @CRANpkg{rJava}:
Simon Urbanek

@item @CRANpkg{RJDBC}:
Simon Urbanek

@item @CRANpkg{RMySQL}:
David James와 Saikat DebRoy

@item @CRANpkg{RNetCDF}:
Pavel Michna

@item @CRANpkg{RODBC}:
Michael Lapsley와 Brian Ripley

@item @CRANpkg{ROracle}:
David A. James

@item @CRANpkg{RPostgreSQL}:
Sameer Kumar Prayaga와 Tomoaki Nishiyama

@item @pkg{RSPerl}:
Duncan Temple Lang

@item @pkg{RSPython}:
Duncan Temple Lang

@item @CRANpkg{RSQLite}:
David A. James

@item @pkg{SJava}:
John Chambers와 Duncan Temple Lang

@item @CRANpkg{WriteXLS}:
Marc Schwartz

@item @CRANpkg{XLConnect}:
Mirai Solutions GmbH

@item @CRANpkg{XML}:
Duncan Temple Lang
@end table
@end quotation

Brian Ripley는 연결 지원의 저자입니다.


@node 소개, 스프레드시트와 유사한 데이터, 감사의 말, 상위
@chapter 소개

통계 시스템에 데이터를 읽어 분석하고 결과를 다른 시스템에 보고서 작성을 위해 내보내는 작업은 통계 분석 자체보다 훨씬 더 많은 시간이 소요되는 골치 아픈 작업일 수 있습니다. 대부분의 독자들은 후자가 훨씬 더 매력적으로 느낄 것입니다.

이 매뉴얼에서는 @R{} 자체 또는 @acronym{CRAN} 또는 다른 곳에서 사용할 수 있는 패키지를 통해 이용할 수 있는 가져오기 및 내보내기 기능을 설명합니다.

별도로 명시되지 않는 한, 이 매뉴얼에서 설명하는 모든 내용은 원칙적으로 @R{}이 실행되는 모든 플랫폼에서 사용할 수 있습니다.

일반적으로 통계 시스템인 @R{}은 대규모 데이터 조작에 특별히 적합하지 않습니다. @R{}보다 이런 작업을 더 잘 수행하는 다른 시스템이 있으며, 이 매뉴얼의 일부 목적은 @R{}에서 기능을 중복하는 대신 다른 시스템에서 작업을 수행하게 할 것을 제안하는 것입니다! (예를 들어 Therneau & Grambsch (2000)는 데이터 조작을 SAS에서 수행한 다음 @Sl{}에서 @CRANpkg{survival} 패키지를 사용하여 분석하는 것을 선호한다고 언급했습니다.) 데이터베이스 조작 시스템은 데이터 조작 및 추출에 매우 적합한 경우가 많으며, 여기에서 DBMS와 상호 작용하는 여러 패키지가 논의됩니다.

@code{Java}, @code{perl}, @code{python}과 같은 언어로 개발된 기능을 @R{} 코드와 직접 통합할 수 있도록 하는 패키지들이 있어, 이러한 언어의 기능을 더욱 적절하게 사용할 수 있습니다. (@acronym{CRAN}에서 제공하는 @CRANpkg{rJava} 패키지를 참조하십시오.)
@c 그리고 @pkg{SJava}, @pkg{RSPerl}, @pkg{RSPython} 패키지는 Omegahat 프로젝트에서 제공되며, @uref{http://www.omegahat.net}에서 확인할 수 있습니다.


@cindex 유닉스 도구
@cindex awk
@cindex perl
@R{}은 @Sl{}처럼 작고 재사용 가능한 도구의 유닉스 전통에서 비롯되었음을 기억하는 것도 중요하며, 데이터를 가져오기 전이나 내보내기 후에 @code{awk}나 @code{perl}과 같은 도구를 사용하는 것이 도움이 될 수 있습니다. Becker, Chambers & Wilks (1988, 9장)의 사례 연구는 이에 대한 예로, 유닉스 도구를 사용하여 @Sl{}에 입력하기 전에 데이터를 확인하고 조작했습니다. 전통적인 유닉스 도구는 이제 훨씬 더 널리 사용할 수 있으며, Windows를 포함하여 사용할 수 있습니다.

이 매뉴얼은 처음으로 2000년에 작성되었으며, 그 이후로 @R{} 패키지의 범위와 수는 백 배 이상 늘어났습니다. 특수한 데이터 형식의 경우 적합한 패키지가 이미 존재하는지 검색해 보는 것이 좋습니다.

@menu
* 가져오기::                     
* 텍스트 파일로 내보내기::        
* XML::                         
@end menu

@node 가져오기, 텍스트 파일로 내보내기, 소개, 소개
@section 가져오기
@findex 스캔

@R{}로 가져올 수 있는 가장 쉬운 형태의 데이터는 간단한 텍스트 파일이며, 이것은 종종 소규모 또는 중규모 문제에 적합합니다. 텍스트 파일에서 가져오는 주요 기능은 @code{scan}이며, 이는 @ref{스프레드시트와 유사한 데이터}에서 논의되는 더 편리한 기능의 기반이 됩니다.

그러나 모든 통계 컨설턴트들은 소유한 이진 형식의 데이터를 포함한 메모리 스틱(이전에는 플로피 디스크 또는 CD-R)을 고객에게 받는 것에 익숙합니다. 예를 들어 'Excel 스프레드시트' 또는 'SPSS 파일'입니다. 종종 가장 간단한 방법은 원래의 응용 프로그램을 사용하여 데이터를 텍스트 파일로 내보내는 것이며(통계 컨설턴트는 그 목적을 위해 컴퓨터에 가장 일반적인 응용 프로그램의 사본을 가지고 있습니다). 그러나 이것이 항상 가능한 것은 아니며, @ref{다른 통계 시스템에서 가져오기}에서는 @R{}에서 이러한 파일에 직접 액세스할 수 있는 기능에 대해 논의합니다. Excel 스프레드시트의 경우 사용 가능한 방법이 @ref{Excel 스프레드시트 읽기}에서 요약되어 있습니다.
@c Open
@c Office에서의 ODS 스프레드시트의 경우, Omegahat 패키지@footnote{현재 해당 저장소에서 사용할 수 없으며, @url{http://www.omegahat.net/ROpenOffice/}에서 소스 패키지를 다운로드할 수 있습니다.} @pkg{ROpenOffice}를 참조하십시오.

소수의 경우 데이터가 압축 및 액세스 속도를 위해 이진 형식으로 저장되어 있습니다. 우리가 여러 번 본 이러한 응용 프로그램 중 하나는 이미지 데이터로, 이는 일반적으로 메모리에서 표현된 바이트 스트림으로 저장되며, 헤더로 시작할 수도 있습니다. 이러한 데이터 형식은 @ref{이진 파일} 및 @ref{이진 연결}에서 논의됩니다.

훨씬 큰 데이터베이스의 경우 데이터베이스 관리 시스템(DBMS)을 사용하여 데이터를 처리하는 것이 일반적입니다. DBMS를 사용하여 일반 파일을 추출하는 옵션이 다시 한 번 있지만, 많은 DBMS의 경우 추출 작업을 @R{} 패키지에서 직접 수행할 수 있습니다: @xref{관계형 데이터베이스}. 네트워크 연결을 통한 데이터 가져오기는 @ref{네트워크 인터페이스}에서 논의됩니다.

@menu
* 인코딩::                   
@end menu

@node 인코딩,  , 가져오기, 가져오기
@subsection 인코딩
@cindex 인코딩

가져올 파일이 완전히 @acronym{ASCII}로 되어 있지 않은 경우, 인코딩 방식을 알아야 합니다. 텍스트 파일의 경우, 구조에 대해 알아보는 좋은 방법은 @command{file} 명령행 도구입니다(Windows의 경우 @code{Rtools}에 포함되어 있음). 이 도구는 다음과 같은 내용을 보고합니다.

@example
text.Rd: UTF-8 유니코드 영어 텍스트
text2.dat: ISO-8859 영어 텍스트
text3.dat: Little-endian UTF-16 유니코드 영어 문자 데이터,
   CRLF 줄 종료자와 함께
intro.dat: UTF-8 유니코드 텍스트
intro.dat: UTF-8 유니코드 (BOM 포함) 텍스트
@end example

@noindent
macOS를 포함한 현대의 유닉스와 유사한 시스템은 UTF-8 파일을 생성할 가능성이 높습니다. 윈도우는 '유니코드' 파일(@code{UCS-2LE} 또는 가끔 @code{UTF-16LE}@footnote{이 둘의 차이는 미묘하며, @uref{https://en.wikipedia.org/wiki/UTF-16/UCS-2}, 대리 쌍의 사용은 매우 드뭅니다.})이라고 부를 수 있습니다. 그렇지 않으면 대부분의 파일은 8비트 인코딩이 될 것입니다. 중국어/일본어/한국어 로케일에서는 일반적으로 사용되는 다양한 인코딩이 존재합니다. 어떤 8비트 인코딩인지 확실히 자동으로 감지하는 것은 불가능하며(추측이 가능하고 @command{file}이 위의 예에서와 같이 추측할 수도 있음), 원작자에게 몇 가지 단서를 요청해야 할 수도 있습니다(예: '윈도우에서의 러시아어').

`BOM'(Byte Order Mark, @uref{https://en.wikipedia.org/wiki/Byte_order_mark})은 유니코드 파일에 문제를 일으킵니다. 유닉스 세계에서는 BOM이 거의 사용되지 않지만, 윈도우 세계에서는 UCS-2/UTF-16 파일에 거의 항상 사용되며, 종종 UTF-8 파일에도 사용됩니다. @command{file} 유틸리티는 BOM이 없는 UCS-2 파일조차 인식하지 못하지만, 많은 다른 유틸리티는 BOM이 있는 파일을 읽지 않을 것이며, @acronym{IANA}의 @code{UTF-16LE} 및 @code{UTF-16BE} 표준은 이를 금지합니다. 우리는 종종 명령행 유틸리티 @command{od}나 16진수 편집기로 파일을 살펴보며 인코딩을 파악해야 했습니다.

@code{utf8}은 유효한 인코딩 이름이 아닙니다(@code{UTF-8}이 맞음), @code{macintosh}는 때때로 '맥 로마' 인코딩이라고 불리는 것에 대한 가장 이식성 있는 이름입니다.

@node 텍스트 파일로 내보내기, XML, 가져오기, 소개
@section 텍스트 파일로 내보내기
@cindex 텍스트 파일로 내보내기

@R{}에서 결과를 내보내는 것은 일반적으로 덜 논란이 되는 작업이지만, 여전히 여러 함정이 있습니다. 대상 응용 프로그램이 있을 것이며, 종종 텍스트 파일이 가장 편리한 교환 매체가 됩니다. (이진 파일이 필요한 경우, @ref{이진 파일}을 참조하십시오.)

@findex cat
함수 @code{cat}은 데이터를 내보내는 함수를 기반으로 합니다. 이 함수는 @code{file} 인수를 사용하며, @code{append} 인수를 사용하면 @code{cat}에 의한 연속 호출을 통해 텍스트 파일을 작성할 수 있습니다. 더 좋은 방법은, 특히 이 작업을 여러 번 수행해야 하는 경우, 쓰기 또는 추가를 위한 @code{file} 연결을 열고 해당 연결에 @code{cat}한 다음 @code{close}하는 것입니다.

@findex write
@findex write.table
가장 일반적인 작업은 행렬이나 데이터 프레임을 숫자의 직사각형 격자로 파일에 작성하는 것이며, 행과 열 레이블이 있을 수도 있습니다. 이 작업은 @code{write.table} 및 @code{write} 함수를 사용하여 수행할 수 있습니다. 함수 @code{write}는 지정된 열 수로 행렬이나 벡터를 그냥 작성하고 행렬을 전치합니다. 함수 @code{write.table}은 더 편리하며, 행과 열 레이블이 있는 데이터 프레임(또는 데이터 프레임으로 강제 변환할 수 있는 객체)을 작성합니다.

텍스트 파일에 데이터 프레임을 작성할 때 고려해야 할 몇 가지 문제가 있습니다.

@enumerate
@findex format
@item @strong{정밀도}

이러한 함수에 의해 수행되는 실수/복소수의 대부분의 변환은 전체 정밀도로 수행되지만, @code{write}에 의해 수행되는 변환은 현재 @code{options(digits)} 설정에 따라 결정됩니다. 더 많은 제어를 위해 데이터 프레임에서 @code{format}을 사용하고, 가능하면 열별로 사용하십시오.

@item @strong{헤더 행}

@R{}은 행 이름에 대한 항목이 없는 헤더 행을 선호하여 파일이 다음과 같이 보입니다.

@example
                dist    climb   time
Greenmantle     2.5     650     16.083
   ...
@end example

@noindent
다른 시스템 중 일부는 행 이름에 대한 항목(빈 항목일 수도 있음)이 필요하며, 인수 @code{col.names = NA}가 지정된 경우 @code{write.table}에서 제공합니다. 엑셀이 그러한 시스템 중 하나입니다.

@item @strong{구분자}
@cindex CSV 파일
@cindex 쉼표로 구분된 값
@findex write.csv
@findex write.csv2

파일에서 사용할 일반적인 필드 구분자는 쉼표이며, 이는 영어 사용 국가의 필드에 나타날 가능성이 적습니다. 이러한 파일은 CSV (쉼표로 구분된 값) 파일로 알려져 있으며, 래퍼 함수인 @code{write.csv}는 적절한 기본값을 제공합니다. 일부 로케일에서는 쉼표가 소수점으로 사용되며 (이는 @code{write.table}에서 @code{dec = ","}로 설정), 이때 CSV 파일은 필드 구분자로 세미콜론을 사용합니다. 적절한 기본값을 위해 @code{write.csv2}를 사용하십시오. CSV 파일에 대한 IETF 표준이 있지만(RFC4180, @uref{https://www.rfc-editor.org/rfc/rfc4180} 참조), 실제로 중요한 것은 해당 파일이 목표로 하는 애플리케이션에서 읽을 수 있는지 여부입니다.

세미콜론이나 탭(@code{sep = "\t"})을 사용하는 것이 가장 안전한 옵션일 것입니다.

@item @strong{결측값}
@cindex 결측값

기본적으로 결측값은 @code{NA}로 출력되지만, 인수 @code{na}를 통해 변경할 수 있습니다. @code{write.table}에서는 @code{NaN}이 @code{NA}로 처리되지만, @code{cat}이나 @code{write}에서는 그렇지 않습니다.

@item @strong{문자열 인용}
@cindex 문자열 인용

기본적으로 문자열은 인용됩니다(행과 열 이름 포함). 인수 @code{quote}는 문자와 팩터 변수가 인용되는지를 제어합니다. 예를 들어, @pkg{Mondrian} (@uref{https://en.wikipedia.org/wiki/Mondrian_(software)})과 같은 일부 프로그램은 인용된 문자열을 받아들이지 않습니다.

문자열에 포함된 따옴표에 주의가 필요합니다. 세 가지 유용한 형태는 다음과 같습니다.

@example
> df <- data.frame(a = I("a \" quote"))
> write.table(df)
"a"
"1" "a \" quote"
> write.table(df, qmethod = "double")
"a"
"1" "a "" quote"
> write.table(df, quote = FALSE, sep = ",")
a
1,a " quote
@end example

@noindent
두 번째 형태는 스프레드시트에서 일반적으로 사용되는 이스케이프 형태입니다.

@item @strong{인코딩}
@cindex 인코딩

텍스트 파일은 인코딩에 대한 메타데이터를 포함하지 않으므로, 비-@acronym{ASCII} 데이터의 경우 읽으려는 응용 프로그램을 목표로 파일을 설정해야 합니다. 이러한 함수는 모두 인코딩을 파일에 지정할 수 있는 @emph{연결}에 쓸 수 있으며, @code{write.table}에는 이를 쉽게 처리할 수 있는 @code{fileEncoding} 인수가 있습니다.

어떤 파일 인코딩을 사용해야 할지 결정하는 것이 어려운 일입니다. Windows에서 사용할 때는 Windows가 '유니코드'라고 부르는 것을 사용하는 것이 좋습니다@footnote{그렇더라도, Windows 애플리케이션은 @R{}에서 사용되는 @code{iconv} 구현에 따라 플랫폼에 따라 추가되거나 추가되지 않을 수 있는 바이트 순서 표시를 기대할 수 있습니다.}, 즉 @code{"UTF-16LE"}입니다. UTF-8을 사용하면 다른 인코딩과 쉽게 혼동되지 않을 이식성이 좋은 파일을 만들 수 있지만, macOS 애플리케이션(UTF-8이 시스템 인코딩인 경우)조차 인식하지 못할 수 있으며, Windows 애플리케이션은 거의 인식하지 못할 것입니다. 애플리케이션 Excel:mac 2004/8은 이전 버전의 Mac OS에서 사용된 인코딩인 @code{"macroman"} 인코딩의 @code{.csv} 파일을 기대했다고 합니다.

@end enumerate

@findex write.matrix
@CRANpkg{MASS} 패키지의 @code{write.matrix} 함수는 행렬을 작성하기 위한 전문 인터페이스를 제공하며, 블록으로 작성하여 메모리 사용량을 줄일 수 있는 옵션을 제공합니다.

@findex sink
@code{sink}를 사용하여 표준 @R{} 출력을 파일로 리디렉션하고, (암시적으로) @code{print} 문의 출력을 캡처할 수 있습니다. 이것은 보통 가장 효율적인 방법이 아니며, @code{options(width)} 설정을 늘려야 할 수도 있습니다.

@findex write.foreign
@CRANpkg{foreign} 패키지의 @code{write.foreign} 함수는 @code{write.table}을 사용하여 텍스트 파일을 작성하고, 이 텍스트 파일을 다른 통계 패키지로 읽어들일 코드 파일을 작성합니다. 현재 @code{SAS}, @code{SPSS}, @code{Stata}로 내보내기를 지원하고 있습니다.

@node XML,  , 텍스트 파일로 내보내기, 소개
@section XML
@cindex XML

텍스트 파일에서 데이터를 읽을 때 사용자의 책임은 해당 파일을 생성하는 데 사용된 관례를 알고 지정하는 것입니다. 예를 들어 주석 문자, 헤더 행이 있는지, 값 구분자, 누락된 값의 표현 등이 @ref{텍스트 파일로 내보내기}에 설명되어 있습니다. 내용뿐만 아니라 내용의 구조를 설명하는 데 사용할 수 있는 마크업 언어는 파일이 스스로 설명할 수 있게 만들어, 데이터를 읽는 소프트웨어에 이러한 세부 정보를 제공할 필요가 없습니다.

확장 가능한 마크업 언어인 @acronym{XML}(eXtensible Markup Language)은 표준 데이터셋뿐만 아니라 더 복잡한 데이터 구조에 대한 구조를 제공하는 데 사용할 수 있습니다. @acronym{XML}은 매우 인기있는 언어로서 일반 데이터 마크업 및 교환을 위한 표준으로 등장하고 있습니다. 지도와 같은 지리적 데이터, 그래픽 디스플레이, 수학 등을 설명하는 데 다양한 커뮤니티에서 사용되고 있습니다.

@acronym{XML}은 파일 인코딩을 지정하는 방법을 제공합니다. 예를 들어:

@example
<?xml version="1.0" encoding="UTF-8"?>
@end example

@noindent
그러나 이를 필수로 요구하지는 않습니다.

@CRANpkg{XML} 패키지는 @R{} 내에서 @acronym{XML} 문서를 읽고 쓰는 일반적인 기능을 제공합니다.
@c 이 문서의 범위를 벗어난 @CRANpkg{XML} 패키지의 기능에 대한 설명입니다. 자세한 내용과 예제는 패키지의 웹 페이지인 @uref{http://www.omegahat.net/RSXML}를 참조하십시오.
@acronym{CRAN}의 @CRANpkg{StatDataML} 패키지는 @CRANpkg{XML}을 기반으로 하는 한 예입니다. 패키지 @CRANpkg{xml2}는 @pkg{libxml2} C 라이브러리에 대한 또 다른 인터페이스를 제공합니다.

@cindex yaml
@acronym{yaml}은 텍스트 데이터 구조화를 위한 또 다른 시스템으로, 인간이 읽기 쉬운 것에 중점을 두고 있습니다. 이는 @CRANpkg{yaml} 패키지에서 지원됩니다.

@node 스프레드시트와 유사한 데이터, 다른 통계 시스템에서 가져오기, 소개, 상위
@chapter 스프레드시트와 유사한 데이터
@cindex 스프레드시트와 유사한 데이터

@menu
* read.table의 변형::    
* 고정 너비 형식 파일::    
* 데이터 교환 형식 (DIF)::  
* scan 직접 사용::         
* 데이터의 형태 변경::             
* 평면 교차표::     
@end menu

@ref{텍스트 파일로 내보내기}에서 데이터가 사각 격자에 나타나는 스프레드시트와 유사한 텍스트 파일 형식에 대한 여러 가지 변형을 살펴보았습니다. 이러한 파일을 @R{}로 가져오는 것을 이 섹션에서 고려합니다.

@node read.table의 변형, 고정 너비 형식 파일, 스프레드시트와 유사한 데이터, 스프레드시트와 유사한 데이터
@section @code{read.table}의 변형
@findex read.table

함수 @code{read.table}은 데이터의 사각 격자를 읽는 가장 편리한 방법입니다. 많은 가능성 때문에 @code{read.table}을 호출하지만 일련의 기본 인수를 변경하는 몇 가지 다른 함수가 있습니다.

@code{read.table}은 매우 큰 수치 행렬을 읽는 비효율적인 방법임에 유의하십시오. 아래의 @code{scan}을 참조하십시오.

고려해야 할 몇 가지 문제점은 다음과 같습니다:

@enumerate
@item @strong{인코딩}

파일에 비-@acronym{ASCII} 문자 필드가 포함되어 있는 경우, 올바른 인코딩으로 읽도록 합니다. 이것은 주로 UTF-8 로케일에서 라틴-1 파일을 읽는 문제이며, 다음과 같은 방법으로 수행할 수 있습니다.

@example
read.table("file.dat", fileEncoding="latin1")
@end example

@noindent
이것은 라틴-1 문자열을 나타낼 수 있는 모든 로케일에서 작동하지만, 그리스/러시아/중국/일본 @dots{} 로케일에서는 그렇지 않습니다.


@item @strong{헤더 라인}

@code{header} 인수를 명시적으로 지정하는 것이 좋습니다. 관례적으로 헤더 라인은 열에 대한 항목만 있으며 행 라벨에 대한 항목이 없어서 남은 라인보다 하나의 필드가 짧습니다. (만약 @R{}이 이것을 확인하면 @code{header = TRUE}로 설정합니다.) 행 라벨에 대한 (빈 값일 수 있는) 헤더 필드가 있는 파일을 다음과 같이 읽습니다.

@example
read.table("file.dat", header = TRUE, row.names = 1)
@end example

열 이름은 @code{col.names}을 통해 명시적으로 지정할 수 있습니다. 명시적인 이름은 헤더 라인을 무시합니다 (만약 존재한다면).

@item @strong{구분자}

일반적으로 파일을 살펴보면 사용할 필드 구분자를 결정할 수 있지만, 공백으로 구분된 파일의 경우 기본값인 @code{sep = ""}을 사용하여 공백(스페이스, 탭, 줄 바꿈)을 구분자로 사용할지, @code{sep = " "} 또는 @code{sep = "\t"}을 사용할지 선택해야 합니다. 구분자의 선택이 따옴표로 묶인 문자열의 입력에 영향을 미친다는 것에 유의하십시오.

비어 있는 필드가 있는 탭으로 구분된 파일이 있는 경우 반드시 @code{sep = "\t"}를 사용하십시오.


@item @strong{따옴표}
@cindex 문자열 따옴표

구분자 문자가 지정되지 않은 경우, 따옴표 내에서 따옴표를 C 스타일로 @samp{\}로 바로 앞에 두어 이스케이프할 수 있습니다.

구분자 문자가 지정된 경우, 따옴표가 두 배로 늘어난 스프레드시트에서 관례적으로 따옴표 내에서 따옴표를 이스케이프할 수 있습니다. 예를 들어,

@example
'하나의 문자열은 두 개가 아닙니다', "하나 더"
@end example

@noindent
는 다음과 같이 읽을 수 있습니다.

@example
read.table("testfile", sep = ",")
@end example

@noindent
기본 구분자로는 작동하지 않습니다.

@item @strong{누락된 값}
@cindex 누락된 값

기본적으로 파일은 누락된 값을 나타내기 위해 문자열 @code{NA}를 포함한다고 가정하지만, 이는 인수 @code{na.strings}를 사용하여 변경할 수 있습니다. 이는 누락된 값을 나타내는 하나 이상의 문자 표현을 포함하는 벡터입니다.

숫자 열의 빈 필드도 누락된 값으로 간주됩니다.

숫자 열에서는 @code{NaN}, @code{Inf} 및 @code{-Inf} 값이 허용됩니다.

@item @strong{채워지지 않은 줄}

스프레드시트에서 내보낸 파일에 종료되는 빈 필드(및 구분자)가 모두 생략되는 경우가 매우 흔합니다. 이러한 파일을 읽으려면 @code{fill = TRUE}를 설정하십시오.

@item @strong{문자 필드의 공백}

구분자가 지정된 경우 문자 필드의 앞뒤 공백은 필드의 일부로 간주됩니다. 공백을 제거하려면 인수 @code{strip.white = TRUE}를 사용하십시오.

@item @strong{빈 줄}

기본적으로 @code{read.table}은 빈 줄을 무시합니다. 이를 변경하려면 @code{blank.lines.skip = FALSE}를 설정하면 되는데, 이는 @code{fill = TRUE}와 함께 사용하여 규칙적인 레이아웃에서 누락된 경우를 나타내는 데 빈 행을 사용할 때 유용합니다.

@item @strong{변수의 클래스}

특별한 조치를 취하지 않으면 @code{read.table}은 모든 열을 문자 벡터로 읽고 데이터 프레임의 각 변수에 대해 적절한 클래스를 선택하려고 합니다. 차례로 @code{logical}, @code{integer}, @code{numeric} 및 @code{complex}를 시도하고, 모든 항목이 누락되지 않고 변환할 수 없는 경우 이동합니다.@footnote{첫 번째 항목을 보면 대부분의 가능성이 제외되므로 일반적으로 빠릅니다.} 이 모든 것이 실패하면 변수가 팩터로 변환됩니다.

인수 @code{colClasses}와 @code{as.is}는 더 큰 제어를 제공합니다. @code{as.is = TRUE}를 지정하면 문자 벡터를 팩터로 변환하는 것만 억제합니다. @code{colClasses}를 사용하면 입력의 각 열에 대해 원하는 클래스를 설정할 수 있으며, 속도가 빠르고 메모리 사용량이 적습니다.

@code{colClasses}와 @code{as.is}는 열 @emph{당} 지정되며 변수 @emph{당} 지정되지 않으므로 행 이름 열(있는 경우)도 포함됩니다.

@item @strong{주석}

기본적으로 @code{read.table}은 @samp{#}을 주석 문자로 사용하며, 이를 발견하면(따옴표로 묶인 문자열 제외) 해당 줄의 나머지 부분이 무시됩니다. 공백과 주석만 포함된 줄은 빈 줄로 취급됩니다.

데이터 파일에 주석이 없을 것이라고 알려진 경우, @code{comment.char = ""}를 사용하는 것이 더 안전하고(또는 더 빠를 수 있습니다).

@item @strong{이스케이프}

많은 운영체제에서는 텍스트 파일에서 백슬래시를 이스케이프 문자로 사용하는 규칙이 있지만, Windows에서는 그렇지 않습니다(Windows에서는 경로 이름에 백슬래시를 사용합니다). 이러한 규칙이 데이터 파일에 적용되는지 여부는 @R{}에서 선택 사항입니다.

@code{read.table}과 @code{scan}은 논리 인수 @code{allowEscapes}를 가집니다. 이것은 기본적으로 거짓이며, 그런 다음 백슬래시는 위에서 설명한 상황에서 따옴표를 이스케이프하는 것으로만 해석됩니다. 이를 true로 설정하면 C 스타일 이스케이프가 해석되며, 제어 문자 @code{\a, \b, \f, \n, \r, \t, \v} 및 8진수와 16진수 표현식(예: @code{\040} 및 @code{\0x2A})이 포함됩니다. 다른 이스케이프된 문자는 그 자체로 취급되며, 백슬래시 포함입니다. 유니코드 이스케이프인 @code{\u@var{xxxx}}는 절대로 해석되지 않는다는 점에 유의하십시오.

@item @strong{인코딩}

이는 @code{fileEncoding} 인수로 지정할 수 있으며, 예를 들어 다음과 같습니다.

@example
fileEncoding = "UCS-2LE"    # Windows '유니코드' 파일
fileEncoding = "UTF-8"
@end example

@noindent
파일의 인코딩을 정확하게 알고 있다면 거의 항상 작동할 것입니다. 그러나, BOM이 있는 UTF-8 파일과 같은 한 가지 예외가 있습니다. 일부 사람들은 UTF-8 파일에는 절대 BOM이 없어야 한다고 주장하지만, 일부 소프트웨어(맥용 엑셀을 포함한 것으로 보임)는 그것을 사용하고 많은 유닉스와 비슷한 운영체제는 그것을 받아들이지 않습니다. 따라서 @command{file}에서 다음과 같이 보고되는 파일이 있는 경우

@example
intro.dat: UTF-8 Unicode (with BOM) text
@end example

@noindent
Windows에서는 다음과 같이 읽을 수 있습니다.

@example
read.table("intro.dat", fileEncoding = "UTF-8")
@end example

@noindent
그러나 유닉스와 비슷한 환경에서는 아래와 같이 필요할 수 있습니다.

@example
read.table("intro.dat", fileEncoding = "UTF-8-BOM")
@end example

@noindent
(UTF-8 로케일에서 인코딩을 지정하지 않고도 아마도 작동할 가능성이 높습니다.)

@c 이 (실제) 예제에서 또 다른 문제는 @command{file-5.03}에서 BOM을 보고했지만, OS
@c 10.5 (Leopard)에서 발견된 @command{file-4.17}은 그렇지 않았다는 점입니다.
@end enumerate

@findex read.csv
@findex read.csv2
@findex read.delim
@findex read.delim2
@cindex CSV 파일
@findex Sys.localeconv
@cindex 로케일
편의 함수인 @code{read.csv}와 @code{read.delim}은 영어 사용 지역의 스프레드시트에서 내보낸 CSV 및 탭으로 구분된 파일에 적합한 @code{read.table} 인수를 제공합니다. @code{read.csv2}와 @code{read.delim2} 변형은 쉼표가 소수점을 나타내는 로케일에서 사용하기에 적합하며 (read.csv2의 경우) 필드를 구분하기 위해 세미콜론을 사용하는 스프레드시트에 적합합니다.

@code{read.table}의 옵션이 잘못 지정된 경우, 오류 메시지는 일반적으로 다음과 같은 형태입니다.

@example
Error in scan(file = file, what = what, sep = sep, : 
        line 1 did not have 5 elements
@end example

@noindent
또는

@example
Error in read.table("files.dat", header = TRUE) : 
        more columns than column names
@end example

@findex count.fields

@noindent
이 정보는 문제를 찾는 데 충분할 수 있지만, 보조 함수인 @code{count.fields}를 사용하여 더 조사할 수 있습니다.

큰 데이터 그리드를 읽을 때 효율성이 중요할 수 있습니다. @code{comment.char = ""}, 각 열의 원자 벡터 유형(logical, integer, numeric, complex, character 또는 아마도 raw) 중 하나인 @code{colClasses}을 지정하고, 읽을 행 수인 @code{nrows}를 제공하면 도움이 됩니다(이를 전혀 지정하지 않는 것보다 약간 과장된 추정치가 더 낫습니다). 이후 섹션의 예제를 참조하십시오.


@node 고정 너비 형식 파일, 데이터 교환 형식 (DIF), read.table의 변형, 스프레드시트와 유사한 데이터
@section 고정 너비 형식 파일
@cindex 고정 너비 형식 파일

때로는 데이터 파일에 필드 구분자가 없고 미리 지정된 열에 필드가 있습니다. 이는 펀치카드 시대에 매우 일반적이었으며, 여전히 파일 공간을 절약하기 위해 사용되기도 합니다.

@findex read.fwf
함수 @code{read.fwf}는 필드 너비의 벡터를 지정하여 이러한 파일을 읽는 간단한 방법을 제공합니다. 함수는 파일을 메모리에 전체 줄로 읽어들인 후 결과 문자열을 분할하고 임시 탭으로 구분된 파일을 작성한 다음 @code{read.table}을 호출합니다. 이것은 작은 파일에 적합하지만, 더 복잡한 경우에는 @code{perl}과 같은 언어의 기능을 사용하여 파일을 사전 처리하는 것을 권장합니다.
@cindex perl


@findex read.fortran
함수 @code{read.fortran}은 고정 형식 파일을 위한 유사한 함수로, 포트란 스타일 열 명세를 사용합니다.

@node 데이터 교환 형식 (DIF), scan 직접 사용, 고정 너비 형식 파일, 스프레드시트와 유사한 데이터
@section 데이터 교환 형식 (DIF)
@cindex 데이터 교환 형식 (DIF)

스프레드시트와 유사한 데이터에 사용되기도 하는 오래된 형식은 DIF 또는 데이터 교환 형식입니다.

@findex read.DIF
함수 @code{read.DIF}는 이러한 파일을 읽는 간단한 방법을 제공합니다. 각 열에 유형을 할당하기 위해 @code{read.table}과 유사한 인수를 사용합니다.

Windows에서는 스프레드시트 프로그램이 클립보드에 복사된 스프레드시트 데이터를 이 형식으로 저장하는 경우가 많습니다. @code{read.DIF("clipboard")}는 클립보드에서 직접 읽을 수 있습니다. 비어있는 셀이 있는 스프레드시트를 처리하는 데 있어서 @code{read.table("clipboard")}보다 약간 더 견고합니다.

@node scan 직접 사용, 데이터의 형태 변경, 데이터 교환 형식 (DIF), 스프레드시트와 유사한 데이터
@section @code{scan} 직접 사용
@findex scan

@code{read.table}과 @code{read.fwf}는 파일을 읽기 위해 @code{scan}을 사용한 다음 @code{scan}의 결과를 처리합니다. 이들은 매우 편리하지만, 때로는 @code{scan}을 직접 사용하는 것이 더 좋습니다.

함수 @code{scan}은 많은 인수를 가지고 있으며, 대부분은 이미 @code{read.table}에서 다루었습니다. 가장 중요한 인수는 파일에서 읽을 변수의 모드 목록을 지정하는 @code{what}입니다. 목록에 이름이 지정되면 반환된 목록의 구성 요소에 해당 이름이 사용됩니다. 모드는 숫자, 문자 또는 복소수일 수 있으며, 일반적으로 예를 들어 @code{0}, @code{""} 또는 @code{0i}로 지정됩니다. 예를 들면

@example
cat("2 3 5 7", "11 13 17 19", file="ex.dat", sep="\n")
scan(file="ex.dat", what=list(x=0, y="", z=0), flush=TRUE)
@end example

@noindent
파일의 네 번째 열을 버리고 세 개의 구성 요소가 있는 목록을 반환합니다.

@findex readLines
전체 줄을 읽어서 @R{}에서 추가 처리를 위해 사용하려는 경우, @code{readLines} 함수가 더 편리할 것입니다.

@code{scan}의 일반적인 사용 사례 중 하나는 큰 행렬을 읽어들이는 것입니다. 파일 @file{matrix.dat}에 200 x 2000 행렬의 숫자만 포함되어 있다고 가정해 봅시다. 그런 다음 다음을 사용할 수 있습니다.
@c write.table(matrix(rnorm(200*2000), 200), "matrix.dat", row.names=F, col.names=F)

@example
A <- matrix(scan("matrix.dat", n = 200*2000), 200, 2000, byrow = TRUE)
@end example

@noindent
한 테스트에서 이 작업은 1초가 걸렸습니다 (Linux에서는 1초, 동일한 기기에서 Windows에서는 3초).

@example
A <- as.matrix(read.table("matrix.dat"))
@end example

@noindent
걸린 시간은 10초였고(그리고 더 많은 메모리가 필요했습니다),

@example
A <- as.matrix(read.table("matrix.dat", header = FALSE, nrows = 200,
                          comment.char = "", colClasses = "numeric"))
@end example

@noindent
걸린 시간은 7초였습니다. 차이는 거의 2000개의 별도의 짧은 열을 읽는 오버헤드 때문입니다. 열의 길이가 2000이면, @code{scan}은 9초가 걸렸고, 효율적으로 사용된 경우(@code{colClasses}를 지정하는 것이 특히 중요) @code{read.table}은 18초가 걸렸으며, 순진하게 사용된 경우 125초가 걸렸습니다.

타입과 데이터에 따라 타이밍이 달라질 수 있습니다.
백만 개의 고유한 정수를 읽는 것을 고려해 보십시오.
@example
writeLines(as.character((1+1e6):2e6), "ints.dat")
xi <- scan("ints.dat", what=integer(0), n=1e6)   # 0.77s
xn <- scan("ints.dat", what=numeric(0), n=1e6)   # 0.93s
xc <- scan("ints.dat", what=character(0), n=1e6) # 0.85s
xf <- as.factor(xc)                              # 2.2s
DF <- read.table("ints.dat")                     # 4.5s
@end example
@noindent
그리고 작은 코드 집합의 백만 개의 예제:
@example
code <- c("LMH", "SJC", "CHCH", "SPC", "SOM")
writeLines(sample(code, 1e6, replace=TRUE), "code.dat")
y <- scan("code.dat", what=character(0), n=1e6)  # 0.44s
yf <- as.factor(y)                               # 0.21s
DF <- read.table("code.dat")                     # 4.9s
DF <- read.table("code.dat", nrows=1e6)          # 3.6s
@end example

이러한 타이밍은 운영 체제(기본 읽기 작업에 대한 Windows 시간은 이 Linux 시간의 최소 두 배가 걸림)와 가비지 수집기의 정확한 상태에 크게 의존합니다.

@node 데이터의 형태 변경, 평면 교차표, scan 직접 사용, 스프레드시트와 유사한 데이터
@section 데이터의 형태 변경
@cindex 데이터의 형태 변경

스프레드시트 데이터가 때때로 각 주제에 대한 공변량과 그 주제에 대한 모든 관찰치를 제공하는 간결한 형식으로 있습니다. @R{}의 모델링 함수는 단일 열에 관측값이 필요합니다. 반복적인 MRI 뇌 측정 데이터의 다음 샘플을 고려해 보십시오.

@example
 Status   Age    V1     V2     V3    V4
      P 23646 45190  50333  55166 56271
     CC 26174 35535  38227  37911 41184
     CC 27723 25691  25712  26144 26398
     CC 27193 30949  29693  29754 30772
     CC 24370 50542  51966  54341 54273
     CC 28359 58591  58803  59435 61292
     CC 25136 45801  45389  47197 47126
@end example

@noindent
각 주제에 대해 최대 네 개의 측정치와 두 개의 공변량이 있습니다. 데이터는 @file{mr.csv} 파일로 Excel에서 내보냈습니다.

@findex stack
단일 응답을 제공하기 위해 이러한 데이터를 조작하는 데 도움이 되는 @code{stack}을 사용할 수 있습니다.

@example
zz <- read.csv("mr.csv", strip.white = TRUE)
zzz <- cbind(zz[gl(nrow(zz), 1, 4*nrow(zz)), 1:2], stack(zz[, 3:6]))
@end example

@noindent
결과는 다음과 같습니다.

@example
      Status   Age values ind
X1         P 23646  45190  V1
X2        CC 26174  35535  V1
X3        CC 27723  25691  V1
X4        CC 27193  30949  V1
X5        CC 24370  50542  V1
X6        CC 28359  58591  V1
X7        CC 25136  45801  V1
X11        P 23646  50333  V2
...
@end example

@findex unstack.
@code{unstack} 함수는 반대 방향으로 작동하며, 데이터를 내보내는 데 유용할 수 있습니다.

@findex reshape
이 작업을 수행하는 또 다른 방법은 다음과 같이 @code{reshape} 함수를 사용하는 것입니다.

@example
> reshape(zz, idvar="id",timevar="var",
  varying=list(c("V1","V2","V3","V4")),direction="long")
    Status   Age var    V1 id
1.1      P 23646   1 45190  1
2.1     CC 26174   1 35535  2
3.1     CC 27723   1 25691  3
4.1     CC 27193   1 30949  4
5.1     CC 24370   1 50542  5
6.1     CC 28359   1 58591  6
7.1     CC 25136   1 45801  7
1.2      P 23646   2 50333  1
2.2     CC 26174   2 38227  2
...
@end example

@code{reshape} 함수는 @code{stack}보다 더 복잡한 구문을 가지지만, 이 예제에서처럼 'long' 형식이 하나 이상의 열을 가진 데이터에 사용할 수 있습니다. @code{direction="wide"}를 사용하면, @code{reshape}은 반대로 변환 작업을 수행할 수도 있습니다.

일부 사람들은 @CRANpkg{reshape}, @CRANpkg{reshape2}, 그리고 @CRANpkg{plyr} 패키지의 도구를 선호합니다.

@node 평면 교차표,  , 데이터의 형태 변경, 스프레드시트와 유사한 데이터
@section 평면 교차표
@cindex 평면 교차표

배열 형태로 높은 차원의 contingency 테이블을 표시하는 것은 일반적으로 불편합니다. 범주형 데이터 분석에서는 이러한 정보가 종종 테두리가 있는 2차원 배열 형태로 표시되며, 선행하는 행과 열이 셀 수에 해당하는 인자 수준의 조합을 지정합니다. 이러한 행과 열은 일반적으로 레이블이 변경될 때만 표시되는 의미에서 "불규칙한" 것으로, 행은 위에서 아래로, 열은 왼쪽에서 오른쪽으로 읽는 분명한 관례가 있습니다. @R{}에서는 이러한 "flat" contingency 테이블을 @code{ftable}을 사용하여 생성할 수 있습니다.
@findex ftable
이는 적절한 print 방법이 있는 클래스 @code{"ftable"}의 객체를 생성합니다.

간단한 예로, @R{} 표준 데이터셋 @code{UCBAdmissions}을 고려해  보려고 합니다. 이 데이터셋은 1973년 UC 버클리 대학원에 지원한 학생들을 입학과 성별에 따라 분류한 결과로 얻어진 3차원 contingency 테이블입니다. 이 테이블은 1973년에 가장 큰 6개 학과로 분류됩니다.

@example
> data(UCBAdmissions)
> ftable(UCBAdmissions)
                Dept   A   B   C   D   E   F
Admit    Gender                             
Admitted Male        512 353 120 138  53  22
         Female       89  17 202 131  94  24
Rejected Male        313 207 205 279 138 351
         Female       19   8 391 244 299 317
@end example

@noindent
인쇄된 표현은 데이터를 3차원 배열로 표시하는 것보다 확실히 더 유용합니다.

파일에서 flat-like contingency 테이블을 읽는 데 사용되는 @code{read.ftable} 함수도 있습니다.
@findex read.ftable
이 함수는 행 및 열 변수 이름과 레벨 정보가 어떻게 표현되는지에 대한 변형을 처리하기 위한 추가 인수가 있습니다. @code{read.ftable}의 도움말 페이지에는 유용한 예제가 있습니다. flat 테이블은 @code{as.table}을 사용하여 배열 형식의 표준 contingency 테이블로 변환할 수 있습니다.

flat 테이블은 행 (또는 열) 레이블의 "불규칙한" 표시로 특징지어집니다. 행 변수의 전체 그리드 레벨이 주어지면 대신 @code{read.table}을 사용하여 데이터를 읽고, @code{xtabs}을 사용하여 이 데이터로부터 contingency 테이블을 만들어야 합니다.


@node 다른 통계 시스템에서 가져오기, 관계형 데이터베이스, 스프레드시트와 유사한 데이터, 상위
@chapter 다른 통계 시스템에서 가져오기
@cindex 다른 통계 시스템에서 가져오기

이 장에서는 다른 통계 시스템에서 작성된 이진 데이터 파일을 읽는 문제를 다룹니다. 원래 시스템을 사용할 수 없는 경우에는 이를 피하기 어려울 수 있습니다.

모든 경우에 해당하는 기능은 다른 시스템의 특정 버전(주로 2000년대 초반)의 데이터 파일에 대해 작성되었으며, 반드시 다른 시스템의 가장 최근 버전에 대해 업데이트되었다고 볼 수는 없습니다.

@menu
* EpiInfo Minitab SAS S-PLUS SPSS Stata Systat::  
* Octave::                      
@end menu

@node EpiInfo Minitab SAS S-PLUS SPSS Stata Systat, Octave, 다른 통계 시스템에서 가져오기, 다른 통계 시스템에서 가져오기
@section EpiInfo, Minitab, S-PLUS, SAS, SPSS, Stata, Systat

권장 패키지인 @CRANpkg{foreign}은 이러한 통계 시스템에서 생성된 파일에 대한 가져오기 기능을 제공하며, Stata로 내보내기를 할 수 있습니다. 경우에 따라 이러한 함수들은 @code{read.table}보다 훨씬 적은 메모리를 사용할 수 있습니다. @code{write.foreign} (참조: @ref{텍스트 파일로 내보내기})은 @code{SAS}, @code{SPSS}, @code{Stata}에 대한 내보내기 메커니즘을 제공합니다.

@cindex EpiInfo
@cindex EpiData
@findex read.epiinfo
EpiInfo 버전 5와 6은 데이터를 자기 기술적 고정 너비 텍스트 형식으로 저장합니다. @code{read.epiinfo}는 이러한 @file{.REC} 파일을 @R{} 데이터 프레임으로 읽어옵니다. EpiData 또한 이 형식의 데이터를 생성합니다.

@cindex Minitab
@findex read.mtp
함수 @code{read.mtp}는 'Minitab Portable Worksheet'를 가져옵니다. 이 함수는 워크시트의 구성 요소를 @R{} 목록으로 반환합니다.

@cindex SAS
@findex read.xport
함수 @code{read.xport}는 SAS Transport (XPORT) 형식의 파일을 읽고 데이터 프레임 목록을 반환합니다. SAS가 시스템에서 사용 가능한 경우, 함수 @code{read.ssd}를 사용하여 SAS 스크립트를 작성하고 실행하여 SAS 영구 데이터셋(@file{.ssd} 또는 @file{.sas7bdat})을 Transport 형식으로 저장할 수 있습니다. 그런 다음 @code{read.xport}를 호출하여 결과 파일을 읽습니다. (패키지 @CRANpkg{Hmisc}는 SAS를 실행하는 유사한 함수인 @code{sas.get}도 가지고 있습니다.)

@cindex S-PLUS
@findex read.S
@findex data.restore

함수 @code{read.S}는 (32비트) 유닉스 또는 윈도우에서 S-PLUS 3.x, 4.x 또는 2000에서 생성된 이진 객체를 읽을 수 있으며(다른 OS에서도 읽을 수 있음). 이 함수는 많은 @Sl{} 객체를 읽을 수 있지만 모든 것을 읽을 수는 없습니다. 특히 벡터, 행렬, 데이터 프레임 및 그것들을 포함하는 목록을 읽을 수 있습니다.

함수 @code{data.restore}는 S-PLUS 데이터 덤프(@code{data.dump}로 생성된)를 읽으며 동일한 제한이 적용됩니다(단, 알파 플랫폼에서 생성된 덤프도 읽을 수 있음). S-PLUS 5.x 이상에서 @code{data.dump(oldStyle=T)}로 작성된 데이터 덤프를 읽을 수 있어야 합니다.

S-PLUS에 접근할 수 있는 경우, 일반적으로 S-PLUS에서 객체를 @code{dump}하고 @R{}에서 덤프 파일을 @code{source}하는 것이 더 안정적입니다. S-PLUS 5.x 이상에서는 @code{dump(..., oldStyle=T)}를 사용해야 할 수도 있고, 매우 큰 객체를 읽을 때는 @code{source} 함수를 사용하는 것보다 덤프 파일을 배치 스크립트로 사용하는 것이 바람직할 수 있습니다.

@cindex SPSS
@cindex SPSS Data Entry
@findex read.spss
함수 @code{read.spss}는 @acronym{SPSS}의 'save' 및 'export' 명령으로 생성된 파일을 읽을 수 있습니다. 저장된 데이터 세트의 각 변수에 대한 한 개의 구성 요소를 포함하는 목록을 반환합니다. 값 레이블이 있는 @acronym{SPSS} 변수는 선택적으로 @R{} 요인으로 변환됩니다.

@acronym{SPSS} Data Entry는 데이터 입력 양식을 생성하는 응용 프로그램입니다. 기본적으로 @code{read.spss}가 처리할 수 없는 추가 형식 정보가 있는 데이터 파일을 생성하지만, 일반 @acronym{SPSS} 형식으로 데이터를 내보내는 것이 가능합니다.

일부 타사 응용 프로그램은 'SPSS 형식'의 데이터를 생성한다고 주장하지만 형식에 차이가 있을 수 있습니다. @code{read.spss}는 이러한 형식을 처리할 수도 있고 그렇지 않을 수도 있습니다.

@cindex Stata
@findex read.dta
@findex write.dta
Stata @file{.dta} 파일은 이진 파일 형식입니다. 버전 5부터 12까지의 Stata 파일은 함수 @code{read.dta}와 @code{write.dta}를 사용하여 읽고 쓸 수 있습니다. 값 레이블이 있는 Stata 변수는 선택적으로 @R{} 요인으로 변환(또는 거꾸로 변환)됩니다. Stata 버전 13 이후에 대해서는 @acronym{CRAN} 패키지 @CRANpkg{readstata13} 및 @CRANpkg{haven}을 참조하십시오.

@cindex Systat
@findex read.systat
@code{read.systat}은 Systat @code{SAVE} 파일 중 직사각형 데이터 파일(@code{mtype = 1})을 작은 엔디안 머신(예: Windows)에서 작성한 것을 읽을 수 있습니다. 이들은 확장자가 @file{.sys} 또는 (최근에는) @file{.syd}입니다.

@node Octave,  , EpiInfo Minitab SAS S-PLUS SPSS Stata Systat, 다른 통계 시스템에서 가져오기
@section Octave
@cindex Octave
@findex read.octave

Octave는 수치 선형 대수 시스템(@uref{https://octave.org/})이며, @CRANpkg{foreign} 패키지의 함수 @code{read.octave}는 Octave 명령어 @command{save -ascii}를 사용하여 생성된 Octave 텍스트 데이터 형식의 파일을 읽을 수 있습니다. 표준 원자(실수 및 복소수 스칼라, 행렬 및 @math{N}-차원 배열, 문자열, 범위 및 부울 스칼라와 행렬) 및 재귀(structs, cells 및 lists) 타입이 포함됩니다.

@node 관계형 데이터베이스, 이진 파일, 다른 통계 시스템에서 가져오기, 상위
@chapter 관계형 데이터베이스

@cindex 관계형 데이터베이스
@cindex DBMS

@menu
* 왜 데이터베이스를 사용하는가?::         
* RDBMS 개요::          
* R 인터페이스 패키지::        
@end menu

@node 왜 데이터베이스를 사용하는가?, RDBMS 개요, 관계형 데이터베이스, 관계형 데이터베이스
@section 왜 데이터베이스를 사용하는가?

@R{}이 잘 처리하지 못하는 데이터 유형에는 제한이 있습니다.
@R{}에서 조작되는 모든 데이터는 메모리에 존재하며 함수 실행 중 데이터의 여러 복사본이 생성될 수 있기 때문에, @R{}은 매우 큰 데이터 세트에는 적합하지 않습니다. 몇백메가바이트 이상의 크기를 가진 데이터 객체는 @R{}이 메모리를 고갈시킬 수 있으며, 특히 32비트 운영체제에서 그렇습니다.

@R{}은 데이터에 대한 동시 액세스를 쉽게 지원하지 않습니다. 즉, 하나 이상의 사용자가 동일한 데이터에 액세스하고 업데이트할 수 있는 경우 한 사용자에 의해 수행된 변경 사항이 다른 사용자에게 표시되지 않습니다.

@R{}은 데이터의 지속성을 지원합니다. 즉, 하나의 세션에서 데이터 객체 또는 전체 워크시트를 저장하고 이후 세션에서 복원할 수 있지만 저장된 데이터의 형식은 @R{}에 특정되어 있어 다른 시스템에서 쉽게 조작할 수 없습니다.

데이터베이스 관리 시스템(DBMS) 및 특히 관계형 DBMS(RDBMS)는 이러한 작업을 모두 잘 처리하도록 설계되어 있습니다.
그들의 강점은 다음과 같습니다.

@enumerate
@item
큰 데이터베이스의 선택된 부분에 빠르게 액세스할 수 있습니다.

@item
데이터베이스의 열을 요약하고 교차 집계하는 강력한 방법을 제공합니다.

@item
스프레드시트와 @R{} 데이터 프레임의 직사각형 그리드 모델보다 더 조직적인 방식으로 데이터를 저장합니다.

@item
데이터에 대한 액세스에 대한 보안 제약 조건을 적용하면서 여러 호스트에서 실행되는 여러 클라이언트로부터 동시 액세스를 지원합니다.

@item
다양한 클라이언트에게 서버 역할을 수행할 수 있는 기능을 제공합니다.
@end enumerate

DBMS가 사용될 수 있는 통계 응용 프로그램의 예로는 데이터의 10% 샘플을 추출하거나, 데이터를 교차 집계하여 다차원 교차표를 생성하고, 데이터베이스에서 그룹별로 데이터를 추출하여 별도로 분석하는 것이 있습니다.

운영체제가 이러한 이유로 DBMS를 사용하는 경우가 점점 늘어나고 있으므로, 현재는 이미 설치된 DBMS가 있을 가능성이 높습니다(Windows가 아닌 경우). @uref{https://en.wikipedia.org/wiki/Akonadi, Akonadi}는 KDE4에서 개인 정보를 저장하는 데 사용됩니다. 맥OS의 여러 애플리케이션, 메일 및 주소록을 비롯하여 SQLite를 사용합니다.
@c https://www.actualtech.com/sqlite_applications.php

@node RDBMS 개요, R 인터페이스 패키지, 왜 데이터베이스를 사용하는가?, 관계형 데이터베이스
@section RDBMS 개요

전통적으로 크고 비싼 상업용 RDBMS(@uref{https://www.ibm.com/products/informix, Informix}; @uref{https://www.oracle.com, Oracle}; Sybase; @uref{https://www.ibm.com/products/db2, IBM의 DB2}; @uref{https://www.microsoft.com/sql-server/, Windows에서의 Microsoft @acronym{SQL} Server})와 학술 및 소규모 시스템 데이터베이스(MySQL@footnote{그리고 파생된 것들, 특히 MariaDB.}, PostgreSQL, Microsoft Access, @dots{})가 있었는데, 전자는 데이터 보안 기능에 훨씬 더 많은 강조가 되었습니다. 경계선이 흐려지고 있으며, MySQL 및 PostgreSQL에 점점 더 많은 고급 기능이 추가되고 있으며, 상업용 DBMS에 대한 무료 '익스프레스' 버전도 제공되고 있습니다.

@cindex ODBC
@cindex 오픈 데이터베이스 연결
스프레드시트, 비관계형 데이터베이스, 심지어 텍스트 파일(압축된 경우도 있음)과 같은 다른 일반적으로 사용되는 데이터 소스도 있습니다. 오픈 데이터베이스 연결(@acronym{ODBC})은 이러한 데이터 소스를 모두 사용하는 표준입니다. 원래 Windows에서 시작되었지만(참조 @uref{https://docs.microsoft.com/en-us/sql/odbc/microsoft-open-database-connectivity-odbc}), 리눅스/유닉스/맥OS에서도 구현되었습니다.

이 장에서 나중에 설명할 패키지들은 모두 클라이언트/서버 데이터베이스에 대한 클라이언트를 제공합니다. 데이터베이스는 동일한 기계에 있거나(더 자주 사용됨) 원격에 있을 수 있습니다. @acronym{ISO} 표준(사실 몇 가지가 있음: @acronym{SQL}92는 @acronym{ISO}/IEC 9075로, 또한 @acronym{ANSI} X3.135-1992로 알려져 있으며, @acronym{SQL}99가 사용되기 시작함)이 있으며, 이 인터페이스 언어는 @acronym{SQL}(구조화된 쿼리 언어, 때때로 '시퀄'이라고 발음됨: Bowman @emph{et al.@:} 1996 및 Kline and Kline 2001 참조)로 불리며, 이 DBMS들이 다양한 정도로 지원합니다.

@menu
* SQL 쿼리::                 
* 데이터 유형::                  
@end menu

@node SQL 쿼리, 데이터 유형, RDBMS 개요, RDBMS 개요
@subsection @acronym{SQL} 쿼리
@cindex SQL 쿼리

보다 포괄적인 @R{} 인터페이스는 일반적인 작업에 대해 뒷단에서 @acronym{SQL}을 생성하지만, 모든 복잡한 작업에 대해 직접적인 @acronym{SQL} 사용이 필요합니다. 전통적으로 @acronym{SQL}은 대문자로 작성되지만, 많은 사용자들이 @R{} 인터페이스 함수에서 소문자를 사용하는 것이 더 편리하다고 생각할 수 있습니다.

관계형 DBMS는 데이터를 @R{} 데이터 프레임과 유사한 @emph{테이블}(또는 @emph{관계}) 데이터베이스로 저장합니다. 테이블은 하나의 유형(숫자, 문자, 날짜, 통화, @dots{})의 @emph{열} 또는 @emph{필드}와 한 엔티티에 대한 관측치를 포함하는 @emph{행} 또는 @emph{레코드}로 구성됩니다.

@acronym{SQL} '쿼리'는 관계형 데이터베이스에서 상당히 일반적인 작업입니다. 고전적인 쿼리는 다음과 같은 SELECT 문입니다.

@example
SELECT State, Murder FROM USArrests WHERE Rape > 30 ORDER BY Murder

SELECT t.sch, c.meanses, t.sex, t.achieve
  FROM student as t, school as c WHERE t.sch = c.id

SELECT sex, COUNT(*) FROM student GROUP BY sex

SELECT sch, AVG(sestat) FROM student GROUP BY sch LIMIT 10
@end example

@noindent
이 중 첫 번째는 데이터베이스 테이블로 복사된 @R{} 데이터 프레임 @code{USArrests}에서 두 개의 열을 선택하고, 세 번째 열에서 부분 집합을 적용하고 결과를 정렬하도록 요청합니다. 두 번째는 두 테이블 @code{student}와 @code{school}에서 데이터베이스 @emph{join}을 수행하고 네 개의 열을 반환합니다. 세 번째와 네 번째 쿼리는 교차 분류를 수행하고 빈도수 또는 평균을 반환합니다. (다섯 개의 집계 함수는 COUNT(*)와 SUM, MAX, MIN, AVG가 있으며, 각각 하나의 열에 적용됩니다.)

SELECT 쿼리는 FROM을 사용하여 테이블을 선택하고, WHERE를 사용하여 포함할 조건을 지정하며(또는 AND 또는 OR로 구분된 여러 조건), 결과를 정렬하기 위해 ORDER BY를 사용합니다. 데이터 프레임과 달리 RDBMS 테이블의 행은 순서가 없는 것으로 가장 잘 생각되며, ORDER BY 문이 없으면 정렬이 결정되지 않습니다. 쉼표로 구분하여 두 개 이상의 열에서 사전식 순서로 정렬할 수 있습니다. ORDER BY 다음에 DESC를 배치하면 내림차순으로 정렬됩니다.

SELECT DISTINCT 쿼리는 선택된 테이블에서 각각 다른 행의 한 개의 복사본만 반환합니다.

GROUP BY 절은 기준에 따라 행의 하위 그룹을 선택합니다. 쉼표로 구분된 둘 이상의 열이 지정되면 다섯 가지 집계 함수 중 하나로 다중 방식 교차 분류를 요약할 수 있습니다. HAVING 절을 사용하면 집계된 값에 따라 그룹을 포함하거나 제외할 수 있습니다.

SELECT 문에 고유한 순서를 생성하는 ORDER BY 문이 포함되어 있으면, LIMIT 절을 추가하여(숫자로) 연속된 출력 행 블록을 선택할 수 있습니다. 이를 통해 한 번에 블록 단위로 행을 검색할 수 있습니다. (순서가 고유하지 않으면 LIMIT 절이 쿼리를 최적화하는 데 사용되므로 신뢰할 수 없을 수 있습니다.)

테이블을 생성하는 쿼리(CREATE TABLE)가 있지만, 이러한 인터페이스에서는 주로 데이터 프레임을 데이터베이스로 복사합니다. 또한 데이터를 삽입, 삭제, 업데이트하는 INSERT, DELETE, UPDATE도 있습니다.

Kline과 Kline(2001)은 Microsoft SQL Server 2000, Oracle, MySQL 및 PostgreSQL에서 SQL 구현의 세부 사항에 대해 논의합니다.

@node 데이터 유형,  , SQL 쿼리, RDBMS 개요
@subsection 데이터 유형

데이터는 데이터베이스에서 다양한 데이터 유형으로 저장할 수 있습니다. 데이터 유형의 범위는 DBMS에 따라 다르지만, @acronym{SQL} 표준은 다음과 같은 광범위하게 구현된 유형을 포함하여 많은 유형을 정의합니다(종종 @acronym{SQL} 이름이 아닙니다).

@table @code
@item float(@var{p})
선택적 정밀도를 가진 실수입니다. 종종 @code{real} 또는 @code{double} 또는 @code{double precision}이라고 불립니다.
@item integer
32비트 정수입니다. 종종 @code{int}라고 불립니다.
@item smallint
16비트 정수입니다.
@item character(@var{n})
고정 길이 문자열입니다. 종종 @code{char}이라고 불립니다.
@item character varying(@var{n})
가변 길이 문자열입니다. 종종 @code{varchar}이라고 불립니다. 거의 항상 255자 제한이 있습니다.
@item boolean
참 또는 거짓입니다. 때때로 @code{bool} 또는 @code{bit}이라고 불립니다.
@item date
달력 날짜입니다.
@item time
하루 중 시간입니다.
@item timestamp
날짜와 시간입니다.
@end table

@noindent
@code{time} 및 @code{timestamp}에 대한 변형으로 @code{with timezone}이 있습니다. 널리 구현된 다른 유형으로는 대량의 텍스트 및 이진 데이터에 대한 @code{text} 및 @code{blob}이 있습니다.

더 포괄적인 @R{} 인터페이스 패키지는 사용자로부터 유형 변환 문제를 숨깁니다.

@node R 인터페이스 패키지,  , RDBMS 개요, 관계형 데이터베이스
@section R 인터페이스 패키지

@R{}이 DBMS와 통신하는 데 도움이 되는 여러 패키지가 @acronym{CRAN}에서 사용할 수 있습니다. 이들은 다른 수준의 추상화를 제공합니다. 일부는 데이터 프레임 전체를 데이터베이스와 복사하는 방법을 제공합니다. 모두 @acronym{SQL} 쿼리를 통해 데이터베이스 내에서 데이터를 선택하고 결과를 전체 데이터 프레임 또는 부분(일반적으로 행 그룹으로)으로 검색하는 기능이 있습니다.

@CRANpkg{RODBC}를 제외한 모든 패키지는 하나의 DBMS와 연결되어 있지만, 통합된 '프론트엔드' 패키지 @CRANpkg{DBI}(@uref{https://developer.r-project.org/db/})와 함께 '백엔드' 제안이 있었습니다. 가장 발전된 것은 @CRANpkg{RMySQL}입니다. 또한 @acronym{CRAN}에는 백엔드 @CRANpkg{ROracle}, @CRANpkg{RPostgreSQL} 및 @CRANpkg{RSQLite}(묶인 DBMS @code{SQLite}, @uref{https://www.sqlite.org/index.html}와 작동) 및 @CRANpkg{RJDBC}(Java를 사용하고 JDBC 드라이버가 있는 모든 DBMS에 연결할 수 있음)가 있습니다.

@c BioConductor 프로젝트는 PostgreSQL에 대한 첫 번째 세대 인터페이스인 @pkg{RdbiPgSQL}(이전에는 @acronym{CRAN} ca 2000)을 업데이트했습니다.

@pkg{PL/R} (@uref{https://github.com/postgres-plr/plr})은 R을 PostgreSQL에 포함시키는 프로젝트입니다.

패키지 @CRANpkg{RMongo}는 'MongoDB'(@uref{https://en.wikipedia.org/wiki/MongoDB}) 데이터베이스에 대한 Java 클라이언트에 대한 @R{} 인터페이스를 제공하며, SQL 대신 JavaScript를 사용하여 쿼리합니다. 패키지 @CRANpkg{mongolite}는 @pkg{mongodb}의 C 드라이버를 사용하는 또 다른 클라이언트입니다.

@menu
* DBI::                         
* RODBC::                       
@end menu


@node DBI, RODBC, R 인터페이스 패키지, R 인터페이스 패키지
@subsection DBI를 사용하는 패키지
@cindex MySQL 데이터베이스 시스템

@acronym{CRAN}의 @CRANpkg{RMySQL} 패키지는 MySQL 데이터베이스 시스템(참조: @uref{https://www.mysql.com} 및 Dubois, 2000) 또는 그 파생 프로젝트인 MariaDB(참조: @uref{https://mariadb.org/})에 대한 인터페이스를 제공합니다. 여기서 설명하는 내용은 @code{0.5-0} 버전 이후에 적용되며, 이전 버전은 상당히 다른 인터페이스를 가지고 있습니다. 현재 버전은 @CRANpkg{DBI} 패키지를 필요로 하며, 이 설명은 @CRANpkg{DBI}의 다른 백엔드에도 소소한 변경을 적용합니다.

MySQL은 Unix/Linux/macOS 및 Windows에서 사용할 수 있으며, GPL 라이선스로 발표된 '커뮤니티 에디션'이 있지만, 상업용 라이선스도 사용할 수 있습니다. MySQL은 원래 '가벼운 경량' 데이터베이스였습니다. (파일 시스템이 대소문자 구분이 있는 경우 이름의 대소문자를 유지하므로 Windows에서는 사용하지 않습니다.)

@findex dbDriver
@findex dbConnect
@findex dbDisconnect
@code{dbDriver("MySQL")} 호출은 데이터베이스 연결 관리자 객체를 반환하고, 그 후 @code{dbConnect} 호출을 통해 데이터베이스 연결을 열 수 있으며, 일반 함수 @code{dbDisconnect} 호출을 통해 이후에 닫을 수 있습니다. 해당 DBMS 및 패키지와 함께 @code{dbDriver("Oracle")}, @code{dbDriver("PostgreSQL")} 또는 @code{dbDriver("SQLite")}를 각각 @CRANpkg{ROracle}, @CRANpkg{RPostgreSQL} 또는 @CRANpkg{RSQLite}로 사용합니다.

@findex dbSendQuery
@findex dbClearResult
@findex dbGetQuery
@acronym{SQL} 쿼리는 @code{dbSendQuery} 또는 @code{dbGetQuery}를 통해 전송할 수 있습니다. @code{dbGetquery}는 쿼리를 전송하고 결과를 데이터 프레임으로 검색합니다. @code{dbSendQuery}는 쿼리를 전송하고 결과를 검색하는 데 사용할 수 있는 @code{"DBIResult"}에서 상속된 클래스 객체를 반환하며, 이후 @code{dbClearResult} 호출에서 결과를 제거하는 데 사용됩니다.

@findex fetch
함수 @code{fetch}는 쿼리 결과에서 몇 개 또는 모든 행을 리스트로 검색하는 데 사용됩니다. 함수 @code{dbHasCompleted}는 모든 행이 가져와졌는지 여부를 나타내고, @code{dbGetRowCount}는 결과의 행 수를 반환합니다.

@findex dbReadTable
@findex dbWriteTable
@findex dbExistsTable
@findex dbRemoveTable
이것들은 데이터베이스의 테이블을 읽기/쓰기/테스트/삭제하기 위한 편리한 인터페이스입니다. @code{dbReadTable}과 @code{dbWriteTable}은 @R{} 데이터 프레임과 매핑하여 데이터 프레임의 행 이름을 @code{MySQL} 테이블의 @code{row_names} 필드로 복사합니다.

@smallexample
> library(RMySQL) # 이것은 DBI도 함께 로드합니다
## MySQL 데이터베이스에 연결을 엽니다
> con <- dbConnect(dbDriver("MySQL"), dbname = "test")
## 데이터베이스의 테이블 목록을 확인합니다
> dbListTables(con)
## 데이터 프레임을 데이터베이스로 불러오고, 기존 복사본을 삭제합니다
> data(USArrests)
> dbWriteTable(con, "arrests", USArrests, overwrite = TRUE)
TRUE
> dbListTables(con)
[1] "arrests"
## 전체 테이블을 가져옵니다
> dbReadTable(con, "arrests")
               Murder Assault UrbanPop Rape
Alabama          13.2     236       58 21.2
Alaska           10.0     263       48 44.5
Arizona           8.1     294       80 31.0
Arkansas          8.8     190       50 19.5
...
## 로드된 테이블에서 선택합니다
> dbGetQuery(con, paste("select row_names, Murder from arrests",
                        "where Rape > 30 order by Murder"))
   row_names Murder
1   Colorado    7.9
2    Arizona    8.1
3 California    9.0
4     Alaska   10.0
5 New Mexico   11.4
6   Michigan   12.1
7     Nevada   12.2
8    Florida   15.4
> dbRemoveTable(con, "arrests")
> dbDisconnect(con)
@end smallexample

@node RODBC,  , DBI, R 인터페이스 패키지
@subsection 패키지 RODBC
@cindex ODBC
@cindex Open Database Connectivity

@acronym{CRAN}의 패키지 @CRANpkg{RODBC}는 @acronym{ODBC} 인터페이스를 지원하는 데이터베이스 소스에 대한 인터페이스를 제공합니다. 이것은 매우 널리 사용되며, 다른 데이터베이스 시스템에 접근하기 위해 동일한 @R{} 코드를 사용할 수 있습니다. @CRANpkg{RODBC}는 Unix/Linux, Windows 및 macOS에서 실행되며, 거의 모든 데이터베이스 시스템은 @acronym{ODBC}를 지원합니다. Windows에서 Microsoft SQL Server, Access, MySQL, PostgreSQL, Oracle 및 IBM DB2를 테스트하였고, Linux에서 MySQL, MariaDB, Oracle, PostgreSQL 및 SQLite를 테스트하였습니다.

ODBC는 클라이언트-서버 시스템이며, Unix 서버에서 실행되는 DBMS에 Windows 클라이언트에서 연결하거나 그 반대로 연결할 수 있습니다.

Windows에서 ODBC 지원은 OS의 일부입니다. Unix/Linux에서는 unixODBC(@uref{http://www.unixODBC.org}) 또는 iOBDC(@uref{https://www.iodbc.org/}: 이것은 macOS에 미리 설치되어 있음)와 같은 @acronym{ODBC} 드라이버 관리자와 데이터베이스 시스템용 설치된 드라이버가 필요합니다.

@cindex Excel
@cindex Dbase
@findex .dbf
Windows는 DBMS뿐만 아니라 Excel (@file{.xls}) 스프레드시트, DBase (@file{.dbf}) 파일, 심지어 텍스트 파일에 대한 드라이버도 제공합니다. (명명된 애플리케이션은 @emph{설치할 필요가 없습니다.} 지원되는 파일 형식은 드라이버 버전에 따라 다릅니다.) Excel과 Access 2007/2010을 위한 버전이 있습니다(@uref{https://www.microsoft.com/en-us/download/default.aspx}로 이동하여 'Office ODBC'를 검색하면 @file{AccessDatabaseEngine.exe}로 이어집니다), '2007 Office System Driver'(이것은 64비트 Windows용 버전이 있으며 이전 버전도 읽을 수 있습니다).

macOS에서 Actual Technologies(@url{https://www.actualtech.com/product_access.php}) 드라이버는 Access 데이터베이스와 Excel 스프레드시트(Excel 2007/2010은 제외)에 대한 ODBC 인터페이스를 제공합니다.

@findex odbcConnect
@findex odbcDriverConnect
@findex odbcGetInfo
동시에 여러 연결이 가능합니다. 연결은 @code{odbcConnect} 또는 @code{odbcDriverConnect}(Windows GUI에서 대화 상자를 통해 데이터베이스를 선택할 수 있음)를 호출하여 열리며, 이후 데이터베이스에 액세스하는 데 사용되는 핸들을 반환합니다. 연결을 인쇄하면 ODBC 연결의 일부 세부 정보가 제공되며, @code{odbcGetInfo}를 호출하면 클라이언트와 서버의 세부 정보를 얻을 수 있습니다.


@findex odbcClose
@findex close
연결은 @code{close} 또는 @code{odbcClose}를 호출하여 닫히며, R 객체가 참조하지 않고 R 세션 종료시 경고와 함께 닫힙니다.

@findex sqlTables
연결에 대한 테이블의 세부 정보는 @code{sqlTables}를 사용하여 찾을 수 있습니다.

@findex sqlFetch
@findex sqlSave
함수 @code{sqlSave}는 @R{} 데이터 프레임을 데이터베이스의 테이블로 복사하고, @code{sqlFetch}는 데이터베이스의 테이블을 @R{} 데이터 프레임으로 복사합니다.

@findex sqlQuery
@findex sqlCopy
@findex odbcQuery
@findex sqlGetResults
@findex sqlFetchMore
@acronym{SQL} 쿼리는 @code{sqlQuery}를 호출하여 데이터베이스로 전송할 수 있습니다. 이 결과는 @R{} 데이터 프레임으로 반환됩니다. (@code{sqlCopy}는 데이터베이스로 쿼리를 전송하고 결과를 데이터베이스의 테이블로 저장합니다.) 더 세밀한 제어는 먼저 @code{odbcQuery}를 호출한 다음 @code{sqlGetResults}를 호출하여 결과를 가져오는 것입니다. 후자는 한 번에 제한된 행 수를 검색하는 루프 내에서 사용할 수 있으며, @code{sqlFetchMore} 함수도 마찬가지입니다.

@cindex PostgreSQL 데이터베이스 시스템
다음은 @acronym{ODBC} 드라이버가 열(column)과 데이터 프레임 이름을 소문자로 매핑하는 PostgreSQL을 사용한 예입니다. 이전에 생성한 데이터베이스 @code{testdb}를 사용하였고, DSN (데이터 소스 이름)을 @code{unixODBC}의 @file{~/.odbc.ini}에 설정했습니다. 동일한 코드가 리눅스 또는 윈도우 하에서 MySQL 데이터베이스에 접근하는 MyODBC를 사용하여 작동했습니다(여기서 MySQL도 이름을 소문자로 매핑합니다).Windows에서, @acronym{DSN}은 제어판의 @acronym{ODBC} 애플릿(`관리 도구' 섹션의 `데이터 소스(ODBC)')에 설정됩니다.
@cindex MySQL 데이터베이스 시스템

@smallexample
> library(RODBC)
## 이름을 소문자로 매핑하도록 알림
> channel <- odbcConnect("testdb", uid="ripley", case="tolower")
## 데이터 프레임을 데이터베이스에 로드
> data(USArrests)
> sqlSave(channel, USArrests, rownames = "state", addPK = TRUE)
> rm(USArrests)
## 데이터베이스의 테이블 목록
> sqlTables(channel)
  TABLE_QUALIFIER TABLE_OWNER TABLE_NAME TABLE_TYPE REMARKS
1                              usarrests      TABLE        
## 테이블 출력
> sqlFetch(channel, "USArrests", rownames = "state")
               murder assault urbanpop rape
Alabama          13.2     236       58 21.2
Alaska           10.0     263       48 44.5
    ...
## SQL 쿼리, 원래는 한 줄에 있음
> sqlQuery(channel, "select state, murder from USArrests
           where rape > 30 order by murder")
       state murder
1 Colorado      7.9
2 Arizona       8.1
3 California    9.0
4 Alaska       10.0
5 New Mexico   11.4
6 Michigan     12.1
7 Nevada       12.2
8 Florida      15.4
## 테이블 제거
> sqlDrop(channel, "USArrests")
## 연결 종료
> odbcClose(channel)
@end smallexample

@cindex Excel
@findex .xls
@findex odbcConnectExcel
Windows에서 Excel 스프레드시트를 사용하여 @acronym{ODBC}를 사용하는 간단한 예를 들어 보겠습니다. 스프레드시트에서 읽어올 수 있습니다.

@smallexample
> library(RODBC)
> channel <- odbcConnectExcel("bdr.xls")
## 스프레드시트 목록 보기
> sqlTables(channel)
  TABLE_CAT TABLE_SCHEM        TABLE_NAME   TABLE_TYPE REMARKS
1 C:\\bdr            NA           Sheet1$ SYSTEM TABLE      NA
2 C:\\bdr            NA           Sheet2$ SYSTEM TABLE      NA
3 C:\\bdr            NA           Sheet3$ SYSTEM TABLE      NA
4 C:\\bdr            NA Sheet1$Print_Area        TABLE      NA
## 시트 1의 내용을 검색하려면 다음 중 하나를 사용합니다.
> sh1 <- sqlFetch(channel, "Sheet1")
> sh1 <- sqlQuery(channel, "select * from [Sheet1$]")
@end smallexample

@noindent
@code{sqlTables}에서 반환된 이름과 달리 테이블의 지정이 다르다는 점에 유의하십시오. @code{sqlFetch}는 차이점을 매핑할 수 있습니다.

@c @node RPgSQL,  , RODBC, R interface packages
@c @subsection Package RPgSQL
@c @cindex PostgreSQL 데이터베이스 시스템

@c @pkg{RPgSQL}은 @uref{http://rpgsql.sourceforge.net/} 및 @acronym{CRAN}의 @code{Devel} 영역에서 @uref{http://www.postgresql.org, PostgreSQL} 인터페이스를 제공합니다. 개발은 중단된 것으로 보입니다.

@c PostgreSQL은 개발자들이 '가장 고급 오픈 소스 데이터베이스 서버'라고 설명하고 있습니다(Momjian, 2000). 대부분의 Unix와 유사한 OS와 Windows(Cygwin 또는 U/Win 하에서)에서 빌드 가능한 것으로 보입니다. PostgreSQL은 상용 RDBMS의 대부분 기능을 갖추고 있습니다.

@c @findex db.connect
@c @findex db.read.table
@c @findex db.write.table
@c @pkg{RPgSQL}을 사용하려면 먼저 @code{db.connect}를 사용하여 데이터베이스에 연결을 엽니다. (현재 한 번에 하나의 연결만 열 수 있습니다.) 연결이 열리면 @R{} 데이터 프레임을 @code{db.write.table}을 사용하여 PostgreSQL 테이블에 복사할 수 있고, @code{db.read.table}을 사용하여 PostgreSQL 테이블을 @R{} 데이터 프레임에 복사할 수 있습니다.

@c @findex bind.db.proxy
@c @cindex 프록시 데이터 프레임
@c @pkg{RPgSQL}은 @emph{프록시 데이터 프레임}이라는 흥미로운 개념을 가지고 있습니다.
@c 데이터 프레임 프록시는 @code{"data.frame"} 클래스에서 상속받은 @R{} 객체이지만 데이터를 포함하지 않습니다. 프록시 데이터 프레임에 대한 모든 접근은 적절한 @acronym{SQL} 쿼리를 생성하고 데이터베이스에서 결과 데이터를 검색합니다. 프록시 데이터 프레임은 @code{bind.db.proxy}를 호출하여 설정됩니다. 프록시를 제거하려면 @code{bind.db.proxy}가 생성한 객체를 제거하면 됩니다.

@c @findex db.execute
@c @findex db.result.columns
@c @findex db.result.rows
@c @findex db.read.column
@c @findex db.fetch.result
@c @findex db.clear.result
@c @findex db.result.get.value
@c PostgreSQL 서버에 @acronym{SQL} 쿼리를 보내는 @code{db.execute}를 통해 더 세밀한 제어 수준을 사용할 수 있습니다. 이렇게 하면 결과가 PostgreSQL의 결과 캐시에 남게 됩니다. 결과가 캐시에 있으면 @code{db.fetch.result}를 사용하여 전체 결과를 데이터 프레임으로 가져올 수 있습니다. @code{db.result.columns} 및 @code{db.result.rows}와 같은 함수는 캐시된 테이블의 열과 행 수를 보고하며, @code{db.read.column}은 단일 열(벡터로)을 가져옵니다. 결과의 개별 셀은 @code{db.result.get.value}를 사용하여 읽을 수 있습니다. @code{db.clear.result}는 결과 캐시를 지웁니다.

@c @findex sql.insert
@c @findex sql.select
@c 한 가지 단점은 PostgreSQL이 모든 테이블과 열 이름을 소문자로 매핑한다는 것입니다. 따라서 최대한의 유연성을 위해 @R{} 이름에 소문자만 사용하십시오. 함수 @code{sql.insert} 및 @code{sql.select}는 INSERT 및 SELECT 쿼리를 위한 편리한 래퍼를 제공합니다.

@c 간단한 예제에서 이러한 함수를 살펴볼 수 있습니다. 데이터베이스 @file{testdb}는 이미 설정되어 있었으며, PostgreSQL이 독립 실행형 기계에서 실행되고 있어 연결할 때 추가 인증이 필요하지 않았습니다.

@c @smallexample
@c > library(RPgSQL)
@c > db.connect(dbname="testdb")   # 필요한 인증 정보 추가
@c ""에서 "testdb" 데이터베이스에 연결됨
@c > data(USArrests)
@c > usarrests <- USArrests
@c > names(usarrests) <- tolower(names(USArrests))
@c > db.write.table(USArrests, write.row.names = TRUE)
@c > db.write.table(usarrests, write.row.names = TRUE)
@c > rm(USArrests, usarrests)
@c ## db.ls는 데이터베이스의 테이블을 나열합니다.
@c > db.ls()
@c [1] "USArrests"  "usarrests"
@c > db.read.table("USArrests")
@c                Murder Assault UrbanPop Rape
@c Alabama          13.2     236       58 21.2
@c Alaska           10.0     263       48 44.5
@c    ...
@c ## 프록시 데이터 프레임 설정. USArrests가 제거된 것을 기억하십시오
@c > bind.db.proxy("USArrests")
@c ## USArrests는 이제 프록시이므로 모든 접근은 데이터베이스로 이루어집니다.
@c > USArrests[, "Rape"]
@c    Rape
@c 1  21.2
@c 2  44.5
@c    ...
@c > rm(USArrests) # 프록시 제거
@c > db.execute("SELECT rpgsql_row_names, murder FROM usarrests",
@c              "WHERE rape > 30 ORDER BY murder", clear=FALSE)
@c > db.fetch.result()
@c            murder
@c Colorado      7.9
@c Arizona       8.1
@c California    9.0
@c Alaska       10.0
@c New Mexico   11.4
@c Michigan     12.1
@c Nevada       12.2
@c Florida      15.4
@c > db.rm("USArrests", "usarrests") # 확인을 건너뛰려면 ask=FALSE 사용
@c 테이블 USArrests를 삭제하시겠습니까? y
@c 테이블 usarrests를 삭제하시겠습니까? y
@c > db.ls()
@c character(0)
@c > db.disconnect()
@c @end smallexample

@c @noindent
@c @code{write.row.names = TRUE}를 사용하여 데이터베이스 테이블의 @code{rpgsql_row_names} 필드에 행 이름이 어떻게 매핑되는지 그리고 쿼리에서 해당 필드를 유지하는 한 투명하게 복원되는지 확인하십시오.

@c @pkg{RPgSQL}은 데이터 프레임 내의 @R{} 클래스와 PostgreSQL 유형 간의 매핑을 확장하는 방법을 제공합니다.


@node 이진 파일, 이미지 파일, 관계형 데이터베이스, 상위
@chapter 이진 파일
@cindex 이진 파일

@menu
* 이진 데이터 형식::         
* dBase 파일 (DBF)::           
@end menu

이진 연결(@ref{연결})은 이제 이진 파일을 처리하는 데 선호되는 방법입니다.



@node 이진 데이터 형식, dBase 파일 (DBF), 이진 파일, 이진 파일
@section 이진 데이터 형식
@findex hdf5
@cindex 계층적 데이터 형식

@findex netCDF
@cindex 네트워크 공통 데이터 형식

@CRANpkg{h5}, Bioconductor의 @pkg{rhdf5}, @CRANpkg{RNetCDF} 및
@acronym{CRAN}의 @CRANpkg{ncdf4} 패키지는 @acronym{NASA}의
HDF5(계층적 데이터 형식, @uref{https://www.hdfgroup.org/HDF5/} 참조)와 UCAR의 netCDF 데이터 파일
(네트워크 공통 데이터 형식, @uref{https://www.unidata.ucar.edu/software/netcdf/} 참조)에 대한 인터페이스를 제공합니다.

이 두 가지 모두 배열 지향 방식으로 과학 데이터를 저장하는 시스템으로, 설명, 레이블, 형식, 단위 등을 포함합니다. HDF5는 배열의 @emph{그룹}도 허용하며, @R{} 인터페이스는 리스트를 HDF5 그룹에 매핑하고, 수치 및 문자 벡터와 행렬을 작성할 수 있습니다.

NetCDF의 버전 4 형식 (혼동스럽게도 netCDF 4.1.1 이후에 구현되었지만 4.0.1에는 포함되지 않음)은 다양한 HDF5 형식을 사용합니다. 이는 패키지 @CRANpkg{ncdf4}에서 처리되며, @CRANpkg{RNetCDF}은 버전 3 파일을 처리합니다.

이러한 형식을 지원하는 소프트웨어의 사용 가능성은 플랫폼에 따라 다소 제한적이며, 특히 Windows에서 그렇습니다.

@node dBase 파일 (DBF),  , 이진 데이터 형식, 이진 파일
@section dBase 파일 (DBF)

@cindex dBase
@cindex DBF 파일
@code{dBase}는 Ashton-Tate에서 작성하고 나중에 Borland에서 소유한 DOS 프로그램으로, 파일 확장자가 @file{.dbf}인 이진 평면 파일 형식이 인기를 얻었습니다. 이것은 'Xbase' 데이터베이스 계열의 dBase, Clipper, FoxPro 및 Windows 상응품인 Visual dBase, Visual Objects 및 Visual FoxPro (참조 @uref{https://www.clicketyclick.dk/databases/xbase/format/})를 포함하고 있습니다.
dBase 파일에는 헤더와 일련의 필드가 포함되어 있으므로 @R{} 데이터 프레임과 가장 유사합니다. 데이터 자체는 텍스트 형식으로 저장되며, 문자, 논리 및 숫자 필드를 포함할 수 있고, 후속 버전에서 다른 유형을 포함할 수 있습니다 (예를 들어 @uref{https://www.loc.gov/preservation/digital/formats/fdd/fdd000325.shtml} 및 @uref{https://www.clicketyclick.dk/databases/xbase/format/index.html} 참조).

@findex read.dbf
@findex write.dbf
함수 @code{read.dbf}와 @code{write.dbf}는 모든 @R{} 플랫폼에서 기본 DBF 파일을 읽고 쓸 수 있는 방법을 제공합니다. Windows 사용자의 경우 패키지 @CRANpkg{RODBC}의 @code{odbcConnectDbase}가 Microsoft의 dBase ODBC 드라이버를 통해 DBF 파일을 읽는 데 더욱 포괄적인 기능을 제공합니다(또한 Visual FoxPro 드라이버도 @code{odbcDriverConnect}를 통해 사용할 수 있음).
@findex odbcConnectDbase

@node 이미지 파일, 연결, 이진 파일, 상위
@chapter 이미지 파일

이진 파일의 특정 클래스는 이미지를 나타내는 파일로, 이미지 파일을 @R{}의 행렬로 읽는 것은 드문 요청이 아닙니다.

이미지 파일의 형식은 많고 (대부분 다양한 변형이 있음) 외부 변환 소프트웨어를 사용하여 이미지를 패키지가 현재 @R{} 리더를 제공하는 형식 중 하나로 먼저 변환해야 할 수 있습니다. 이러한 소프트웨어의 다재다능한 예로 ImageMagick과 이것의 포크인 GraphicsMagick이 있습니다. 이러한 프로그램은 명령줄 프로그램 @command{convert}와 @command{gm convert}를 제공하여 이미지를 한 형식에서 다른 형식으로 변환합니다. 입력 가능한 형식은 컴파일할 때 결정되며, 지원되는 형식은 예를 들어 @command{convert -list format}을 통해 나열할 수 있습니다.

패키지 @CRANpkg{pixmap}에는 PBM (흑백), PGM (회색), PPM (RGB 컬러) 형식의 `휴대용 anymap' 이미지를 읽는 함수 @code{read.pnm}이 있습니다. 이러한 형식은 'netpbm' 형식으로도 알려져 있습니다.

패키지 @CRANpkg{bmp}, @CRANpkg{jpeg}, @CRANpkg{png}는 각각의 이름으로 된 형식을 읽습니다. 또한 패키지 @CRANpkg{biOps}, @CRANpkg{Momocs} 및 Bioconductor 패키지 @pkg{EBImage}를 참조하십시오.

TIFF는 메타 형식으로, 매우 다양한 이미지 형식이 포함될 수 있는 래퍼입니다. 패키지 @CRANpkg{rtiff} 및 @CRANpkg{tiff}는 하위 형식 중 일부를 읽을 수 있습니다 (컴파일된 외부 @code{libtiff} 소프트웨어에 따라 다름). 예를 들어 Bioconductor 패키지 @pkg{beadarray}에서는 특수한 하위 형식에 대한 기능이 있습니다.

래스터 파일은 지리 과학에서 일반적이며, 패키지 @CRANpkg{rgdal}은 GDAL에 대한 인터페이스를 제공하며, 자체 래스터 파일을 읽는 기능과 다른 많은 기능에 대한 링크를 제공합니다. 지원되는 형식은 GDAL이 컴파일 될 때 결정되며, 사용 중인 빌드에 대한 내용은 @code{gdalDrivers()}를 사용하여 확인할 수 있습니다. macOS 및 Windows 바이너리 버전의 @CRANpkg{rgdal}에서 현재 지원되지 않는 JPEG 2000 (JPEG와는 다른 형식)과 같은 희귀한 형식에 유용할 수 있습니다.


@node 연결, 네트워크 인터페이스, 이미지 파일, 상위
@chapter 연결

@cindex 연결
@emph{Connections}는 @R{}에서 Chambers (1998)와 Ripley (2001)의 의미로 사용되며, 파일 이름 사용을 파일과 유사한 객체에 대한 유연한 인터페이스로 대체하는 함수 세트입니다.


@menu
* 연결 유형::        
* 연결을 통한 출력::       
* 연결로부터의 입력::      
* 연결 목록 및 조작::  
* 이진 연결::          
@end menu


@node 연결 유형, 연결을 통한 출력, 연결, 연결
@section 연결 유형
@cindex 연결

@findex 파일
@cindex 파일 연결
가장 친숙한 연결 유형은 파일이며, 파일 연결은 @code{file} 함수에 의해 생성됩니다. 파일 연결은 (OS가 해당 파일에 대해 허용하는 경우) 읽기 또는 쓰기 또는 추가, 텍스트 또는 이진 모드로 열 수 있습니다. 사실, 파일은 읽기와 쓰기 모두를 위해 열릴 수 있으며, @R{}은 읽기와 쓰기를 위한 별도의 파일 위치를 유지합니다.

@findex open
@findex close
주의할 점은 연결이 생성될 때 기본적으로 연결이 열리지 않는다는 것입니다. 규칙은 연결을 사용하는 함수가 이미 열려있지 않은 연결을 열어야 하며 (필요한 경우), 사용 후 열었던 연결을 닫아야 합니다. 간단히 말해서, 발견한 상태로 연결을 유지하십시오. 명시적으로 연결을 열고 닫기 위한 메서드가 있는 일반 함수 @code{open} 및 @code{close}가 있습니다.

@findex gzfile
@findex bzfile
@cindex 압축된 파일
@code{gzip}에 사용된 알고리즘을 통해 압축된 파일은 @code{gzfile} 함수로 생성된 연결로 사용할 수 있으며, @code{bzip2}로 압축된 파일은 @code{bzfile}을 통해 사용할 수 있습니다.

@cindex 터미널 연결
@findex stdin
@findex stdout
@findex stderr
유닉스 프로그래머들은 특수한 파일 @code{stdin}, @code{stdout} 및 @code{stderr}를 다루는 데 익숙합니다. 이들은 @R{}에서 @emph{터미널 연결}로 존재합니다. 일반 파일일 수도 있지만, GUI 콘솔로부터의 입력과 출력을 참조할 수도 있습니다. (표준 Unix @R{} 인터페이스에서도 @code{stdin}은 파일이 아닌 @code{readline}에서 제출된 행을 참조합니다.)

세 가지 터미널 연결은 항상 열려 있으며 열거나 닫을 수 없습니다. @code{stdout}과 @code{stderr}은 일반적으로 일반 출력과 오류 메시지에 각각 사용됩니다. 일반적으로 같은 위치로 이동하지만, 일반 출력은 @code{sink} 호출로 리디렉션할 수 있는 반면, 오류 출력은 @code{sink, type="message")}에 의해 리디렉션되지 않으면 @code{stderr}로 전송됩니다. 여기서 사용된 언어에 주의하십시오: 연결은 리디렉션할 수 없지만, 출력은 다른 연결로 전송할 수 있습니다.

@cindex 텍스트 연결
@findex textConnection
@emph{텍스트 연결}은 입력의 또 다른 출처입니다. 이를 통해 @R{} 문자 벡터를 마치 텍스트 파일에서 읽는 것처럼 읽을 수 있습니다. 텍스트 연결은 @code{textConnection} 호출을 통해 생성되고 열리며, 생성 시점에 문자 벡터의 현재 내용을 내부 버퍼로 복사합니다.

텍스트 연결은 또한 @R{} 출력을 문자 벡터로 캡처하는 데 사용할 수 있습니다. @code{textConnection}은 새 문자 객체를 생성하거나 기존 객체에 추가하라고 요청받을 수 있으며, 두 경우 모두 사용자의 작업 공간에서 이루어집니다. 연결은 @code{textConnection} 호출로 열리며, 연결로 출력되는 완전한 줄은 언제든지 @R{} 객체에서 사용할 수 있습니다. 연결을 닫으면 남은 출력이 문자 벡터의 마지막 요소에 기록됩니다.

@cindex 파이프 연결
@findex pipe
@emph{파이프}는 다른 프로세스에 연결하는 파일의 특수한 형태이며, 파이프 연결은 @code{pipe} 함수로 생성됩니다. 쓰기용으로 파이프 연결을 여는 것(파이프에 추가하는 것은 의미가 없습니다)은 OS 명령을 실행하고, 그것의 표준 입력을 @R{}이 해당 연결에 쓰는 것과 연결합니다. 반대로, 입력용으로 파이프 연결을 여는 것은 OS 명령을 실행하고, 그것의 표준 출력을 해당 연결로부터 @R{} 입력에 사용할 수 있게 합니다.

@cindex URL 연결
@findex url
@acronym{URL}은 @samp{http://}, @samp{https://}, @samp{ftp://}, @samp{file://} 타입의 URL들을 @code{url} 함수를 사용하여 읽을 수 있습니다. 편의를 위해, @code{file}은 파일 지정으로 이들을 받아들이고 @code{url}을 호출합니다.

@cindex 소켓
@findex socketConnection
소켓은 또한 Berkeley 스타일의 소켓을 지원하는 플랫폼에서(대부분의 Unix 시스템, Linux 및 Windows) @code{socketConnection} 함수를 통해 연결로 사용할 수 있습니다. 소켓에 쓰거나 읽을 수 있으며, 클라이언트와 서버 소켓 모두 사용할 수 있습니다.

@node 연결을 통한 출력, 연결로부터의 입력, 연결 유형, 연결
@section 연결을 통한 출력
@cindex 연결

@findex cat
@findex write
@findex write.table
@findex sink
우리는 @code{cat}, @code{write}, @code{write.table} 및 @code{sink} 함수를 파일에 쓰는 것으로 설명했으며, 인수 @code{append = TRUE} 인 경우 파일에 추가할 수도 있습니다. 이것은 @R{} 버전 1.2.0 이전에 그들이 했던 일입니다.

현재의 동작은 동일하지만, 실제로 일어나는 일은 @code{file} 인수가 문자열일 때 파일 연결이 열려(쓰기 또는 추가) 함수 호출이 끝날 때 다시 닫힙니다. 동일한 파일에 반복해서 쓰려면 연결을 명시적으로 선언하고 열어 각 출력 함수 호출에 연결 객체를 전달하는 것이 더 효율적입니다. 이를 통해 파이프에 쓸 수도 있으며, 이는 @code{file = "|cmd"} 구문을 통해 제한적으로 구현되었습니다(여전히 사용할 수 있음).

@findex writeLines
연결에 완전한 텍스트 줄을 작성하는 @code{writeLines} 함수가 있습니다.

간단한 예시는 다음과 같습니다.

@example
zz <- file("ex.data", "w")  # 출력 파일 연결 열기
cat("TITLE extra line", "2 3 5 7", "", "11 13 17", 
    file = zz, sep = "\n")
cat("One more line\n", file = zz)
close(zz)

## 출력에서 십진점을 쉼표로 변환, 파이프 사용 (Unix)
## R 문자열과 (아마도) 셸에서 \\ 두 번 사용
zz <- pipe(paste("sed s/\\\\./,/ >", "outfile"), "w")
cat(format(round(rnorm(100), 4)), sep = "\n", file = zz)
close(zz)
## 이제 출력 파일을 확인하십시오:
file.show("outfile", delete.file = TRUE)

## R 출력 캡처: help(lm)의 예제 사용
zz <- textConnection("ex.lm.out", "w")
sink(zz)
example(lm, prompt.echo = "> ")
sink()
close(zz)
## 이제 'ex.lm.out'에 출력이 포함되어 추가 처리가 가능합니다.
## 예를 들어 다음과 같이 확인할 수 있습니다.
cat(ex.lm.out, sep = "\n")
@end example

@node 연결로부터의 입력, 연결 목록 및 조작, 연결을 통한 출력, 연결
@section 연결로부터의 입력

@findex scan
@findex read.table
@findex readLines
연결에서 읽는 기본 함수는 @code{scan} 및 @code{readLines}입니다. 이러한 함수는 문자열 인수를 사용하고 함수 호출 동안 파일 연결을 엽니다. 하지만 파일 연결을 명시적으로 열면 파일을 다양한 형식으로 순차적으로 읽을 수 있습니다.

다른 함수들은 특히 @code{read.table}과 함께 @code{scan}을 호출하여 연결을 사용할 수도 있습니다.

간단한 예시는 다음과 같습니다.

@example
## 이전 예시에서 생성된 파일 읽기
readLines("ex.data")
unlink("ex.data")

## 현재 디렉토리 목록 읽기 (Unix)
readLines(pipe("ls -1"))

# 입력 파일에서 끝에 오는 쉼표 제거.
# 예를 들어, 'data' 파일이 다음과 같이 주어졌다고 가정합니다.
450, 390, 467, 654,  30, 542, 334, 432, 421,
357, 497, 493, 550, 549, 467, 575, 578, 342,
446, 547, 534, 495, 979, 479
# 그렇다면 이것을 다음과 같이 읽습니다.
scan(pipe("sed -e s/,$// data"), sep=",")
@end example

@cindex URL 연결
편의를 위해, @code{file} 인수가 FTP, HTTP 또는 HTTPS @acronym{URL}을 지정하면, @code{url}을 통해 @acronym{URL}을 읽기 위해 연결이 열립니다. @samp{file://foo.bar}를 통해 파일을 지정하는 것도 허용됩니다.

@menu
* Pushback::                    
@end menu

@node Pushback,  , 연결로부터의 입력, 연결로부터의 입력
@subsection Pushback

@findex pushBack.
@cindex 연결에서의 Pushback
C 프로그래머들은 텍스트 입력 스트림에 문자를 다시 밀어 넣는 @code{ungetc} 함수를 알고 있을 것입니다. @R{} 연결은 @code{pushBack}을 호출하여 연결에 (기본적으로) 임의의 텍스트 줄을 다시 밀어 넣을 수 있는 더 강력한 방법으로 동일한 아이디어를 가지고 있습니다.

Pushback은 스택처럼 작동하므로, 읽기 요청은 가장 최근에 밀려온 텍스트의 각 줄을 먼저 사용한 다음 이전에 밀려온 텍스트의 줄을 사용하고 마지막으로 연결 자체에서 읽습니다. 밀려온 줄이 완전히 읽히면 지워집니다. 밀려있는 줄의 수는 @code{pushBackLength}를 호출하여 찾을 수 있습니다.
@findex pushBackLength

간단한 예시를 통해 아이디어를 확인할 수 있습니다.

@example
> zz <- textConnection(LETTERS)
> readLines(zz, 2)
[1] "A" "B"
> scan(zz, "", 4)
Read 4 items
[1] "C" "D" "E" "F"
> pushBack(c("aa", "bb"), zz)
> scan(zz, "", 4)
Read 4 items
[1] "aa" "bb" "G"  "H" 
> close(zz)
@end example

Pushback은 텍스트 모드에서 입력을 위해 열린 연결에서만 사용할 수 있습니다.

@node 연결 목록 및 조작, 이진 연결, 연결로부터의 입력, 연결
@section 연결 목록 및 조작
@cindex 연결

@findex showConnections
사용자가 현재 열어둔 모든 연결에 대한 요약은 @code{showConnections()}를 사용하여 찾을 수 있으며, 종료된 연결과 터미널 연결을 포함한 모든 연결에 대한 요약은 @code{showConnections(all = TRUE)}를 사용하여 찾을 수 있습니다.

@findex seek
@findex isSeekable
일반적인 함수 @code{seek}은 읽기 또는 쓰기를 위한 현재 위치를 읽고(일부 연결에서) 재설정하는 데 사용할 수 있습니다. 불행히도 이것은 OS 기능에 따라 신뢰할 수 없을 수 있습니다(예: Windows에서의 텍스트 파일). 함수 @code{isSeekable}은 @code{seek}이 인수로 주어진 연결의 위치를 변경할 수 있는지 여부를 보고합니다.

@findex truncate
함수 @code{truncate}은 쓰기를 위해 열린 파일을 현재 위치에서 잘라내는 데 사용할 수 있습니다. 이 기능은 @code{file} 연결에서만 작동하며, 모든 플랫폼에서 구현되지는 않습니다.


@node 이진 연결,  , 연결 목록 및 조작, 연결
@section 이진 연결
@cindex 이진 파일

@findex readBin
@findex writeBin
함수 @code{readBin}과 @code{writeBin}은 이진 연결에서 읽고 쓰기를 수행합니다. 연결은 mode에 @code{"b"}를 추가하여 바이너리 모드로 열립니다. 즉, 읽기를 위해 mode @code{"rb"}를 사용하고 쓰기를 위해 mode @code{"wb"} 또는 @code{"ab"}(해당하는 경우)를 사용합니다. 함수는 다음 인수를 사용합니다.

@example
readBin(con, what, n = 1, size = NA, endian = .Platform$endian) 
writeBin(object, con, size = NA, endian = .Platform$endian) 
@end example

각 경우에 @code{con}은 연결이며, 필요한 경우 호출 동안 열립니다. 문자열이 주어지면 파일 이름을 지정한다고 가정합니다.

쓰기를 먼저 설명하는 것이 약간 더 간단하므로 먼저 설명하겠습니다. @code{object}는 원자 벡터 객체여야 합니다. 즉, 속성이 없는 mode @code{numeric}, @code{integer}, @code{logical}, @code{character}, @code{complex} 또는 @code{raw} 벡터입니다. 기본적으로 이것은 메모리에 표시된 대로 파일에 바이트 스트림으로 작성됩니다.

@code{readBin}은 파일에서 바이트 스트림을 읽고 @code{what}에 의해 지정된 mode의 벡터로 해석합니다. 이것은 적절한 mode의 객체(예: @code{what=integer()}) 또는 mode를 설명하는 문자열(이전 문단에서 언급된 다섯 가지 중 하나 또는 @code{"double"} 또는 @code{"int"})이 될 수 있습니다. 인수 @code{n}은 연결에서 읽을 최대 벡터 요소 수를 지정합니다. 더 적은 요소가 사용 가능한 경우 더 짧은 벡터가 반환됩니다. 인수 @code{signed}는 1바이트와 2바이트 정수를 부호 있는(기본값) 또는 부호 없는 정수로 읽을 수 있습니다.

나머지 두 인수는 다른 프로그램이나 다른 플랫폼과 데이터를 주고받기 위해 읽고 쓰는 데 사용됩니다. 기본적으로 이진 데이터는 메모리에서 연결로 직접 전송되거나 그 반대로 전송됩니다. 이것은 데이터가 다른 아키텍처를 가진 기계로 전송되어야 하는 경우에는 충분하지 않지만, 거의 모든 @R{} 플랫폼 간에 필요한 변경은 바이트 순서뿐입니다. 일반 PC(@cputype{ix86} 기반 및 @cputype{x86_64} 기반 기계), Compaq Alpha 및 Vaxen은 @emph{little-endian}이고, 반면에 Sun Sparc, mc680x0 시리즈, IBM R6000, SGI 및 대부분의 다른 기계들은 @emph{big-endian}입니다. (네트워크 바이트 순서(XDR, eXternal Data Representation에서 사용됨)는 big-endian입니다.) 다른 프로그램과 주고받을 때는 더 많은 작업이 필요할 수 있습니다. 예를 들어, 16비트 정수를 읽거나 단정밀도 실수를 작성해야 할 수도 있습니다. 이 작업은 @code{size} 인수를 사용하여 수행할 수 있으며, 일반적으로 정수와 논리 값에 대해 크기 1, 2, 4, 8을 허용하고, 실수 값에 대해 크기 4, 8, 그리고 아마도 12 또는 16을 허용합니다. 다른 크기로 전송하면 정밀도가 떨어질 수 있으며, @code{NA}를 포함하는 벡터의 경우 시도하지 않아야 합니다.

@findex readChar
@findex writeChar
문자열은 C 형식으로 읽고 쓰여집니다. 즉, 0 바이트로 종료되는 바이트 문자열로서, 함수 @code{readChar}과 @code{writeChar}은 더 큰 유연성을 제공합니다.

@menu
* 특수 값::              
@end menu

@node 특수 값,  , 이진 연결, 이진 연결
@subsection 특수 값

함수 @code{readBin}과 @code{writeBin}은 누락된 값과 특수 값을 전달할 수 있으나, 크기 변경이 포함된 경우에는 시도하지 않아야 합니다.

@R{} 논리 및 정수 유형에 대한 누락된 값은 @code{INT_MIN}으로, C 헤더 @file{limits.h}에 정의된 가장 작은 표현 가능한 @code{int} 값입니다. 일반적으로 비트 패턴 @code{0x80000000}에 해당합니다.

@R{} 숫자 및 복소수 유형에 대한 특수 값의 표현은 기계 종속적이며, 컴파일러 종속적일 수도 있습니다. 가장 간단한 방법은 외부 응용 프로그램을 독립 실행형 @code{Rmath} 라이브러리와 연결하고 이중 상수 @code{NA_REAL}, @code{R_PosInf}, @code{R_NegInf}를 내보내며, 매크로 @code{ISNAN}과 @code{R_FINITE}를 정의하는 헤더 @file{Rmath.h}를 포함시키는 것입니다.

이것이 불가능한 경우, 현재 모든 플랫폼에서 IEC 60559 (즉, IEEE 754) 산술이 사용되므로, 표준 C 기능을 사용하여 @code{Inf}, @code{-Inf}, @code{NaN} 값을 테스트하거나 설정할 수 있습니다. 이러한 플랫폼에서 @code{NA}는 하위 워드 @code{0x7a2} (10진수로는 1954)를 가진 @code{NaN} 값으로 표현됩니다.

문자 누락 값은 @code{NA}로 작성되며, 문자 값을 누락된 것으로 인식할 준비가 없습니다(이것은 읽은 후 다시 할당함으로써 수행할 수 있습니다).

@node 네트워크 인터페이스, Excel 스프레드시트 읽기, 연결, 상위
@chapter 네트워크 인터페이스

@menu
* 소켓에서 읽기::        
* download.file 사용하기::         
@end menu

네트워크 연결을 통해 데이터를 더 낮은 수준에서 교환할 수 있는 기능이 제한적으로 제공됩니다.

@node 소켓에서 읽기, download.file 사용하기, 네트워크 인터페이스, 네트워크 인터페이스
@section 소켓에서 읽기

@cindex 소켓
기본 @R{}은 일반적인 Linux, Unix, Windows 포트를 포함하여 이들을 지원하는 시스템에서 @acronym{BSD} 소켓을 통해 통신할 수 있는 기능을 제공합니다. 소켓을 사용하는 데있어 잠재적인 문제점은 보안상의 이유나 웹 캐시의 사용을 강제하기 위해 이러한 기능이 종종 차단되어 있다는 것입니다. 따라서 이러한 함수들은 인터넷보다 내부 네트워크에서 더 유용할 수 있습니다. 새 프로젝트에서는 대신 소켓 연결이 사용되는 것이 좋습니다.

@findex make.socket
@findex read.socket
@findex write.socket
@findex close.socket
이전의 저수준 인터페이스는 @code{make.socket}, @code{read.socket}, @code{write.socket}, @code{close.socket} 함수로 제공됩니다.


@node download.file 사용하기,  , 소켓에서 읽기, 네트워크 인터페이스
@section @code{download.file} 사용하기

함수 @code{download.file}은 FTP 또는 HTTP(HTTPS 포함)를 통해 웹 리소스에서 파일을 읽어서 파일에 쓰는 데 사용됩니다. 종종 이것을 피할 수 있습니다. 왜냐하면 @code{read.table}과 @code{scan}과 같은 함수들은 @code{url}을 사용하여 명시적으로 연결을 여는 것이나 @code{file} 인수로 URL을 제공함으로써 암시적으로 사용하여 URL에서 직접 읽을 수 있기 때문입니다.


@node Excel 스프레드시트 읽기, 참조, 네트워크 인터페이스, 상위
@chapter Excel 스프레드시트 읽기

@findex .xls
@findex .xlsx

가장 일반적인 R 데이터 가져오기/내보내기 질문은 'Excel 스프레드시트를 어떻게 읽을 수 있을까요' 인 것 같습니다. 이 장에서는 이전에 제공된 조언과 옵션을 모아 놓았습니다. 주의할 점은 대부분의 조언이 Excel 2007 이전의 스프레드시트를 위한 것이며 나중의 @file{.xlsx} 형식은 아닙니다.

@findex read.csv
@findex read.delim
@findex read.DIF
@findex read.table
@findex readClipboard
첫 번째 조언은 가능하면 그렇게 하지 않는 것입니다! Excel에 액세스할 수 있다면, 탭으로 구분되거나 쉼표로 구분된 형식으로 Excel에서 원하는 데이터를 내보내고, @code{read.delim} 또는 @code{read.csv}를 사용하여 R로 가져옵니다. (소수점으로 쉼표를 사용하는 로케일에서는 @code{read.delim2} 또는 @code{read.csv2}를 사용해야 할 수도 있습니다.) DIF 파일을 내보내고 @code{read.DIF}를 사용하여 읽는 것도 가능한 방법입니다.

Excel이 없다면, Windows와 Unix 모두에서 텍스트 형식으로 내보내기가 가능한 스프레드시트를 읽고 다른 많은 프로그램이 있습니다. 예를 들어 Gnumeric (@uref{http://www.gnumeric.org})과 OpenOffice (@uref{https://www.openoffice.org})가 있습니다. 이러한 프로그램에서 스프레드시트를 표시하고 R 사이에서 자르고 붙여넣을 수도 있습니다. @code{read.table}은 R 콘솔에서 읽거나, Windows에서 클립보드에서 읽을 수 있습니다. (@code{file = "clipboard"} 또는 @code{readClipboard}를 통해). @code{read.DIF} 함수도 클립보드에서 읽을 수 있습니다.

Excel @file{.xls} 파일은 단순한 스프레드시트가 아닌 점에 유의하십시오. 이러한 파일에는 여러 시트가 포함될 수 있고, 시트에는 수식, 매크로 등이 포함될 수 있습니다. 모든 리더가 첫 번째 시트 이외의 것을 읽을 수 있으며, 파일의 다른 내용에 혼란스러울 수 있습니다.

@findex odbcConnectExcel
@findex odbcConnectExcel2007
32비트 @R{}를 사용하는 윈도우 사용자는 @CRANpkg{RODBC} 패키지의 @code{odbcConnectExcel}을 사용할 수 있습니다. 이를 통해 Excel 스프레드시트 파일의 모든 시트에서 행과 열을 선택할 수 있습니다(최소한 Excel 97~2003, ODBC 드라이버에 따라 다릅니다. @code{odbcConnect}를 직접 호출하여 Excel 3.0까지의 버전을 읽을 수 있습니다). @code{odbcConnectExcel2007} 버전은 Excel 2007 형식뿐만 아니라 이전 버전도 읽을 수 있습니다(드라이버가 설치되어 있어야 하며, 64비트 윈도우 @R{}도 포함됩니다: @pxref{RODBC}). 맥OS 사용자도 적절한 드라이버가 있으면(예: Actual Technologies에서 제공하는 드라이버) @CRANpkg{RODBC}를 사용할 수 있습니다.

@findex read.xls
@code{Perl} 사용자들은 @code{OLE::SpreadSheet::ParseExcel} 모듈과 @code{xls2csv.pl} 프로그램을 제공하여 Excel 95-2003 스프레드시트를 CSV 파일로 변환합니다. @CRANpkg{gdata} 패키지는 @code{read.xls} 함수에서 기본 래퍼를 제공합니다. 적절한 @code{Perl} 모듈이 설치되어 있으면 이 함수는 Excel 2007 스프레드시트도 읽을 수 있습니다.

@findex dataframes2xls
@findex WriteXLS
@CRANpkg{dataframes2xls}와 @CRANpkg{WriteXLS} 패키지 각각에는 하나 이상의 데이터 프레임을 @file{.xls} 파일로 @emph{쓰는} 함수가 포함되어 있으며, 각각 Python과 Perl을 사용합니다.

@findex xlsx
@CRANpkg{xlsx} 패키지는 Excel 2007 이후의 스프레드시트를 읽고 조작할 수 있으며, Java가 필요합니다.

@findex XLConnect
@CRANpkg{XLConnect} 패키지는 Java를 사용하여 Excel 97-2003 및 Excel 2007/10 스프레드시트를 읽고, 쓰고, 조작할 수 있습니다.

@findex readxl
@CRANpkg{readxl} 패키지는 포함된 C 라이브러리를 사용하여 Excel 97-2003 및 Excel 2007/10 스프레드시트를 읽을 수 있습니다.

@node 참조, 함수 및 변수 색인, Excel 스프레드시트 읽기, 상위
@appendix 참조

@noindent
R.@: A.@: Becker, J.@: M.@: Chambers and A.@: R.@: Wilks (1988)
@emph{The New S Language.  A Programming Environment for Data Analysis
and Graphics.}  Wadsworth & Brooks/Cole.

@noindent
J.@: Bowman, S.@: Emberson and M.@: Darnovsky (1996) @emph{The
Practical @acronym{SQL} Handbook.  Using Structured Query Language.}
Addison-Wesley.

@noindent
J.@: M.@: Chambers (1998) @emph{Programming with Data.  A Guide to the S
Language.} Springer-Verlag.

@noindent
P.@: Dubois (2000) @emph{MySQL.} New Riders.

@noindent
M.@: Henning and S.@: Vinoski (1999) @emph{Advanced CORBA Programming
with C++.} Addison-Wesley.

@noindent
K.@: Kline and D.@: Kline (2001) @emph{SQL in a Nutshell.} O'Reilly.

@noindent
B.@: Momjian (2000) @emph{PostgreSQL: Introduction and Concepts.}
Addison-Wesley.
Also available at @uref{https://momjian.us/main/writings/pgsql/aw_pgsql_book/}.

@noindent
B.@: D.@: Ripley (2001) Connections. @emph{R News}, @strong{1/1}, 16--7.
  @uref{https://www.r-project.org/doc/Rnews/Rnews_2001-1.pdf}


@noindent
T.@: M.@: Therneau and P.@: M.@: Grambsch (2000) @emph{Modeling Survival
Data.  Extending the Cox Model.} Springer-Verlag.

@noindent
E.@: J.@: Yarger, G.@: Reese and T.@ King (1999) @emph{MySQL & mSQL}.
O'Reilly.

@node 함수 및 변수 색인, 개념 색인, 참조, 상위
@unnumbered 함수 및 변수 색인

@printindex vr

@node 개념 색인,  , 함수 및 변수 색인, 상위
@unnumbered 개념 색인

@printindex cp


@bye

@c Local Variables: ***
@c mode: TeXinfo ***
@c End: ***
